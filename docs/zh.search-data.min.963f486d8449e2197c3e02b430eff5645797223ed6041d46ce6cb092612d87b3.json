[{"id":0,"href":"/docs/BDL/2.medium/17.interface/1.interface-tree/","title":"1.前言--抽象界面","section":"第十七章 用户界面","content":"抽象界面\r#\r\r在编程领域中，GUI 界面如何描述一直是桌面程序开发中的一个难题。 在 BDL 中，我们使用 XML 来描述界面，BDL 操作界面作为补充。\nXML是一种标记语言，它并不是编程语言。\n你如果了解HTML，那么你就可以轻松理解XML。XML是一种要求严格的HTML，但他们实际并不存在包含不包含关系。\n在\r百度首页，按下F12，你能看到如下界面，这就是HTML语言。XML也遵循着类似的结构风格。\n\rXML 语法\r#\r\r XML 语法仅需要了解即可，并不会要求能够写出一个标准的 XML。只需要了解即可。\n XML的语法非常简单，它由标签组成，标签分为开始标签和结束标签。\n名词介绍\r#\r\r\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;note name=\u0026#34;n1\u0026#34; \u0026gt;  \u0026lt;to\u0026gt;Tove\u0026lt;/to\u0026gt;  \u0026lt;from\u0026gt;Jani\u0026lt;/from\u0026gt;  \u0026lt;heading\u0026gt;Reminder\u0026lt;/heading\u0026gt;  \u0026lt;body\u0026gt;Don\u0026#39;t forget me this weekend!\u0026lt;/body\u0026gt; \u0026lt;/note\u0026gt; 以上 XML 代码中，\n  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; 是 XML 的申明\n  任何一个 \u0026lt;...\u0026gt;到它的\u0026lt;.../\u0026gt;被称作元素，元素也被称为节点，是同一个意思\n 以下是一个元素   \u0026lt;note name=\u0026#34;n1\u0026#34; \u0026gt;  \u0026lt;to\u0026gt;Tove\u0026lt;/to\u0026gt;  \u0026lt;from\u0026gt;Jani\u0026lt;/from\u0026gt;  \u0026lt;heading\u0026gt;Reminder\u0026lt;/heading\u0026gt;  \u0026lt;body\u0026gt;Don\u0026#39;t forget me this weekend!\u0026lt;/body\u0026gt; \u0026lt;/note\u0026gt;  以下也是一个元素  \u0026lt;to\u0026gt;Tove\u0026lt;/to\u0026gt;   元素中可以包含元素\n  \u0026lt;to\u0026gt;Tove\u0026lt;/to\u0026gt;中Tove是元素to的值\n  \u0026lt;note name=\u0026quot;n1\u0026quot; \u0026gt;中name=\u0026quot;n1\u0026quot;被称作属性，name是属性名，n1是属性值\n  XML 文档必须有根元素\r#\r\rXML 必须包含根元素，它是所有其他元素的父元素，比如以下实例中 root 就是根元素：\n\u0026lt;root\u0026gt;  \u0026lt;child\u0026gt;  \u0026lt;subchild\u0026gt;.....\u0026lt;/subchild\u0026gt;  \u0026lt;/child\u0026gt; \u0026lt;/root\u0026gt; 以下实例中 note 是根元素：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;note\u0026gt;  \u0026lt;to\u0026gt;Tove\u0026lt;/to\u0026gt;  \u0026lt;from\u0026gt;Jani\u0026lt;/from\u0026gt;  \u0026lt;heading\u0026gt;Reminder\u0026lt;/heading\u0026gt;  \u0026lt;body\u0026gt;Don\u0026#39;t forget me this weekend!\u0026lt;/body\u0026gt; \u0026lt;/note\u0026gt; XML 声明\r#\r\rXML 声明文件的可选部分，如果存在需要放在文档的第一行，如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; 所有的 XML 元素都必须有一个关闭标签\r#\r\r在 XML 中，每一个\u0026lt;...\u0026gt;必须对应一个\u0026lt;.../\u0026gt;\n\u0026lt;item\u0026gt;...\u0026lt;/item\u0026gt; XML 必须正确嵌套\r#\r\r以下是正确语法：\n\u0026lt;b\u0026gt;  \u0026lt;i\u0026gt;This text is bold and italic\u0026lt;/i\u0026gt; \u0026lt;/b\u0026gt; 以下语法是错误的：\n\u0026lt;b\u0026gt;  \u0026lt;i\u0026gt;This text is bold and italic\u0026lt;/b\u0026gt; \u0026lt;/i\u0026gt; XML 属性值必须加引号\r#\r\r在 XML 中，XML 的属性值必须加引号。\n请研究下面的两个 XML 文档。 第一个是错误的，第二个是正确的：\n\u0026lt;note date=12/11/2007\u0026gt;  \u0026lt;to\u0026gt;Tove\u0026lt;/to\u0026gt;  \u0026lt;from\u0026gt;Jani\u0026lt;/from\u0026gt; \u0026lt;/note\u0026gt; \u0026lt;note date=\u0026#34;12/11/2007\u0026#34;\u0026gt;  \u0026lt;to\u0026gt;Tove\u0026lt;/to\u0026gt;  \u0026lt;from\u0026gt;Jani\u0026lt;/from\u0026gt; \u0026lt;/note\u0026gt; 实体引用\r#\r\r在 XML 中，一些字符拥有特殊的意义。\n如果您把字符 \u0026ldquo;\u0026lt;\u0026rdquo; 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。\n这样会产生 XML 错误：\n\u0026lt;message\u0026gt;if salary \u0026lt; 1000 then\u0026lt;/message\u0026gt; 为了避免这个错误，请用实体引用来代替 \u0026ldquo;\u0026lt;\u0026rdquo; 字符：\n\u0026lt;message\u0026gt;if salary \u0026amp;lt; 1000 then\u0026lt;/message\u0026gt;    原符号 需替换为 说明     \u0026amp;lt; \u0026lt; 小于号   \u0026amp;gt; \u0026gt; 大于号   \u0026amp;amp; \u0026amp; and符   \u0026amp;apos; ' 单引号   \u0026amp;quot; \u0026quot; 双引号    XML 中的注释\r#\r\r\u0026lt;!-- This is a comment --\u0026gt; 验证XML是否合法\r#\r\r你可以在\rxmlvalidation验证你的xml是否正确。\nBDL界面XML语法\r#\r\rXML语法很简单，但BDL中不是随便写一个XML语法就可以产生页面，页面上不同的输入框、按钮、表格等都需要特定的元素名称才可以实现，BDL才能正确识别。\n我们先来看一下已有的文件的XML文件，在BDL中，我们调用的GUI文件是42f文件，p_zz主画面在azz/42f/p_zz.42f，让我们打开这个文件。\n我们截取其中一部分文件：\n\u0026lt;Page name=\u0026#34;page01\u0026#34; text=\u0026#34;Main\u0026#34;\u0026gt;  \u0026lt;Grid name=\u0026#34;gr3040\u0026#34; width=\u0026#34;72\u0026#34; height=\u0026#34;2\u0026#34;\u0026gt;  \u0026lt;Label text=\u0026#34;Program ID\u0026#34; posY=\u0026#34;0\u0026#34; posX=\u0026#34;1\u0026#34; gridWidth=\u0026#34;10\u0026#34;/\u0026gt;  \u0026lt;FormField name=\u0026#34;zz_file.zz01\u0026#34; colName=\u0026#34;zz01\u0026#34; sqlType=\u0026#34;VARCHAR(20)\u0026#34; required=\u0026#34;1\u0026#34; notNull=\u0026#34;1\u0026#34; fieldId=\u0026#34;0\u0026#34; sqlTabName=\u0026#34;zz_file\u0026#34; tabIndex=\u0026#34;1\u0026#34;\u0026gt;  \u0026lt;ButtonEdit width=\u0026#34;18\u0026#34; action=\u0026#34;controlp\u0026#34; image=\u0026#34;zoom\u0026#34; shift=\u0026#34;down\u0026#34; scroll=\u0026#34;1\u0026#34; comment=\u0026#34;KEY Field,No Blank/Repeated!\u0026#34; posY=\u0026#34;0\u0026#34; posX=\u0026#34;22\u0026#34; gridWidth=\u0026#34;20\u0026#34;/\u0026gt;  \u0026lt;/FormField\u0026gt;  \u0026lt;Label text=\u0026#34;Module ID\u0026#34; posY=\u0026#34;0\u0026#34; posX=\u0026#34;48\u0026#34; gridWidth=\u0026#34;9\u0026#34;/\u0026gt;  \u0026lt;FormField name=\u0026#34;zz_file.zz011\u0026#34; colName=\u0026#34;zz011\u0026#34; sqlType=\u0026#34;VARCHAR(10)\u0026#34; fieldId=\u0026#34;1\u0026#34; sqlTabName=\u0026#34;zz_file\u0026#34; tabIndex=\u0026#34;2\u0026#34; notNull=\u0026#34;1\u0026#34; required=\u0026#34;1\u0026#34;\u0026gt;  \u0026lt;ComboBox width=\u0026#34;7\u0026#34; queryEditable=\u0026#34;1\u0026#34; comment=\u0026#34;Which Module is the Program in. Fill it!\u0026#34; posY=\u0026#34;0\u0026#34; posX=\u0026#34;62\u0026#34; gridWidth=\u0026#34;9\u0026#34;/\u0026gt;  \u0026lt;/FormField\u0026gt;  \u0026lt;Label text=\u0026#34;Program Name\u0026#34; posY=\u0026#34;1\u0026#34; posX=\u0026#34;1\u0026#34; gridWidth=\u0026#34;12\u0026#34;/\u0026gt;  \u0026lt;FormField name=\u0026#34;gaz_file.gaz03\u0026#34; colName=\u0026#34;gaz03\u0026#34; sqlType=\u0026#34;VARCHAR(500)\u0026#34; fieldId=\u0026#34;2\u0026#34; sqlTabName=\u0026#34;gaz_file\u0026#34; tabIndex=\u0026#34;3\u0026#34; noEntry=\u0026#34;1\u0026#34;\u0026gt;  \u0026lt;Edit width=\u0026#34;38\u0026#34; comment=\u0026#34;Show Program Description\u0026#34; posY=\u0026#34;1\u0026#34; posX=\u0026#34;22\u0026#34; gridWidth=\u0026#34;38\u0026#34;/\u0026gt;  \u0026lt;/FormField\u0026gt;  \u0026lt;Button name=\u0026#34;modify_program_name\u0026#34; width=\u0026#34;5\u0026#34; text=\u0026#34;Update\u0026#34; posY=\u0026#34;1\u0026#34; posX=\u0026#34;62\u0026#34; gridWidth=\u0026#34;5\u0026#34; tabIndex=\u0026#34;503\u0026#34;/\u0026gt;  \u0026lt;/Grid\u0026gt; \u0026lt;/Page\u0026gt; \u0026lt;ComboBox width=\u0026#34;18\u0026#34; queryEditable=\u0026#34;1\u0026#34; posY=\u0026#34;2\u0026#34; posX=\u0026#34;27\u0026#34; gridWidth=\u0026#34;20\u0026#34;\u0026gt;  \u0026lt;Item name=\u0026#34;sm1\u0026#34; text=\u0026#34;sm1\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;sm2\u0026#34; text=\u0026#34;sm2\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;sm3\u0026#34; text=\u0026#34;sm3\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;popup\u0026#34; text=\u0026#34;popup\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;main\u0026#34; text=\u0026#34;main\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;dialog\u0026#34; text=\u0026#34;dialog\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;naked\u0026#34; text=\u0026#34;naked\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;viewer\u0026#34; text=\u0026#34;viewer\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;report\u0026#34; text=\u0026#34;report\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;err01\u0026#34; text=\u0026#34;err01\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;login\u0026#34; text=\u0026#34;login\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;view\u0026#34; text=\u0026#34;view\u0026#34;/\u0026gt;  \u0026lt;Item name=\u0026#34;lib\u0026#34; text=\u0026#34;lib\u0026#34;/\u0026gt; \u0026lt;/ComboBox\u0026gt; 可以看到上，元素的名称，属性都不是随便命名的：\n 元素名称FormField、Label定义了这个元素显示的时候的基本类型，如标签、输入框等。 元素的属性名name、width、posY、posY 分别指定了这个元素在页面上的显示位置，以及显示的类型。 复杂的元素如下拉框ComboBox，除了本身之外，还有子元素Item  那么这么多的不同的名称都需要记住才能写好BDL的GUI界面吗，当然不需要！\n安装GDC套件时，可选的genero studio既可以编写程序代码，也可以用鼠标拖拽的方式来生成BDL的GUI界面。\n所以你只要知道每种元素的名称，就可以用鼠标来生成界面，然后直接产生画面档文件即可。\n"},{"id":1,"href":"/docs/BDL/2.medium/16.module/1.%E9%87%8D%E6%96%B0%E5%9B%9E%E9%A1%BE%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/","title":"1.重新回顾编译链接","section":"第十六章 模块","content":"重新回顾编译链接\r#\r\r在\r第二章时，我们就介绍了r.c2与r.l2编译链接的命令。 还介绍了exe2运行的命令。\n现在我们新建一个czzi004.4gl程序：\nmain  display \u0026#34;program code is czzi004\u0026#34; end main 我们上传在$TOP/czz/4gl目录中，运行r.c2命令：\n如果环境没有问题，将输出类似下面结果:\nczzi004 .............. 编译成功，因为我们没有调用外部函数，所以不用链接也可以运行。\n我们使用exe2命令运行，如没有意外，会出现以下意外：\n\r这是因为我们在tiptop gp中，未通过p_zz作业建立程序，所以系统找不到执行文件目录。\n我们运行以下命令\ncd $CZZ/42m fglrun czz_czzi004 ... program code is czzi004 成功运行！这是因为我们的可执行文件是在czz/42m目录下，我们来看下42m生成的文件。\ncd $CZZ/42m ls -l *czzi004* -rw-rw-rw- 1 tiptop tiptop 242 Aug 28 14:46 czz_czzi004.42m -rw-rw-r-- 1 tiptop tiptop 52 Aug 28 14:46 czz_czzi004.4gl czz_czzi004.42m是4gl编译后的二进制文件，czz_czzi004.4gl是我们在使用r.d2+debug调式时需要的文件。\n而fglrun命令是真正的BDL执行文件，exe2命令其实是tiptop gp专用的运行命令，所以p_zz中没有录入的程序无法用exe2运行。\n既然运行有底层命令，那么编译、链接自然也有对应的底层命令。\nfglcomp\r#\r\r还是之前的czzi004.4gl文件，我们切换到4gl目录下，使用底层函数编译。\ncd $CZZ/4gl fglcomp czzi004.4gl 注意\n使用fglcomp编译时需要指定文件的全名，包括扩展名。\n\r错误\n如果出现这个报错，说明你的授权不包含编译授权，请运行命令FGLDIR=$FGLDIR.dev切换到测试环境编译。\nERROR(-6112):Compilation is not allowed: This product is licensed for runtime only. \r\r如果编译成功，不会有任何提示，我们运行ls -l *czzi04*查看当前目录下czzi004相关文件。\n-rw-rw-r-- 1 tiptop tiptop 211 Aug 28 14:59 czzi004.42m -rw-rw-r-- 1 tiptop tiptop 52 Aug 28 14:46 czzi004.4gl 可以看到，fglcomp编译后在当前目录产生了czzi004.42m文件，且并不产生额外的4gl文件。\n我们用fglrun命令运行以下。\ncd $CZZ/4gl fglrun czzi004 ... program code is czzi004 可以看到和r.c2编译后文件输出内容一样。\nfgllink\r#\r\r之前我们编写的程序，都是单一文件，所以并不需要链接操作。\n 现在我们再来写一个文件czz/4gl/s_czzi004.4gl  function add(a,b)  define a,b integer  return a+b end function 内容很简单一个可以返回两个整数之和的add()函数，我们先来编译fglcomp s_czzi004.4gl。\n如果没有写错，将在当前目录产生s_czzi004.42m文件。\nczzi004.4gl 调用add()  main  display \u0026#34;program code is czzi004\u0026#34;  + display sfmt(\u0026#34;2+3=%1\u0026#34;,add(2,3)) end main 重新编译czzi004.4gl  这个时候，czz/4gl目录下应该包含两个42m文件，czzi004.42m和s_czzi004.42m。\n如果你尝试运行任意一个文件，都会报错。\nfglrun czzi003\nprogram code is czzi004 Program stopped at \u0026#39;czzi004.4gl\u0026#39;, line number 3. FORMS statement error number -1338. The function \u0026#39;add\u0026#39; has not been defined in any module in the program. fglrun s_czzi004\nFORMS statement error number -1338. The function \u0026#39;main\u0026#39; has not been defined in any module in the program. 当调用外部函数时，我们需要使用fgllink链接命令将多个42m文件链接起来。\nfgllink -o czzi004.42r czzi004.42m s_czzi004.42m\n这时，查看当前目录，你能看到产生了一个czzi004.42r文件。运行42r文件能够正常得到运行结果。\nfglrun czzi004 program code is czzi004 2+3=5 总结\r#\r\rBDL中每一个可执行文件，只要经过3个步骤即可。\n fglcomp 编译  将主程序，和主程序要用到的程序源代码全部编译为42m文件\nfgllink 链接  将主程序和所有需要用到的程序42m文件链接为42r文件\nfglrun 运行  执行42r文件即可\n练习\r#\r\r在czzi004.4gl中调用lib中的cl_null()函数\r#\r\r 已知$LIB/4gl目录下载有cl_null.4gl文件，其中含有一个函数cl_null() cl_null()函数接受一个字符串参数 返回值为一个，数据类型为boolean 功能为判断一个字符串是否为空，或者只含有空格字符  "},{"id":2,"href":"/docs/BDL/2.medium/15.function_plus/1.parameter/","title":"1.函数的参数","section":"第十五章 函数进阶","content":"函数的参数\r#\r\r在BDL中除了变量定义，其它所有操作都需要在函数中进行。\n所以能够灵活使用函数是编程能力重要体现，使用函数时，除了程序逻辑需要考虑，如何定义函数的结构也是值得考虑的。\n函数的结构包括两部分，参数与返回值。\n参数个数\r#\r\r函数的参数个数是无上限的，且不是必须含有参数。\n\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD\r#\r\r0个参数\r#\r\r       1d67cdd5786f4fafd74c3017d23ade5bb17724be 如果你的函数不受程序的上下文影响，或者说不需要考虑调用之前做了哪些操作，那么你的函数就不要参数。\n       BDL自带函数中有不少类似函数如下：\nfgl_lastkey() --获取最后一次按下的按键 \u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD\r#\r\r任意个数参数\r#\r\r任意个数的参数需要在在定义function时就确认，参数时变量的一种，需要定义在函数体的括号中，由,作为分隔符。\n在函数中还必须定义所有参数的数据类型。 调用时传入的参数需要和定义的参数个数一样，且数据类型一致(可以转换的数据类型会自动转换)。\nmain  display add(1,\u0026#39;2\u0026#39;,3,\u0026#39;4\u0026#39;,...,n) end main function add(x1,x2,x3,x4,...,xn)  return x1+x2+x3+x4+...+xn function 参数类型\r#\r\r字符串、数值参数\r#\r\r在BDL中，基本类型只有两种字符串和数值，如果参数是这两种基础类型之一，那么参数是将实际的值传递到函数中。\n例如：\nmain  define x,y string  define i,j integer  let x = \u0026#39;demo\u0026#39;  let i = 2  let j = 3  display sfmt(\u0026#39;add(i,j) is %1,i is %2 ,j is %3\u0026#39;,add(i,j),i,j)   let y = ext(x)  display sfmt(\u0026#34;x is %1 y is %2\u0026#34;,x,y) end main function add(a,b)  define a,b integer  let a = a + 1  let b = b + 1  return a+b end function function ext(x)  define x string  let x = x+\u0026#34;.ext\u0026#34;  return x end function 如上述例子，参数x,i,j是将值传递到函数中，函数中会将传递过来的值赋值到自己的变量中。\n所有无论函数如何对自己的变量进行操作，都不影响main函数中变量的值。\n结构体参数\r#\r\r虽然BDL中参数的个数不受限制，但是当参数个数过于多时，一个函数维护的难度就非常的复杂。例如：哪些参数对应什么功能，哪些参数可以为空，哪些参数不可以为空，参数的顺序。\n为了减少参数数量，我们可以使用结构体作为参数，这样参数的个数就变得可控了。\n并且结构体中只要将需要的成员赋值，其它成员即使没有初始化也可以传递参数给函数。\n结构体作为参数如下：\nmain  define l_ima record like ima_file.*  let l_ima.ima01 = \u0026#39;MRA-001\u0026#39;  call dis(l_ima.*) end main function dis(p_ima)  define p_ima record like ima_file.*  if p_ima.ima02 is null then  let p_ima.ima02 = \u0026#39;null\u0026#39;  end if  display sfmt(\u0026#39;料号：%1 品名：%2 规格：%3 \u0026#39;,p_ima.ima01,p_ima.ima02,p_ima.ima021) end function 结构体变量作为参数时传递的也是变量的值，在函数中修改参数的值，不会影响main函数中变量的值。\n注意\n结构体作为参数传参时，需要以变量名.*的形式传参。\n\r数组参数\r#\r\r在传递结构体时，我们传递了一行数据用dis函数显示出来，但是在实际的应用中，我们需要显示的不是一笔，而是多笔，10笔，20笔，甚至时上万笔。\n如果使用循环调用上万次dis函数，确实可以实现，但是这样会非常消耗内存，并且效率非常低下。 为了提高效率，我们可以使用数组作为参数，数组中存放结构体，这样就可以一次性将数据传递给函数。\nmain  define l_ima dynamic array of record like ima_file.*  define l_i integer  for l_i = 1 to 10000  let l_ima[l_i].ima01 = sfmt(\u0026#39;MRA-%1\u0026#39;,l_i using \u0026#39;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026#39;)  end for  call dis(l_ima)  display l_ima[1].ima02 --!!!!! end main function dis(p_ima)  define p_ima dynamic array of record like ima_file.*  define l_i integer  for l_i = 1 to p_ima.getLenght()  if p_ima[l_i].ima02 is null then  let p_ima.ima02 = \u0026#39;null\u0026#39;  end if  display sfmt(\u0026#39;料号：%1 品名：%2 规格：%3 \u0026#39;,p_ima[l_i].ima01,p_ima[l_i].ima02,p_ima[l_i].ima021)  end for  end function 发现了吗，上述例子中，运行后，main函数中的数组变量的值也被修改了！！\n数组变量作为参数时，传递的不是值，而是数组变量在内存中的内存地址，所以你在dis函数中修改的数组中任何内容，在main中也是同步修改。\n实际上这不是数组作为参数的特殊性，而是数组的特殊性。\n数组在内存中是一块连续的内存空间，数组保存的是每块内存空间的地址，而不是每块内存空间的值。\n所以在dis函数中数组和main函数中数组随便变量名不同，但是他们地址指向的内存块都是同一块，所以修改也是同步生效，在任意函数中修改，在任意函数中都只能看到修改后的内容。\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rgraph LR a[\"1\"]--b[\"0x001\"]\rb--b1[\"物理内存\"]\rc[\"2\"]--d[\"0x002\"]\rd--d1[\"物理内存\"]\rh[\"...\"]--g[\"...\"]\rg--g1[\"...\"]\re[\"n\"]--f[\"0x00n\"]\rf--f1[\"物理内存\"]\r注意\n数组作为参数时，传递的指针，对数组进行修改，会永久影响整个数组变量的值。\n\r       1d67cdd5786f4fafd74c3017d23ade5bb17724be\n       "},{"id":3,"href":"/docs/BDL/2.medium/14.database/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/","title":"1.数据库连接","section":"第十四章 数据库使用","content":"数据库连接\r#\r\rTIPTOP GP/T100 在按照时会配置号数据库，一般为ORACLE DB，也可能是postgresql。\n本章所有内容都是基于ORACLE DB，但大部门内容应该是通用的。\n数据库已经配置的连接可以在文件$FGLPROFILE中看见，这里配置好的数据库都是可以在BDL中使用的。\n连接数据库\r#\r\r在已有的BDL代码中我们经常见到在main函数外，有一个databse ds语句。\ndatabase就是连接数据库的语句，ds就是要连接的数据库。ds为TIPTOP中一个特殊的数据库，此数据保存了所有表的表结构，和同义词表的数据。\n 同义词值得是不同库之间都可以使用的一个表，但此表实际只保存在ds库，每个库查看的数据内容都是相同的。\n database ds1即可切换到ds1数据库中。\nmain funtion main()的区别\r#\r\rmain end main 还可以写出function的格式function main() end function。\n这两者在连接数据库时是有区别main end main 会自动连接到 main之外的databse ds数据库。 而function main() end function只会用到databse ds的表结构，而不会自动连接到数据库。\n 使用表结构的方法在下一节将会讲到\n 除此之外他们还有另一个区别main end main需定义在一个模块所有函数之前，而function main() end function的位置没有限制。\n"},{"id":4,"href":"/docs/BDL/2.medium/13.struct/1.record/","title":"1.结构体","section":"第十三章 结构体","content":"结构体\r#\r\r仍以人为例来介绍，要管理姓名、单位、E-mail地址、 联系电话等信息，现实生活中，很多人采用名片的形式，将这些信息印在一张卡片上。\n收集的一张张名片大大方便了数据的管理，将这种理念借鉴到BDL语言程序设计中，是否有类似于名片的那么一种变量呢?\n有，答案就是“结构体变量”，这是一种复合变量，在进一步说明结构体变量前，先来看“结构体”的概念，结构体和结构体变量的关系类似与类型与普通变量的关系，结构体中说明了结构体变量的信息格式，而结构体变量是结构体的实例。\n结构体的定义\r#\r\r只有先完成结构体的定义，才能声明并使用结构体变量，正如，只有确定了名片，上要印什么内容，才能开始印刷名片。结构体的定义即是为了说明结构体变量要存储什么信息的过程。\ndefine 变量 record  存储数据列表  end record 举例说明：\ndefine person record  name,age varchar(20),  email varchar(50)  end record 上面我们定义了一个变量person，这个变量没有实际的累计，既不是字符串也不是数字。而其内有有另外类似变量的定义name、age和email。\n结构体定义规则：\n 每个成员名称符合标识符规则 在同一个结构体中名称不得重复 每个成员定义后要加,号，最后一个成员不能加, 与下一个成员类型一致，可以省略类型  访问结构体成员\r#\r\r习惯上我们将诸如字符串name、age和email在结构体变量内部这些变量称作数据成员（简称成员），有的时候也称作元素、属性。\n在定义了一个结构体变量后，我们使用成员操作符号.来访问每个成员，例如person.name、person.age，分别表示person这个变量中储存的姓名年纪等信息。\n提示\n结构体成员，和我们之前使用的变量的方法都是使用.操作符号来访问/调用。他们的区别在于方法需要有()，而成员没有()。\n\r我们看一段示例代码：\n define zhangsan record  name varchar(20),  age integer,  email varchar(50)  end record   let zhangsan.name = \u0026#34;zhang san\u0026#34;  let zhangsan.age = 24  let zhangsan.email = \u0026#34;zhangsan@outlook.com\u0026#34;  display sfmt(\u0026#34;\\nname:%1\u0026#34;,zhangsan.name)  display sfmt(\u0026#34;age:%1\u0026#34;,zhangsan.age)  display sfmt(\u0026#34;email:%1\u0026#34;,zhangsan.email) 输出结果:\nname:zhang san\rage:24\remail:zhangsan@outlook.com 初始化结构体变量\r#\r\r当你的结构体变量需要重复使用时，你不知道之前的结构体哪些成员有值，哪些成员没有值了。\n难道要访问每个成员复制为空值吗？\n我们有一个快速将结构体所有成员赋空值的关键字：\ninitialize 结构体变量.* to null 批量访问成员变量\r#\r\r初始化所有成员时，我们使用了一个结构体变量.*方式。 这里的.*表示访问所有成员。\n除了访问所有成员，我们还可以指定一个成员范围。\ninitialize 结构体变量.成员1 thru 结构体变量.成员2 to null 需要注意的时thru连接的两个成员必须是同一个结构体变量，且只能在initialize、validate和locate中使用。\n请运行以下代码，观察其输出值：\n define zhangsan record  name varchar(20),  age integer,  email varchar(50)  end record  define lisi record  name varchar(20),  age integer,  email varchar(50)  end record   let zhangsan.name = \u0026#34;zhang san\u0026#34;  let zhangsan.age = 24  let zhangsan.email = \u0026#34;zhangsan@outlook.com\u0026#34;  let lisi.* = zhangsan.*  let lisi.name = \u0026#34;lisi\u0026#34;  display sfmt(\u0026#34;\\nname:%1\u0026#34;,zhangsan.name)  display sfmt(\u0026#34;age:%1\u0026#34;,zhangsan.age)  display sfmt(\u0026#34;email:%1\u0026#34;,zhangsan.email)  display sfmt(\u0026#34;\\nname:%1\u0026#34;,lisi.name)  display sfmt(\u0026#34;age:%1\u0026#34;,lisi.age)  display sfmt(\u0026#34;email:%1\u0026#34;,lisi.email) 输出结果：\nname:zhang san\rage:24\remail:zhangsan@outlook.com\rname:lisi\rage:24\remail:zhangsan@outlook.com 利用let lisi.* = zhangsan.*可以赋值两个成员和对应数据类型一样的结构体变量的值。\n"},{"id":5,"href":"/docs/BDL/2.medium/12.string/1.dynamic-string/","title":"1.动态长度字符串","section":"第十二章 字符串操作","content":"动态长度字符串\r#\r\r我们知道BDL中可以存放数据类型的类型有好几种，string、char、varchar。text和byte有特殊不再本章讨论范围。\n对于定长类型varchar、char也不再本章讨论范围内。之后所说字符串特指string类型的字符串。\n所以要处理除了string类型的字符串，需要先转换为string类型。\n如果最大长度允许，string 与char、varchar在大部分地方都可以自动转换。但在SQL语句中无法自动转换。\n注意\nBDL4.01版本之后string类型也可以用于SQL中。\n\r字符串的方法\r#\r\r字符串的处理，就是通过BDL预定义的方式实现的，因为方法是绑定数据类型，所以char和varchar都是不能调用字符串string的方法的。\n拼接字符串\r#\r\r语法\nappend(a string) returning s string 使用案例\n define s string\rlet s = \u0026#34;darcy\u0026#34;\rlet s = s.append(\u0026#34;.joven\u0026#34;) 除了调用方法，拼接字符串还有很多其它方式。\n 逗号拼接   define s string  let s = \u0026#34;darcy\u0026#34;,\u0026#34;.joven\u0026#34; 这是最常用的字符串拼接方法 2. ||拼接\n define s string  let s = \u0026#34;darcyjoven\u0026#34;||\u0026#34;\u0026#39;s blog\u0026#34; 这种方式与逗号拼接区别在于，不能存在空值，有任意一个字符串为空值，最后的结果都为空值 3. sfmt()拼接\n define s string  let s = sfmt(\u0026#34;darcy%1\u0026#34;,\u0026#34;joven\u0026#34;) sfmt()拼接的好处在于：非字符串类型为显示转换。\n字符串比较\r#\r\requals(s string) return b boolean 使用示例：\n define x,y string  let x = \u0026#34;darcyjoven\u0026#34;  let y = \u0026#34;darcy\u0026#34;  if x.equals(y) then  display \u0026#34;OK\u0026#34;  end if 相比equals，我们更经常用的比较字符串的方式是用==或者=直接判断。 例如：\n define x,y string  let x = \u0026#34;darcyjoven\u0026#34;  let y = \u0026#34;darcy\u0026#34;  if x == y then  display \u0026#34;OK\u0026#34;  end if 两只的区别是当两侧的值都为空值时，equals比较的结果是真，==比较的结果是假。\n string类型还有一个忽略大小写比较的方法，equalsIgnoreCase用法和equals一致\n 取子字符串/字符\r#\r\r用例：\n define s,a,b string  let s = \u0026#34;darcyjoven@gmail.com\u0026#34;  let a = s.getCharAt(11)  let b = s.subString(1,10) 需要注意的是，字符串第一个字符的位置是1。\n获取字符串长度\r#\r\r define s string  define a,b integer  let s = \u0026#34;darcyjoven \u0026#34;  let a = s.getLength()  let b = length(s)  display sfmt(\u0026#34;s.getLength() = %1 length(s) = %2\u0026#34;,a,b) 除了string的方法getLength()，BDL还有一个内置的函数lenght(s string) returning l integer可以获取字符串的长度。\n请编译以上代码，比较两只的区别。\n大小写转换\r#\r\r define s string  let s = \u0026#34;DarcyJoven\u0026#34;  let s = s.toLowerCase()  display sfmt(\u0026#34;\\nmy name is %1\u0026#34;,s)  let s = s.toUpperCase()  display sfmt(\u0026#34;my name is %1\u0026#34;,s) 去除空格\r#\r\r define a,b string  let a = \u0026#34; darcy joven\u0026#39;s email is darcyjoven@gmail.com \u0026#34;  let b = a.trim()  display b  let b = a.trimLeft()  display b  let b = a.trimRight()  display b 其它常见字符串操作\r#\r\r一些常用的字符串操作，一些字符串操作要借助其它数据类型，或者其它函数。\n这里介绍几种非常常用的用法。\n替代字符串\r#\r\r替代字符串是将原字符串中含有的部分字符串替换为新字符串，如果没有的话，仍输出原有字符串。\n此方法在string类型中没有，需要借助base.StringBuffer字符串流类型处理。\n使用办法：\n define buf base.StringBuffer  let buf = base.StringBuffer.create()  call buf.append(\u0026#34;darcyjoven@gamil.cn\u0026#34;)  call buf.replace(\u0026#34;cn\u0026#34;,\u0026#34;com\u0026#34;,0) -- 0 代表，要全部替换 ，其它正整数n，代表替换前n个  display buf.toString() 因为这个使用场景实在太多，tiptop产品依据替我们封装在了lib函数中。\ntiptop gp\r call cl_replace_init() -- 调用此函数表示全部替换，默认调用  call cl_replace_once() -- 调用此函数表示只替换一个  call cl_replace(\u0026#34;darcyjoven@gmail.cn\u0026#34;,\u0026#34;cn\u0026#34;,\u0026#34;com\u0026#34;) T100\r\r字符串分割\r#\r\r字符串分割是将一个字符串依据一个字符/字符串（分割符号）分割为多个子字符串。\n此操作需要借助base.StringTokenizer类型。\n 子字符串中不包含分隔符\n 示例：\n define s string  define tok base.StringTokenizer   let s = \u0026#34;darcyjoven@gmail.com;darcy_joven@live.com;darcy_joven@163.com;\u0026#34;  let tok = base.StringTokenizer.create(s,\u0026#34;;\u0026#34;)  while tok.hasMoreToken()  display tok.nextToken()  end while tok.hasMoreToken()判断是否还有值，如果有值，可以利用tok.nextToken()将下一个值取出来。\n需要注意的是tok.nextToken()取值的时候，会自动切换到下一个值，所以base.StringTokenizer只能顺序操作，不能返回上一个值操作。\n"},{"id":6,"href":"/docs/BDL/2.medium/11.array/1.what-is-array/","title":"1.什么是数组","section":"第十一章 数组-同一类型的多个元素的集合","content":"什么是数组\r#\r\r程序经常使用同类型的数据，比如要处理某个班级的学生成绩信息，如果只有几个学生，我们可以使用几个同类型的变量，比如：define mark0, mark1, mark2, mark3, mark4 integer;` 这样，便可以存放5个学生的成绩，但如果是几百人呢?要一直这么写下去吗?如果读者觉得继续写下去没什么不妥的话，那几千甚至几万人呢!所以，如何合理组织大量同类数据是个问题。\n在这种应用背景下，数组应运而生，成功解决了上述问题。\n数组是一大片连续的存储空间\r#\r\r声明一个数组时，编译器为数组分配内存存储空间，以存放多个同型数据。每个数据称为数组的一个元素，要存储的元素个数称为数组的大小，元素的类型称为数组的类型。数据占据的内存空间大小取决于数组的大小和类型，而且，编译器为数组分配一片连续的内存空间。很容易计算数组占据的内存大小和每个元素对应的内存首地址。\n下图，形象地示意了数组占据内存空间的情况，其中每个小方框代表一个内存字节，smallint占据2个内存字节，因此，数组中每个元素占据2个内存字节。\n\r数组元素的访问\r#\r\r下面来看要解决的第2个问题“每个数据应当有唯一的标识符进行读写和查找”，这是通过下标来实现的。以一-维数组为例，元素的访问形式为:\n数组名[下标] 举例来说，有一个数组，名为mark,里面记录着全班60个人的成绩，mark中的第1个元素可写为mark[1]，第2个元素为mark[2]，第3个元素为mark[3]，以此类推，第60个元素为mark[60]，好了，结束。有效的下标为1到N,不在此范围的下标访问都会引发越界错误。 线界错误是初学者经常犯错的地方。\n了解了数组的基本组织形式，下面具体看一下如何使用数组解决实际问题。\n"},{"id":7,"href":"/docs/BDL/2.medium/10.function/1.what-is-function/","title":"1.什么是函数","section":"第十章 函数入门-写程序就是写函数","content":"什么是函数\u0026ndash;根据输入进行处理返回输出\r#\r\r代码编多了会发现一个问题:一些通用的操作，比如交换两个变量的值、对一组变量进行排序等，可能在多个程序中都会用到，不仅如此，在单独一个程序中也可能会对某个代码段执行多次。\n问题\n有必要在每次执行时都把该代码段书写一次吗?这不仅会让程序变得很长，而且难以理解，使可读性下降。\n\r分割\r#\r\r为了解决以上问题，C语言将程序按功能分割成-.系列的小模块，所谓“小模块”，可理解为完成-定功能的可执行代码块，称之为“函数”。\n函数是BDL语言源程序的基本功能单位，打个比方，可以将函数视为一个黑盒子，或“加工设备”，从一头输人数据(原材料),从另一头就可以得到结果(产品)。至于函数内部是如何工作的，外部并不关心。 C语言源程序均是由函数组成的，在前面章节中给出的示例代码，只有一个main函数，这仅适用于比较简单的问题，实际的程序往往由多个函数组成。函数的调用是由另\u0026ndash;个函数发起的，举例来说，在A函数中调用B函数，从B函数的角度上说，A函数可视为外部函数,外部函数A对“函数B是如何定义的，功能是如何实现的”毫不关心，A对B所知道的仅限于输入给B什么，以及B输出什么。\n标准函数、lib/sub函数和自定义函数\r#\r\r为了方便解决一些基本问题，BDL语言提供了一些标准函数。 除此之外，tiptop gp和T100都集成了一些经常使用的函数。\n 注意这是产品提供的，不是BDL语言提供的，可以被修改，增加。\n 除了上述函数外，BDL也允许用户自定义函数以便灵活解决各种问题，用户可以将自己的算法编写为一个个相对独立的函数模块，用调用的方法来使用函数。\n从某种程度上说，BDL全部功能都是由这样或那样的函数实现的。\n"},{"id":8,"href":"/docs/Practice/basic/","title":"基础练习题","section":"BDL练习题","content":"基础练习题\r#\r\r基础练习题目，并不是指难度基础，而是不涉及到除了语言特性其它的范围。\n不涉及到画面规格（GUI）、和数据库等，专注于 BDL 基础语法。\n反而某些题目难度可能很大，不必强求所有题目都能解出，果断时间再来看，可能就可以解出了。\n第 1 题\r#\r\r 已完成√\n 题目： 有 1、2、3、4 四个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？\n程序分析： 可填在百位、十位、个位的数字都是 1、2、3、4，组成所有的排列后再去掉不满足条件的排列。\r\r第 2 题\r#\r\r 已完成√\n 题目： 企业发放的奖金根据利润提成。\n 利润(I)低于或等于 10 万元时，奖金可提 10%； 利润高于 10 万元，低于 20 万元时，低于 10 万元的部分按 10%提成，高于 10 万元的部分，可提+ 成 7.5%； 20 万到 40 万之间时，高于 20 万元的部分，可提成 5%； 40 万到 60 万之间时高于 40 万元的部分，可提成 3%； 60 万到 100 万之间时，高于 60 万元的部分，可提成 1.5%； 高于 100 万元时，超过 100 万元的部分按 1%提成。 从键盘输入当月利润 I，求应发放奖金总数？  程序分析： 请利用数轴来分界，定位。注意定义时需把奖金定义成双精度浮点(double)型。\r\r第 3 题\r#\r\r题目： 一个整数，它加上 100 后是一个完全平方数，再加上 168 又是一个完全平方数，请问该数是多少？\n程序分析： 假设该数为 x。\n 则：x + 100 = n2, x + 100 + 168 = m2 计算等式：m2 - n2 = (m + n)(m - n) = 168 设置： m + n = i，m - n = j，i * j =168，i 和 j 至少一个是偶数 可得： m = (i + j) / 2， n = (i - j) / 2，i 和 j 要么都是偶数，要么都是奇数。 从 3 和 4 推导可知道，i 与 j 均是大于等于 2 的偶数。 由于 i * j = 168， j\u0026gt;=2，则 1 \u0026lt; i \u0026lt; 168 / 2 + 1。 接下来将 i 的所有数字循环计算即可。  \r第 4 题\r#\r\r 已完成√\n 题目： 输入某年某月某日，判断这一天是这一年的第几天？\n程序分析： 以 3 月 5 日为例，应该先把前两个月的加起来，然后再加上 5 天即本年的第几天，特殊情况，闰年且输入月份大于 3 时需考虑多加一天。\r\r第 5 题\r#\r\r 已完成√\n 题目： 输入三个整数 x,y,z，请把这三个数由小到大输出。\n程序分析： 我们想办法把最小的数放到 x 上，先将 x 与 y 进行比较，如果 x\u0026gt;y 则将 x 与 y 的值进行交换，然后再用 x 与 z 进行比较，如果 x\u0026gt;z 则将 x 与 z 的值进行交换，这样能使 x 最小。\r\r第 6 题\r#\r\r 已完成√\n 题目： 用*号输出字母 C 的图案。\n程序分析： 可先用\u0026rsquo;*\u0026lsquo;号在纸上写出字母 C，再分行输出。\r\r第 7 题\r#\r\r 已完成√\n 题目： 打印楼梯，同时在楼梯上方打印两个笑脸。\n程序分析：\n用 i 控制行，j 来控制列，j 根据 i 的变化来控制输出黑方格的个数。\n:):)\r##\r####\r######\r########\r##########\r############ \r\r第 8 题\r#\r\r 已完成√\n 题目： 输出 9*9 口诀。\n程序分析： 分行与列考虑，共 9 行 9 列，i 控制行，j 控制列。\r\r第 9 题\r#\r\r题目： 古典问题（兔子生崽）：有一对兔子，从出生后第 3 个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？（输出前 40 个月即可）\n程序分析： 兔子的规律为数列 1,1,2,3,5,8,13,21\u0026hellip;.，即下个月是上两个月之和（从第三个月开始）.\r\r第 10 题\r#\r\r题目： 判断 101 到 200 之间的素数。\n程序分析： 判断素数的方法：用一个数分别去除 2 到 sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。\r\r第 11 题\r#\r\r题目： 打印出所有的\u0026quot;水仙花数\u0026quot;，所谓\u0026quot;水仙花数\u0026quot;是指一个三位数，其各位数字立方和等于该数 本身。例如：153 是一个\u0026quot;水仙花数\u0026quot;，因为 153=1 的三次方＋ 5 的三次方＋ 3 的三次方。\n程序分析： 利用 for 循环控制 100-999 个数，每个数分解出个位，十位，百位。\r\r第 12 题\r#\r\r题目： 将一个正整数分解质因数。例如：输入 90,打印出 90=2*3*3*5。\n程序分析： 对 n 进行分解质因数，应先找到一个最小的质数 k，然后按下述步骤完成：\n 如果这个质数恰等于（小于的时候，继续执行循环）n，则说明分解质因数的过程已经结束，另外 打印出即可。 但 n 能被 k 整除，则应打印出 k 的值，并用 n 除以 k 的商,作为新的正整数 n.重复执行第二步。 如果 n 不能被 k 整除，则用 k+1 作为 k 的值,重复执行第一步。  \r第 13 题\r#\r\r 已完成√\n 题目： 利用条件运算符的嵌套来完成此题：学习成绩\u0026gt;=90 分的同学用 A 表示，60-89 分之间的用 B 表示，60 分以下的用 C 表示。\n程序分析： iif(a\u0026gt;b,a,b) 这是条件运算符的基本例子。\r\r第 14 题\r#\r\r题目： 输入两个正整数 m 和 n，求其最大公约数和最小公倍数。\n程序分析：\n  最小公倍数=输入的两个数之积除于它们的最大公约数，关键是求出最大公约数；\n  求最大公约数用辗转相除法（又名欧几里德算法）\n    证明：设 c 是 a 和 b 的最大公约数，记为 c=gcd(a,b),a\u0026gt;=b, 令 r=a mod b 设 a=kc，b=jc，则 k，j 互素，否则 c 不是最大公约数 据上，r=a-mb=kc-mjc=(k-mj)c 可知 r 也是 c 的倍数，且 k-mj 与 j 互素，否则与前述 k，j 互素矛盾, 由此可知，b 与 r 的最大公约数也是 c，即 gcd(a,b)=gcd(b,a mod b)，得证。\n  算法描述：\n  第一步：a ÷ b，令 r 为所得余数（0≤r 第二步：互换：置 a←b，b←r，并返回第一步。\n\r第 16 题\r#\r\r题目： 输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。\n程序分析： 取字符串第几位。\r\r第 18 题\r#\r\r 已完成√\n 题目： 求 s=a+aa+aaa+aaaa+aa\u0026hellip;a 的值，其中 a 是一个数字由键盘输入。 例如 2+22+222+2222+22222(此时共有 5 个数相加)，几个数相加由键盘输入。\n程序分析： 关键是计算出每一项的值。\r\r第 19 题\r#\r\r题目： 一个数如果恰好等于它的因子之和，这个数就称为\u0026quot;完数\u0026quot;。例如 6=1 ＋ 2 ＋ 3.编程找出 1000 以内的所有完数。\n程序分析： 参考正整数分解质因数\r\r第 20 题\r#\r\r 已完成√\n 题目： 一球从 100 米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第 10 次落地时，共经过多少米？第 10 次反弹多高？\n第 21 题\r#\r\r 已完成√\n 题目： 猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下 的一半零一个。到第 10 天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。\n程序分析： 采取逆向思维的方法，从后往前推断。\n 设 x1 为前一天桃子数，设 x2 为第二天桃子数， 则：  x2=x1/2-1, x1=(x2+1)*2\nx3=x2/2-1, x2=(x3+1)*2\n以此类推： x 前=(x 后+1)*2\n从第 10 天可以类推到第 1 天，是一个循环过程。  \r第 22 题\r#\r\r问题： 两个乒乓球队进行比赛，各出三人。甲队为 a,b,c 三人，乙队为 x,y,z 三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a 说他不和 x 比，c 说他不和 x,z 比，请编程序找出三队赛手的名单。\n第 23 题\r#\r\r 已完成√\n 题目： 打印出如下图案（菱形）。\n *\r***\r*****\r*******\r*****\r***\r*\r 程序分析： 先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重 for 循环，第一层控制行，第二层控制列。\r\r第 24 题\r#\r\r 已完成√\n 题目： 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13\u0026hellip;求出这个数列的前 20 项之和。 程序分析： 请抓住分子与分母的变化规律。\r\r第 25 题\r#\r\r 已完成√\n 题目： 求 1+2!+3!+\u0026hellip;+20!的和。 程序分析： 此程序只是把累加变成了累乘。\r\r第 26 题\r#\r\r题目： 利用递归方法求 5!。 程序分析： 递归公式：fn=fn_1*4!\r\r第 27 题\r#\r\r题目： 利用递归函数调用方式，将所输入的 5 个字符，以相反顺序打印出来。\n第 28 题\r#\r\r题目： 有 5 个人坐在一起，问第五个人多少岁？他说比第 4 个人大 2 岁。问第 4 个人岁数，他说比第 3 个人大 2 岁。问第三个人，又说比第 2 人大两岁。问第 2 个人，说比第一个人大两岁。最后问第一个人，他说是 10 岁。请问第五个人多大？ 程序分析： 利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10 岁），再往回推。\r\r第 29 题\r#\r\r 已完成√\n 题目： 给一个不多于 5 位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。 程序分析： 学会分解出每一位数。\r\r第 30 题\r#\r\r题目： 一个 5 位数，判断它是不是回文数。即 12321 是回文数，个位与万位相同，十位与千位相同。 程序分析： 学会分解出每一位数。\r\r第 31 题\r#\r\r题目： 请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。 程序分析： 用情况语句比较好，如果第一个字母一样，则判断用情况语句或 if 语句判断第二个字母\r\r第 32 题\r#\r\r题目： 删除一个字符串中的指定字母，如：字符串 \u0026ldquo;aca\u0026rdquo;，删除其中的 a 字母。\n第 33 题\r#\r\r题目： 判断一个数字是否为质数。 程序分析： 质数（prime number）又称素数，有无限个。一个大于 1 的自然数，除了 1 和它本身外，不能被其他自然数整除。\r\r第 34 题\r#\r\r题目： 字符串反转，如将字符串 \u0026ldquo;\rwww.runoob.com\u0026rdquo; 反转为 \u0026ldquo;moc.boonur.www\u0026rdquo;。\n第 35 题\r#\r\r题目： 求 100 之内的素数。 程序分析：\n质数（prime number）又称素数，有无限个。一个大于 1 的自然数，除了 1 和它本身外，不能被其他自然数整除。\n\r第 36 题\r#\r\r**题目：**对 10 个数进行排序。 程序分析：\n可以利用选择法，即从后 9 个比较过程中，选择一个最小的与第一个元素交换， 下次类推，即用第二个元素与后 8 个进行比较，并进行交换。\n\r第 37 题\r#\r\r题目： 求一个 3*3 矩阵对角线元素之和 程序分析：\n利用双重 for 循环控制输入二维数组，再将 a[i,i]累加后输出。\n\r第 38 题\r#\r\r题目： 有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。 程序分析：\n首先判断此数是否大于最后一个数,然后再考虑插入中间的数的情况,插入后此元素之后的数,依次后移一个位置。\n\r第 39 题\r#\r\r题目： 将一个数组逆序输出。 程序分析：\n用第一个与最后一个交换。\n\r第 40 题\r#\r\r题目： 打印出杨辉三角形（要求打印出 10 行）。 程序分析：\n结构如下：\n 1\r1 1\r1 2 1\r1 3 3 1\r1 4 6 4 1 \r\r第 41 题\r#\r\r题目： 输入 3 个数 a,b,c，按大小顺序输出。\n第 42 题\r#\r\r题目： 输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。\n第 43 题\r#\r\r题目： 有 n 个整数，使其前面各数顺序向后移 m 个位置，最后 m 个数变成最前面的 m 个数。 程序分析：\n可以使用一个辅助数组来保存需要移动的元素，然后再将元素按照要求移动到正确的位置。\n\r第 44 题\r#\r\r题目： 有 n 个人围成一圈，顺序排号。从第一个人开始报数（从 1 到 3 报数），凡报到 3 的人退出圈子，问最后留下的是原来第几号的那位。\n第 45 题\r#\r\r题目：\n写一个函数，求一个字符串的长度，在 main 函数中输入字符串，并输出其长度。 程序分析：\r\r第 46 题\r#\r\r题目： 编写 input()和 output()函数输入，输出 5 个学生的数据记录。\n程序分析：\n学生信息包括姓名、性别、年纪。请用 record 实现。\n\r第 47 题\r#\r\r题目： 输入一个整数，并将其反转后输出。 程序分析：\n拆分每一位\n\r第 48 题\r#\r\r题目： 编写一个函数，输入 n 为偶数时，调用函数求 1/2+1/4+\u0026hellip;+1/n,当输入 n 为奇数时，调用函数 1/1+1/3+\u0026hellip;+1/n(利用指针函数)。\n第 49 题\r#\r\r题目： 海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只 猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了 一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的， 问海滩上原来最少有多少个桃子？\n第 50 题\r#\r\r题目： 809*??=800*??+9*?? 其中??代表的两位数, 809*??为四位数，8*??的结果为两位数，9*??的结果为 3 位数。求??代表的两位数，及 809*??后的结果。\n第 51 题\r#\r\r**题目：**八进制转换为十进制\n第 52 题\r#\r\r题目： 求 0—7 所能组成的奇数个数。 程序分析：\n这个问题其实是一个排列组合的问题，设这个数为 sun=a1a2a3a4a5a6a7a8,a1-a8 表示这个数的某位的数值，当一个数的最后一位为奇数时，那么这个数一定为奇数，不管前面几位是什么数字。如果最后一位数为偶数，则这个数一定为偶数。\na1-a8 可以取 0-7 这个八个数字，首位数字不为 0。 从该数为一位数到该数为 8 位数开始统计奇数的个数：\n  当只有一位数时也就是该数的最后一位，奇数个数为 4\n  当该数为两位数时，奇数个数为 4*7=28\n  当该数为三位数时，奇数个数为：487=224\n\u0026hellip;\n  当该数为八位数时，奇数个数为：4888888*7(依次为最后一位到第一位)\n  \r第 53 题\r#\r\r题目： 一个偶数总能表示为两个素数之和。 程序分析：\n我去，这是什么题目，要我证明这个问题吗？真不知道怎么证明。那就把一个偶数分解成两个素数吧。\n\r第 54 题\r#\r\r题目：\n判断一个素数能被几个 9 整除。\n程序分析：\n丫的！这题目的意思是判断一个素数能整除几个 9 组成的数吧？我就这么理解吧。素数是不 能被除 1 和自身之外的数整除的\n\r第 55 题\r#\r\r题目： 程序分析：\r\r第 56 题\r#\r\r题目： 读取 7 个数（1—50）的整数值，每读取一个值，程序打印出该值个数的 ＊。\n第 57 题\r#\r\r题目： 某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下： 每位数字都加上 5,然后用和除以 10 的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。\n第 58 题\r#\r\r题目： 猜数字游戏，用户可以输入数字，提示用户输入的数字是大了，还是小了。 猜中后提示一共猜了多少次，并可以选择是否继续猜数字。\n第 59 题\r#\r\r题目： 从键盘输入一个字符串，将小写字母全部转换成大写字母，然后输出到一个磁盘文件\u0026quot;test\u0026quot;中保存。 输入的字符串以！结束。\n第 60 题\r#\r\r题目： 有两个磁盘文件 A 和 B,各存放一行字母，要求把这两个文件中的信息合并（按字母顺序排列），输出到一个新文件 C 中。\n程序分析：\n你需要先创建 A.txt 与 B.txt。 A.txt 文件内容：\n123\r B.txt 文件内容：\n456\r \r第 61 题\r#\r\r第 61 题\r#\r\r题目： 有五个学生，每个学生有 3 门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，况原有的数据和计算出的平均分数存放在磁盘文件\u0026quot;stud\u0026quot;中。\n"},{"id":9,"href":"/docs/BDL/1.basic/9.over_and_over_again/1.create-cycle/","title":"1.构造循环","section":"第九章 循环结构--一遍又一遍","content":"构造循环\r#\r\r循环结构有两大要素:循环条件和循环体，当满足某个条件时，重复执行某些动作，直到该条件不再满足，这个表述很好地体现了循环条件和循环体的关系。\n构造循环时，首先应明白要做什么，即“循环体是什么”，这是和程序的目的相关的。知道要干什么了还不够，还要明白什么时候开始做，什么时候停，如果没有设定合理的循环条件，很容易造成程序死循环，至使资源耗尽而导致电脑死机。\n举个最简单的例子，要求计算从1加到100，因为本章讨论的是循环，所以我们撇开高斯的简便方法((1+100)*50=5050)。\n程序的编写采用如下形式显然是不现实的:sum=1+2+3+.....+100写完这个式子就够费劲的，还好只有100个，要是有成千上万个，活活要累个半死。\n在这种应用背景下，需要使用循环结构，只要一小段代码，如下。\n define i,sum integer  while i\u0026lt;=100  let sum = sum + i  let i = i + 1  end while  display sfmt(\u0026#34;\\n结果是：%1\u0026#34;,sum) 输出结果是结果是：5050。\n代码解析\n代码中采用的是while结构，i作为加数，sum作为被加数，用以保存结果，程序的关键部分是第3~4行。\ni的初始值为1，当i小于等于100时( 循环条件)，会重复执行循环体，在循环体内做了两件事情，- -是将i和sum相加，结果重新保存到sum中，二是将i增加1，一步步逼近循环结束的条件。\n由此可知，循环条件和循环体相互配合完成特定的功能。一次次的循环，距离循环结束 应越来越近，避免出现死循环，试想，如果循环体中只是完成let sum=sum+i 这一操，而不对i进行修改，那么循环条件i\u0026lt;=100 的条件将一 直满足，循环永不会终止。\n注意 在代码中，即使要计算1加到10000，只要将100修改为10000即可，十分方便快捷。\r\r语法规则\r#\r\rwhile 表达式  循环结构体 end while 在while结构中，表达式既可以是逻辑表达式或关系表达式，也可以是普通表达式，甚至常量或变量，判断的关键这个值是否为真（非0），下面看一下表达式仅是个变量的示例：\n define sum,i integer  let i =100  while i  let sum = sum + i  let i = i -1  end while  display sfmt(\u0026#34;\\n结果是：%1\u0026#34;,sum) 编译运行后结果为：\n结果是：5050 代码解析\n两种代码实现了同样的结果，第二种i初始值为100，在循环体结构中逐次-1，知道i变为0，循环条件不满足，程序退出，完成了1+2+3+...+100的计算。\n"},{"id":10,"href":"/docs/BDL/1.basic/8.condition/1.judgment-statement-if/","title":"1.if语句--简单条件判断","section":"第八章 条件判断-分支结构","content":"if语句\u0026ndash;简单条件判断\r#\r\r生活中充满了选择，在BDL语言编程中同样如此。 最简单的条件判断语句是if语句，其基本格式为：\nif 判断表达式 then\r语句1\r语句2\r...\rend if 判断表达式\r#\r\r判断表达式可以是简单的逻辑语句(逻辑表达式或关系表达式)，可以是多个逻辑语句的“与”、“或”、“非”组合，也可以是一般表达式，甚至还可以是一个变量或常量。\n执行到if结构时，该表达式的值被首先计算，当判断表达式的值不为0 (真) 时，if then后花括号中的结构体代码被执行，否则，跳过if end if中的代码。\n做个形象的比方，在街上购物的时候，看到某件商品，常常会这样想:如果不高于50块，就买下了，否则，就继续逛街。用if结构可表述为:\nif 商品价格\u0026lt;50 then\r买下它\rend if 看一下下列代码:\n define price integer  prompt \u0026#34;请输入商品价格（正整数）：\u0026#34; for price  if price \u0026lt; 50 then  display \u0026#34;\\n好，买好了\u0026#34;  end if 当输入的金额小于50时，控制台输出的结果为\n好，买好了 否则为空。\n"},{"id":11,"href":"/docs/BDL/1.basic/7.atoml_statement/1.statement-type/","title":"1.语句类型","section":"第七章 语句-程序最小构成单元","content":"语句类型\r#\r\r前文已经介绍过，BDL中有4中类型的语句，分别是表达式语句、流程控制语句、函数调用语句和符和语句。\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rflowchart LR\ra[\"BDL语言\"]\rb1[\"表达式语句\"]\rb2[\"函数调用语句\"]\rb3[\"复合语句\"]\rb4[\"流程控制语句\"]\rc1[\"运算符表达式语句\"]\rc2[\"赋值语句\"]\rc3[\"结构化语句\"]\rc4[\"非结构化语句\"]\rd1[\"条件语句\"]\rd2[\"循环语句\"]\rd3[\"限定转向语句\"]\rd4[\"非限定转向语句\"]\re1[\"if语句\"]\re2[\"case语句\"]\re3[\"while语句\"]\re4[\"for语句\"]\re5[\"break语句\"]\re6[\"continue语句\"]\re7[\"return语句\"]\re8[\"goto语句\"]\ra--b1\ra--b2\ra--b3\ra--b4\rb1--c1\rb1--c2\rb4--c3\rb4--c4\rc3--d1\rc3--d2\rc4--d3\rc4--d4\rd1--e1\rd1--e2\rd2--e3\rd2--e4\rd3--e5\rd3--e6\rd3--e7\rd4--e8\r表达式语句\r#\r\r在上一章，我们已经介绍了表达式的概念，通俗说，“有表达式组成的语句叫做表达式语句”。\n表达式语句只有一种赋值表达式，在BDL中不允许计算一个值而不使用。\n下属语句都是赋值语句：\n let x = 3  let x = x + 1  let y = 1 \u0026gt; 2 函数调用语句\r#\r\r以下语句都是函数调用语句。\ncall add() call minux() returning x 复合语句\r#\r\r以下语句是调用函数后，将函数的值赋值给变量。 即使函数调用右是赋值语句。\nlet x = add (a,b)\rlet y = sfmt(\u0026#34;today is %1\u0026#34;,today) 流程控制语句\r#\r\r从前面流程图，可以看到流程控制语句最为茂盛，这是本章的关键点。 到目前位置，所接触的代码都是顺序执行的，按语句的书写顺序从上向下一条条执行，如：\n 语句1  语句2  语句3 在实际应用中，程序并不一定按书写的顺序来执行，可能希望在某处设置多条路径，由程 序选择一条来执行。 以人爬山来类比，上山可能有多条路，在分岔口处需要登山者做出选择，如果体力状态不错，可以选坡陡难爬的一条路，如果很疲劳了，可以选平缓容易的路，或者干脆下山。 这种选择机制提供了解决问题的灵活性。\n说明 有时程序希望对某块代码重复多次执行，按顺序方式将这块代码复制、粘贴多次是很笨的方法，且无法控制循环的次数。\r\r能否引入一些控制结构，以解决选择和重复执行的问题，“流程控制”应运而生。 流程控制语句分为结构化语句和非结构化语句两部分，结构化语句包含条件语句(处理分支情况)和循环语句(处理重复情况)，而非结构化语句用于一些特殊的跳转，有一种“便捷通道”的味道。继续讨论流程控制前，先来看一下BDL语言的结构化和算法。\n"},{"id":12,"href":"/docs/BDL/1.basic/6.operators_and_expressions/1.operators/","title":"1.运算符和表达式","section":"第六章 运算符和表达式-程序基本构成","content":"认识BDL语言中的运算符和表达式\r#\r\r在前面的章节中，已经接触过运算符和表达式了。 可以说，运算符和表达式是BDL语言的最基本构成，没有运算符和表达式，则不能编写任何程序。 程序的任务是对数据进行处理，数据是程序处理的对象，而运算符是施加给这些数据的操作。数据和运算符是表达式的基本元素。\n认识运算符和表达式\r#\r\r最近本的运算符，莫过于加、减、乘、除四则运算了\n1+1\r2*4\r10-20\r100/3 由于键盘无法输出算数中的乘号(✖)，和出号(➗)，改用*和、代替。删改你的例子都是常量参与运算，在BDL中，变量也可以参与运算，如：\ndefine a,b,c integer let a = 0 let b = 10 b - a a +b +10 a+b+10/b 上面的每一个式子都可以称为一个表达式。 BDL中的算术表达式和普通算术中的表达式写法基本一样，运算符两边是参与运算的对象，非常容易理解； 而有些语言，其表达式的写法非常古怪，让人望而生畏。 同样地，算术运算中，除数是不能为0的，在计算机中，如果除数为0，将产生一个“除数为0的异常”。 所以上面的示例中，有一个表达式因为除数为0，将使得程序运行崩溃。\n另外在给变量赋值的时候，使用赋值运算符=，如：\nlet a = a+b+10/b let b = a+b+10 在介绍这个运算符的时候，特别强调了它和算术运算中的等号“=”的区别。 BDL中的“=”，是将右边的值赋给左边的变量，而并不表示等号两边相等。 在BDL中，要表示两边是否相等，可用“==”表示（你也可能见到过使用一个“=”比较大小的，这样语法也没问题，但建议使用两个），即两个等号连接在一起，用来检查等号两边是否相等。 类似这种进行两个对象的大小关系比较的运算，是一种关系运算。\n操作数、运算符和表达式\r#\r\r参与运算的对象称做操作数（operator）。 如3+5中的3和5，a+b+10中的a，b和10，他们是参与具体预算的对象。同样地：\n(3+5)*a 这个表达式中，对于运算符“*”，两边的操作数就分别是(3+5)和a。 可见，操作数也可以是比较复杂的对象。 3+5也可以看做是一个加法表达式。\n运算符是指定要执行某项操作的一个标志符号，它指明了对操作数所进行的运算。 如“+”号，表示了一个相加运算;“==” 号表示了一个关系判断是否“ 相等”的运算。 表达式表示一个求值的规则。 表达式是由变量、常量、运算符、函数和圆括号按一定的规则组合而成的。 BDL语言的表达式可根据运算的不同而分为不同的表达式类型，如算术表达式、关系表达式、函数表达式等。一般来说，表达式有如下的书写规则。\n 运算符不能相邻。如a+-b是错误的。 乘号不能省略。如x乘以y应写成: x*y， 不能写成xy。 可用多层括号表示运算次序，括号必须成对出现，均使用小括号。  注意\n一个常量，例如390，也可以说是一个表达式；同样，一个变量x，也可以说是一个表达式。\r\rBDL运算符简介\r#\r\rBDL语言的内部运算符很丰富，范围也很宽。 运算符告诉编译器去执行特定的算术或逻辑操作。 BDL语言有两大类运算符:算术、关系与逻辑。 另外，BDL还有一些特殊的运算符，用于完成一些特殊的任务。 如下：\n关系运算符\n   运算符 描述     is null 判断控制   like 如果字符串和给定的格式匹配成功返回true   matches 如果字符串和给定的格式匹配成功返回true   相同(==or=) 判断两个值是否相同   不相同(!=or\u0026lt;\u0026gt;) 判断两个值是否不相同   小于\u0026lt; 判断左边的值小于右边   小于等于\u0026lt;= 判断左边的值小于等于右边   大于\u0026gt; 判断左边的值大于右边   大于等于\u0026gt;= 判断左边的值大于等于右边   nvl() 如果第一参数为空，返回第二个参数   iif() 如果第一个参数为true,返回第二个参数，否则返回第三个参数   in() 判断值是否在一个范围内    逻辑运算符\n   运算符 描述     not 如果右边表示大为true返回false，如果为flase，返回true   and 如果左边和右边表达式都为true,返回true,否则false   or 如果左边和右边表达式都为false,返回false,否则true    算数运算符\n   运算符 描述     + 左加右   - 左减右   * 两数相乘   / 左除以右   ** 计算幂   mod 左边对右边求余数    字符串运算符\n   运算符 描述     ascii() 依据ascii码变为字符   column 生成空行   `    using 格式化   clipped 去掉尾部空格   ord() 依据字符变为ascii码   spaces 空格   lstr() 本地化字符串   sfmt() 根据占位符替换值    关联语句运算符\n   运算符 描述     () 设置运算符优先顺序   . 对象成员分割符   [] 数组索引下标    交互运算符\n   运算符 描述     get_fldbuf() 返回指定字段当前值   infield() 判断是否在指定栏位   field_touched() 判断执行栏位是否修改过    "},{"id":13,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/1.input-proces-output/","title":"1.输出-处理-输出","section":"第五章 利用键盘、鼠标与程序交互","content":"输出-处理-输出\u0026ndash;这就是程序\r#\r\r工厂的生产车间生产出来的产品是最终的输出。\n比如某药厂生产的保健药，号称是经历了80多道工序。 这些工序，当然是从输入原材料开始，每道工序处理-件事情，最终生产出包装精美的保健药品。\n第一道工序，清洗，输人的是刚刚采摘下来的药材，其中，有不少的烂叶子、烂根。 清洗工序处理完毕后，输出来的是干净的有用的药材。\n第二道工序，榨汁，输人的是干净有用的药材，榨汁工序处理时，添加纯净水，榨出药汁。 接着是萃取工序，将药汁中的有用的部分苹取.来\u0026hellip;.80多道工序就这样一一处理完毕， 保健 药就制作完毕。\n从进场时的原材料，到最终出产的保健药，就是一个“输入一处理一输出” 的过程。 深入到药厂中的处理部分，80多道工序，每个工序也是一个“输入- -处理一输出”的过程。 没有输入，就没有处理的素材，也就没有输出。\n程序就是这样，根据输人进行不同的处理，输入不同，处理结果不同，这就是程序。 没有输出的程序是没有用的;没有输入的程序，缺乏灵活性，因为运行一次后，由于处理的数据相同，下一次运行结果也\u0026ndash;样，而程序在多次运行时，用到的数据可能是不同的。\n在程序运行时，由用户临时根据情况输人所需的数据，可以提高程序的通用性，增加程序的利用价值。\nBDL语言中有多种多样的输出方式，大部分是封装好的函数，只要调用就可以将结果输出出来。之前我们使用的display后面直接方变量或者直接写的字符串数字，就可以将结果直接打印输出到控制到命令行。本章我们还会介绍输入和其它输出方式。\n"},{"id":14,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/1.binary-octal-hexadecimal/","title":"1.二进制、八进制、十六进制","section":"第四章 存储和获取数据","content":"二进制、八进制、十六进制\r#\r\r二进制、八进制和十六进制是计算机中常用的进制形式。N进制的算法就是逢N进1。\n 二进制  二进制数使用0和1两个数码来表示的书，如111110112表示二进制。它的基数是2，进位规则是“逢二进一”。\n八进制  八进制是用0~7 8个数码来表示的数，如1678,进为规则是“逢八进一”。\n十六进制  十六进制是用0~9和A~F 16个字符表示，如1AE16,它的基数是16,进为规则为“逢16进1”。\n"},{"id":15,"href":"/docs/BDL/1.basic/3.composition_of_bdl/1.BDL-look/","title":"1.BDL程序全貌","section":"第三章 最简单bdl程序的组成","content":"BDL程序全貌\r#\r\rdatabase ds main  display sfmt(\u0026#34;hello world\u0026#34;) end main 代码很短，只有几行就建立一个可运行的程序。 代码虽小，但五脏俱全，纵观整个代码，可以总结如下特点：\n  代码有单词、符号、空白组成。 单词以英语单词为主，有的单词是纯正的英语单词，如main、display、end、database；有的不是如sfmt。代码中的标点符号并不是随意输入的。 每个符号在编程中都有特定含义。 单词于单词之间用空白分割，空白可以是空格，也可以是tab制表符。个数没有限制\n  BDL源码是从上往下阅读，也就是源码的先后顺序是有讲究的。\n  行与行之前可以有空白行，数量也没有限制。 有的行顶格书写，有的却向后退了几个空格，这种后退，成为“缩进”。如何缩进也是有讲究的。 3. 并没有专门的标识标识文件从哪里开始，也没标识文件从哪里结束。从第一个字符开始，文件就开始了，到最后一个字符结束，文件就结束了。\n"},{"id":16,"href":"/docs/BDL/1.basic/2.first_code/1.wirte-program-by-youself/","title":"1.自己动手创建程序","section":"第二章 第一行代码","content":"自己动手创建程序\r#\r\r就像小学生解决应用题一样，在答题之前，必须了解题目给的条件，然后明确题目的问题，最后才是解题。 开发软件也需要这样一个过程，必须先清楚用户的需求，根据需求来进行设计和开发，不遗漏需求，也不能有超过需求的功能。\n本章的目标就是创建一个可以执行的程序，并输出一句话：“Hello World”。如果读者看了这个要求就开始写代码，就烦了大忌。 这个需求起始很不明确，并没有规定如何输出这句话。 在实际的软件发开工作中，类似不明确的需求比比皆是，所以动手写代码前，一定要非常明确软件的需求。\n很多曾经有过语言学习经理的读者看见上面的需求后，第一印象，认为就是在控制台打印出这句话来，然后就开始思索如何设计程序了。 但假设用户需求是用人声读出这句话呢？发声也是一种输出！ 或者用户需求是在一个窗口界面输出这句话，甚至要求这句话的大小、样式、颜色符和某种规定，那么只在控制台打印“Hello World！”的程序是不符合要求的。 所以在开发软件前，用大量的时间进行实际需求的调研时非常有必要的。 否则，花费大量时间出来的程序可能没有任何价值。\n更明确的修去时：在控制台程序中，输出依据简单的文字：“Hello World！”。具体要求明确后就可以开始程序设计了。\n本章只是引导大家了解BDL语言，故没有输入，只有输出。\n"},{"id":17,"href":"/docs/BDL/1.basic/1.before_all/1.why-dbl/","title":"1.为什么学习（使用）BDL语言","section":"第一章 踏上征程前的思想动员","content":"为什么学习（使用）BDL语言\r#\r\r开发迅速\r#\r\rBDL配套的开发工具和GUI都是打包好，所以开发周期非常的短，也不需要考虑过多的事情。\n程序易读性高\r#\r\r如果你使用过SQL查询语言，或者对数据库有一定了解，甚至对excel使用比较熟练，你会发现BDL的处理方式与它们非常相似。\n不得不使用\r#\r\r你的公司使用了BDL语言的产品，现在要修改或者增加功能，不得不去读，写BDL程序。\n"},{"id":18,"href":"/docs/BDL/","title":"BDL有钱途的编程语言(tiptop)","section":"Docs","content":"BDL 语言发开\r#\r\rBusiness Development Language(BDL) 是 4js 公司 4js 开发一款商业发开软件，因为其语言后缀名为4gl，也被成为4gl语言或者fgl语言。\n鼎捷旗下tiptop gp T100系列 ERP 软件就是使用此商业语言开发。\n"},{"id":19,"href":"/docs/Practice/medium/","title":"进阶练习题","section":"BDL练习题","content":"第 1 题\r#\r\r题目： 输入两个正整数，输出这两个数的最小公倍数，和最大公约数。\n程序分析：\n 两个自然数的公倍数是指能被两个自然数整除的最小正整数 公倍数是能够被这两个数整除的数  \r第 2 题\r#\r\r题目： 输出 1~200 之间的素数\n程序分析：\n素数，是只能被 1 或自身整除的整数\n\r第 3 题\r#\r\r题目：\n打印 100 以内除了尾数为 3、5、7 的所有自然数\n程序分析：\n获取一个数的个位数\n\r第 4 题\r#\r\r题目： 输入一个数，判断该数是否是水仙花数\n水仙花数：是指一个三位数，其各位数字立方和等于该数字本身 例如：153 就是一个水仙花数，因为 153 = 1³ + 5³ + 3³\n程序分析：\n获取一个数的各个位数数字\n\r第 5 题\r#\r\r题目：\n输入一个华氏温度，要求输出摄氏温度。公式为 c=5(F-32)/9，取位2小数。\n程序分析：\n温度应该是含有小数的变量\n\r"},{"id":20,"href":"/docs/BDL/2.medium/17.interface/2.wiget/","title":"2.控件\u0026容器","section":"第十七章 用户界面","content":"控件\u0026amp;容器\r#\r\r打开genero studio，我的版本为2.40.11，请打开和 ERP 版本相对应的genero studio。\n 使用fglform -V可以查看版本，只要大版本一直即可，即2.40.xx\n \r新建一个 4fd 文件，我这里命名为czzi002.4fd，你可以按照喜好自己行命名。\n\r一个空的 4fd 文件看起来就是一张空白纸，我们只要将你需要的东西用鼠标拖拽到这张之上即可。\n当然拖拽也是有规律的，否则无法生成你想要的画面，甚至还会报错。\n\r在顶部菜单中不同名称的按钮，都是一个个控件和容器。\n 控件：  GUI 中数据操作方法的合集叫做控件，它能够对数据进行操作。\n 容器：  容器是用来包裹控件，让控件已希望的方式展现出来的元素。\n容器\r#\r\r容器均具有本身的属性及特殊用途，容器间可相互包覆（基本物件除外），以呈现不同的效果。\n\r不同容器清单说明如下：\n   名称 功能说明 可使用的下层容器物件     Grid 简易空白画布 ScrollGrid、Table、GroupBox   ScrollGrid 有卷轴的空白画布 ScrollGrid、Table、GroupBox   Table 以表格方式显示阵列资料 无   MFArray 以画布方式显示阵列资料 无   GroupBox 将外层加上框线 VBOX、HBOX、GroupBox、PageControl、Grid、ScrollGrid、Table   PageControl 以分页方式显示资料 VBOX、HBOX、GroupBox、PageControl、Grid、ScrollGrid、Table   VBOX(Vertical layout) 将内含的物件以垂直方式排列 VBOX、HBOX、GroupBox、PageControl、Grid、ScrollGrid、Table   HBOX(Horizontal layout) 将内含的物件以水平方式排列 VBOX、HBOX、GroupBox、PageControl、Grid、ScrollGrid、Table    Grid\r#\r\r\r可将此容器视为一块空白的画布，布置在上方的元件都可以显示在画面相对位置上。\nGrid 只能处理非阵列资料。Grid 不可以被安排在其他 Grid 容器之内。\nstudio\n\r\r画面预览\n\r\r\rFloder\r#\r\r\r当摆放元件空间不足时（或是需要滚动画面，操作上较麻烦时），即可使用切页的功能，以资料夹的形式将资料性质相近的栏位，切分在同样的 page 当中。\n制作时可在页签位置以鼠标右键新增、删除页面。\n编译时若该页签内没有任何元件，则编译会失败，且系统会显示有空白页签存在。 页签上显示字符串仍需在属性视窗指定。\nstudio\n\r\r画面预览\n\r\r\rGroup\r#\r\r\r相关栏位可用 Group 包覆，以让相近性质的栏位可以明确的群聚于同处。\n编写时须注意：\n 若不需要 Group 名称，则可以不要设定textGroup、Text属性。 若要分组但不要框线，请改用 Grid。  studio\n\r\r画面预览\n\r\r\rHRec\r#\r\r\rHRec 用 spacer 来保留画面一定的空格符数。当元件在容器中时，若不使用 HRec，则在预览时会发现想要保留的空格符，实际上并没有被保留。点选 HRec 里面的元件或是 spacer 时，可以在元件的左右加入 spacer（Spacer left and Spacer right）。\nstudio\n\r\r画面预览\n\r\r\rScrollGrid\r#\r\r\r在 Genero Studio 中，此容器与 Grid 相同，均作为处理非阵列资料用。与 Grid 容器的差异仅在可使用滚动轴，可以滚动画面。不能用于显示阵列资料。 studio\n\r\r画面预览\n\r\r\rTable\r#\r\r\r使用 TABLE 即是以表格方式显示阵列资料，此方式有许多的优点，这些优点都是系统提供的，不需要额外再撰写程序码即可使用；\n包含：动态排序、栏位隐藏、显示或移动等。 在设计时期改变 Table 高度时，会自动增减资料的行数。 在 Table 物件上按鼠标右键，在弹出式选单可以新增或移除栏位。\n另外可以直接以鼠标拖曳改变栏位的顺序。\n编写时须注意：\n 使用 TABLE 物件时，资料（Record）一定是横列，没有直垂直排列。 编写时须到各栏位的属性中进行形态、对应数据库等资料的设定或变更。  studio\n\r\r画面预览\n\r\r\rTree\r#\r\r\rTree 树状图预览时和 Table 是一样的，当有资料的资料，树状图是有层级结构的。\n当节点展开时，可以展开上下级结构。\nstudio\n\r\r画面预览\n\r\r\r布局\r#\r\r\r当有多个容器（Container）同时并存在同一层画面上，设计画面时就必须再对这多个容器进行位置排列的指定。\nVBox\n\r\rHbox\n\r\r\r在设计视窗中，以多选物件的方式，选取两个以上的物件后，工具列上的Layout 排列工具项（Create Layout）即会被 enable，直接选取工具列中的垂直排列功能Vertical或水平排列功能（Horizontal），出现红色外框时，即完成排列方式指定。\n\r若设定完成后发现设定错误，必须取消原先设定后才能在设定新的排列方式。此时点选该红色外框，上方取消排列(Break Layout)即可进行取消作业。\n功能说明：\n垂直排列功能 Vertical Layout\n水平排列功能 Horizontal Layout\n取消排列功能 Break Layout\n控件\r#\r\r4FD 档在编辑时，就需要视需求将指定的元件布置在画面上。\nWidget 项目如下图所示，每个项目均可以鼠标拖拉至画面上的指定位置做处理。\n\r但若仅需要进行元件项目代换时，也可以透过属性页处提供的功能，直接进行转换。\n以下分项目说明各种元件的差异。\nLabel\r#\r\r定义一显示值用的栏位，可区分为下列三类。\n StaticLabel   静态文字标签，可设定宽度、 前景色等。\n Text  \rStaticLabel 可以和 Text 相互转换。Text 字符数自动决定大小的基本静态文字标签。无法自行设定宽度。\n FormFieldLabel  \r动态标签元件，属于 FormField 物件，可设定与资料栏位的关联。\n常用属性：\n textGroup -\u0026gt; text：显示说明字符串。 附注说明\n TIPTOP GP 可支援动态画面多语言转换的功能，因此定有转换规则，符合下列规则的画面元件始能进行语系转换：  输入栏位左侧说明依同名元件方式转换 TABLE 每栏栏位标题可转换 各别元件有元件 ID 足供识别可转换（含 page、groupbox、static label 等）    其余不符合上列规则者均无法于 TIPTOP GP 系统中完成多语言元件转换。\n TIPTOP GP 在设计 static label 时，要求其栏位名称必需以dummy为启始，以资识别为 static label。  \r  Edit\r#\r\r\r定义一个编辑栏位。属于 FormField 物件，可设定与资料栏位的关联。\n常用属性：\n commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。 constraints -\u0026gt; noEntry：设定此属性后即无法进入此栏位编辑资料。 constraints -\u0026gt; notNull：不可在此栏位输入 NULL 值或空字符串。 constraints -\u0026gt; required：不可在此栏位输入 NULL 值、空字符串或纯空格符。 appearance -\u0026gt; case：令输入字符串自动转换大/小写。 appearance -\u0026gt; scroll：卷动，若数据库栏宽大于画面预留栏宽时有效，当设定此属性时可藉卷动方式输入。  Button\r#\r\r\r定义一个按钮以触发某一 4GL 中已写定的 ON ACTION 段。\n建议除了特别的 ACTION 有需要在 Layout 内布置按键外，一般作业可不必布置，令其出现在 Ring Menu 处即可。\n常用属性：\n commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。 Image Group -\u0026gt; image：设定出现在 BUTTON 上的图片，其来源可参照 ACTION DEFAULT 段说 明。 textGroup -\u0026gt; text：显示在 BUTTON 上面的说明字符串。  ButtonEdit\r#\r\r\r定义一个编辑栏位的元件，可透过右侧按钮以触发某一事件。通常用在串连与此栏位输入时有关的动作，例如查询合法可用资料等。此元件为 FormField 物件，可设定与数据库中资料表的栏位相关联，将 data 属性设为 TABLE_COLUMN 时可额外设定 tableName 及 columnName 这两个属性。\n常用属性：\n action：设定当按下按纽时要触发 4GL 中何组 ON ACTION 段、此处定义其 action-id。 commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。 Image Group -\u0026gt; image：设定出现在 BUTTON 上的图片，其来源可参照 ACTION DEFAULT 段说明。 constraints -\u0026gt; noEntry：设定此属性后即无法进入此栏位编辑资料。 constraints -\u0026gt; notNull：不可在此栏位输入 NULL 值或空字符串。 constraints -\u0026gt; required：不可在此栏位输入 NULL 值、空字符串或纯空格符。 appearance -\u0026gt; case：令输入字符串自动转换大/小写。 appearance -\u0026gt; scroll：卷动，若数据库栏宽大于画面预留栏宽时有效，当设定此属性时可藉卷动方式输入。  ComboBox\r#\r\r\r定义一个可利用下拉功能选值的编辑栏位，若输入资料只有几种值可供选择时，建议采用 RadioGroup 方式来限缩使用者可输入的内容（参阅 RadioGroup）。属于 FormField 物件，可设定与资料栏位的关联。\n选项对话视窗:\n可管理 ComboBox 的选项，也可以按字母顺序排列选项的 Text。\n\r常用属性：\n commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。 items：定义可选择的选项，用对话视窗设定。 constraints -\u0026gt; noEntry：设定此属性后即无法进入此栏位编辑资料。 constraints -\u0026gt; notNull：不可在此栏位输入 NULL 值或空字符串，可抑制 NULL 选项出现。 constraints -\u0026gt; required：不可在此栏位输入 NULL 值、空字符串或纯空格符。 queryEditable：当设定此属性后，若为 CONSTRUCT 模式下即可开放 USER 自行输入。 case  令输入字符串自动转换大/小写。  DateEdit\r#\r\r\r定义一个日期编辑，按右侧钮可带出 Client 端万年历选择视窗。日期显示格式由主机端 DBDATE 环境变量控制。属于 FormField 物件，可设定与资料栏位的关联。\n常用属性：\n commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。 constraints -\u0026gt; noEntry：设定此属性后即无法进入此栏位编辑资料。 constraints -\u0026gt; required：不可在此栏位输入 NULL 值、空字符串或纯空格符。  RadioGroup\r#\r\r\r定义一个可用选择方式输入资料的输入栏位，此种选择方式会将选项清单展示在画面上（ComboBox 不会展开显示，可参照 ComboBox 说明），故若需要采用此输入形态，要注意画面空间是否足够。\n\r常用属性：\n commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。 items：定义可选择的选项，依范例方式设定。【必要属性】 constraints -\u0026gt; noEntry：设定此属性后即无法进入此栏位编辑资料。 constraints -\u0026gt; notNull：不可在此栏位输入 NULL 值或空字符串。 constraints -\u0026gt; required：不可在此栏位输入 NULL 值、空字符串或纯空格符。 orientation：可定义选项排列方式为垂直排列（vertical）或水平排列（horizontal）。  注意\n使用 ComboBox 可动态定义 items，而 RadioGroup 不可动态定义 items。\n\rCheckBox\r#\r\r\r当栏位选项只有两种选择时（如：是或否，0 或 1，100 或 200 等），就可以采用此种输入型态执行输入。属于 FormField 物件，可以设定与资料栏位相关联。\n常用属性：\n commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。 constraints -\u0026gt; noEntry：设定此属性后即无法进入此栏位编辑资料。 constraints -\u0026gt; notNull：不可在此栏位输入 NULL 值或空字符串，可抑制 NULL 选项出现。 constraints -\u0026gt; required：不可在此栏位输入 NULL 值、空字符串或纯空格符。 textGroup -\u0026gt; text：显示在选取格后面的说明字符串。 valueChecked：选取核取后传入 4GL 的值，可为数字、字符、字符串。【必要属性】 valueUnchecked：选取取消后传入 4GL 的值，可为数字、字符、字符串。【必要属性】  HLine\r#\r\r\r水平分隔线\nCanvas\r#\r\r\r定义一个绘图的区块以供 4GL 程序绘制图形用。\n常用属性：\n commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。  说明\nGenero BDL 可支援简易的绘图模式，但需藉由建立物件 om.DomNode 的方式来建立，此部份可参阅 Genero BDL 在线说明文件。\n\rProgressBar\r#\r\r\r定义一水平方向的进度显示表。\n常用属性：\n valueMin：定义控制数值的最小值。 valueMax：定义控制数值的最大值。  注意\nTIPTOP GP 中有已定义完整的 Progress Bar 处理函式，可直接呼叫使用，使用者不需自行定义 Progress Bar。\n\rTextEdit\r#\r\r\r定义可编辑多行的栏位，输入长度当超过画面预留长度时，会自动出现卷轴。属于 FormField 物件，可设定与资料栏位的关联。\n常用属性：\n commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。 constraints -\u0026gt; noEntry：设定此属性后即无法进入此栏位编辑资料。 constraints -\u0026gt; notNull：不可在此栏位输入 NULL 值或空字符串。 constraints -\u0026gt; required：不可在此栏位输入 NULL 值、空字符串或纯空格符。 appearance -\u0026gt; case：令输入字符串自动转换大/小写。 scrollBars：可设定卷轴出现的位置，有 NONE、VERTICAL、HORIZONTAL、BOTH 等。 wantTabs：当设定此属性时，允许在输入框中输入 TAB 键。 WantNoReturns：当设定此属性时，不允许在输入框中输入 ENTER 键。  TimeEdit\r#\r\r\r定义一个时间编辑栏位。属于 FormField 物件，可设定与资料栏位的关联。\n常用属性：\n commentGroup -\u0026gt; comment：设定说明内容，当鼠标移过时会以符动视窗方式显示内容。 constraints -\u0026gt; noEntry：设定此属性后即无法进入此栏位编辑资料。 constraints -\u0026gt; required：不可在此栏位输入 NULL 值、空字符串或纯空格符。  Image\r#\r\r定义一个可显示图档的区域。\nImage 分为下列两种 Widget：\n StaticImage   显示静态图档。\n FormFieldImage   显示动态图档\n常用属性：\n autoScale：自动依画面上现行留存框格为准，调整（等比例缩放）显示在画面上的图片大小。 geometry  Width 或 Height：不以画框的方式指定大小，而直接以画素指定的方式定宽或高。 stretch：定义是否要出现卷轴，有 none、x、y、both 四种可选择。 说明\n  IMAGE 有区分动态或静态模式，以上范例为动态模式，影像图片在 CLEAR FORM 时会一并清除，如同一般栏位设定。若图片属于 logo 类与资料无关、不会常常切换的话，建议可改用静态图片的作法。\n  静态的以『Image Group -\u0026gt; image』属性以指定图片档来源。静态图片不会因 CLEAR FORM 被清除。\n  \r  Slider\r#\r\r\r定义一个水平或垂直刻度的拖动条栏位。属于 FormField 物件，可设定与资料栏位的关联。显示的位置必须在有效范围内（在下限与上限之中）。\n常用属性：\n valueMin：定义控制数值的最小值。 valueMax：定义控制数值的最大值。 step：刻度的间距。  SpinEdit\r#\r\r\r定义一个旋转编辑栏位。属于 FormField 物件，可设定与资料栏位的关联。上下图示的按钮可以增加/减少数值，也可以直接在栏位中输入数值。\n常用属性：\n step：增加/减少数值的间距。  WebComponent\r#\r\r\rWebComponent是一个可代码控制的可重用控件，并无示例，这里不展开讲。\n其它项目\r#\r\rTopMenus\r#\r\rTM 页签对应到fgl 中PER 档的TOMMENU Section。主要功能在将Action 依功能别群聚为一组一组，设定显示在画面上方Menu Bar，让使用者利用Pull-Down Menu 点选即可执行Action。\n\r注意\n在TIPTOP GP 系统中亦有使用TM 功能，但已依TIPTOP GP 特性进行设定，并 未将资料定义于4FD 档内，而是将资料另外储存于$TOPCONFIG/4tm下。\n你在运行作业时，也能看到当前作业使用到的TopMenu文件\n\u0026lt;topprod:/u1/topprod/tiptop/azz/4gl\u0026gt; exe p_zz Execute program:p_zz [Guard-1234]Check successfully. \u0026lt;topprod:/u1/topprod/tiptop/azz/4gl\u0026gt; SESSIONID: 288299771 PLANT:FOREWIN DBNAME:forewin INFO: Your Plant (FOREWIN) is setting in GMT+8 time zone. No idle control INFO: 4st for Interface Level = /u1/topprod/tiptop/config/4st/tiptop.4st INFO: 4ad for Interface Level = /u1/topprod/tiptop/config/4ad/2/tiptop.4ad INFO: 4ad for Form Level = /u1/topprod/tiptop/config/4ad/2/azz/p_zz.4ad INFO: 4tm for Interface Level = /u1/topprod/tiptop/config/4tm/topmenu_i.4tm INFO: 4tb for Interface Level = /u1/topprod/tiptop/config/4tb/toolbar_i.4tb g_ui_setting : std INFO: Locale feature use 0.05225 seconds. \r\rToolbars\r#\r\r对应至原PER 格式的TOOLBAR Section，主要功能在定义将常用的Action 显示在画面上方TOOLBAR 处。\n\rAction Defaults\r#\r\rAD 页签对应到原PER 档的ACTION DEFAULTS 区段，主要功能是定义功能按键（Action）的属性，包含显示在画面档上的文字、快速键（1.31 以上版本允许设定至多三组）、显示图片、弹出式说明（Hint、Comments）等属性，须搭配4GL 程序才会有作用。\n.4ad档\r#\r\r在某些特殊原因下，可照规则编写一XML 格式档案（例如下面范例：act.4ad）。\n而在4GL 程序中以呼叫（CALL）ui.Interface.loadActionDefaults(\u0026ldquo;4ad-filename\u0026rdquo;) ，传入参数是4ad 档档名，附档名可不写；产生的结果也与在PER 档编辑ACTION DEFAULTS 段或在4FD 编写TM 功效一致。\n范例：act.4ad\n\u0026lt;ActionDefaultList\u0026gt;  \u0026lt;ActionDefault name=\u0026#34;add\u0026#34; text=\u0026#34;Append\u0026#34; acceleratorName=\u0026#34;CONTROL-V\u0026#34; /\u0026gt;  \u0026lt;ActionDefault name=\u0026#34;del\u0026#34; text=\u0026#34;Delete\u0026#34; acceleratorName=\u0026#34;SHIFT-F2\u0026#34;/\u0026gt;  \u0026lt;ActionDefault name=\u0026#34;zoom\u0026#34; text=\u0026#34;Zoom\u0026#34; comment=\u0026#34;Open zoom window\u0026#34; /\u0026gt;  \u0026lt;ActionDefault name=\u0026#34;quit\u0026#34; text=\u0026#34;Quit\u0026#34; acceleratorName=\u0026#34;SHIFT-F5\u0026#34; image=\u0026#34;quit\u0026#34; /\u0026gt; \u0026lt;/ActionDefaultList\u0026gt; 4GL 引入范例：act.4gl\nMAIN  DEFINE ls_flow_pic STRING  CALL ui.Interface.loadActionDefaults(\u0026#34;act\u0026#34;)  OPEN WINDOW act_w WITH FORM \u0026#34;/u1/topprod/tiptop/demo/edit\u0026#34;  MENU \u0026#34;\u0026#34;  ON ACTION add  CALL act_a()  ON ACTION del  ：  ON ACTION zoom  ：  ON ACTION quit  EXIT Program  END MENU  ： 编译之后可以得到的画面与前一页相同。\n注意\n如TIPTOP GP 系统即未采用在PER 档编写ACTION DEFAULT 段的方法，原因是若编写在PER 档中，则于遭遇不同语系时，就需准备多组不同的PER 档案，如此则会增加程序开发的困难。故采用4ad 分离的方式以降低开发系统中会发生的错误情形。\n\rScreen Record\r#\r\r在4fd文件新增的可输入控件，在Records中都会生成对应屏幕变量组。\n\r一个屏幕变量集合（Screen Record）可以包含来自不同资料表格的资料行，甚至是formonly 的栏位，若该屏幕记录恰完全属于同一个表格（table），则可以使用table_id.*来定义。\n\r每个Table 元件都会自动建立Default Screen Record，所有的变更都会自动反应到Default Screen Record。\n可以对Table 建立不同栏位顺序的额外的ScreenRecord。\n注意\n 使用Table 时虽然会自行建立SR 变量，但是却会以tbXX﹝即table 的名称﹞直接命名，和TIPTOP GP 对荧幕变量组命名规则不合，需要自行手动至属性页签处进行变更。 栏位不可被重复定义，重复定义在编译时会产生编译错误。  \rStyle\r#\r\r\r在一个4fd的Form属性中有一个可以styleFile，它可以引入一个4st文件，这个文件可以影响4fd文件最后的样式。\n\rstudio可以新建4st文件，tiptop gp有默认的4st文件，一般不去修改。\nTab Index\r#\r\r定义画面上元件的输入顺序（按Tab 键可以跳到下一个元件）。可以在Edit Menu 中的Tab Index 或是如下图中的小图示上按鼠标左键执行。\n\r更改顺序方式：\n 双击鼠标左键将顺序数字重设为1。 在任一数字上按鼠标左键将从目前的数字顺序往下排。 结束目前的设定按ESC 键。 再按一次ESC 键离开Tab index 设定（数字会消失）。 更改顺序也可以透过直接更改元件的tabindex 属性的数值，但必须在离开Tab Index设定顺序的状态下。  Alignment\r#\r\r\r在图示列或是在选单中Alignment 的功能。\n只有在同一个容器（container）内的元件（widgets）可以进行对齐功能。也可以同时选取多个元件修改它们的PosX/PosY 属性以达到对齐的功能。这些属性对上层容器物件来说是相对位置，而不是绝对位置。\n练习\r#\r\r将每个不同的控件都拖住到4fd文件中试一试\r#\r\r"},{"id":21,"href":"/docs/BDL/2.medium/16.module/2.lib-sub/","title":"2.lib和sub函数","section":"第十六章 模块","content":"lib 和 sub 函数\r#\r\r42x 文件\r#\r\r回顾上一节的练习，调用cl_null()函数，是不是比较简单。\n但是我们来看下一下p_zz.4gl的源码中调用了多少次 lib 函数(lib 函数一般以cl开始，有误差，但误差不大)，$AZZ/4gl目录下。\ncd $AZZ/4gl grep -c \u0026#34;cl\u0026#34; p_zz.4gl ... 265 调用了 265 次 lib 函数，如果按照上一节的办法，我们要找到这 265 个 lib 函数对应的文件，链接后并编译。\n这实在太不方便了，所以 BDL 在链接时其实还隐藏了一个功能。\n不需要额外的命令和源代码，我们依然使用czzi004.4gl和s_czzi004.4gl进行示例。\n我们先删除之前生成的文件，防止影响本次结果。\ncd $CZZ/4gl rm *czzi004*.42m rm *czzi004*.42r   编译 czzi004.4gl和s_czzi004.4gl，和之前一样\n  单独链接 s_czzi004.42m\n  fgllink -o czzi004_sub.42x s_czzi004.42m 编译 czzi004_sub.42x和czzi004.42m  fgllink -o czzi004.42r czzi004.42m czzi004_sub.42x fglrun czzi004  一样可以运行，看起来并没有减少步骤。\n但是我们可以将第二步运用到整个 lib 目录下的所有文件，将所有 lib 目录下源代码都链接为lib.42x文件，那么之后不管哪个作业调用多少个 lib 函数，那么我们只要在编译这个新作业后，将lib.42x这个文件和主程序链接以下即可。\n只要当lib目录下哪个文件修改了，才需要重新连接lib.42x文件。\n这一步tiptop gp已经替我们做好了，$LIB/42m目录下有一个lib.42x文件。\n上一节的练习题中，让我们使用以下命令，连接主程序。\nfgllink -o czzi004.42r czzi004.42m $LIB/42m/lib.42x 结果一样可以运行。\nlib 和 sub 函数\r#\r\rlib和sub是tiptop gp中的两个子函数库，如果你使用r.l2链接程序，那么程序自动将这两个函数库链接到程序中。\n所以这两个库的函数，你可以随时调用，而不用担心函数不存在的报错。\n在结构上lib和sub没有任何区别，在使用上没有任何区别。\n但如果你要新增，或者修改那么有几点需要注意：\n   项目 lib sub     功能范围 底层逻辑(替换字符串、判断字符段是否为空、四舍五入函数) 业务逻辑（库存过账、系统日志记录）   建议新增 不建议 可以   建议修改 不建议 可以   建议删除 不建议 不建议    重要\n无论是 sub 还是 lib，链接失败都影响所有作业，如果你要修改或新增这两个库的函数，请务必现在测试区测试成功后再搬到正式区运行。\n\rlib、sub函数新增流程\r#\r\r\r"},{"id":22,"href":"/docs/BDL/2.medium/15.function_plus/2.parament/","title":"2.函数的返回值","section":"第十五章 函数进阶","content":"函数的返回值\r#\r\r上一节中我们讲到，函数结构由参数和返回值决定。\n这节我们介绍函数的返回值。\n返回值个数\r#\r\r和参数一样，函数的返回值个数可以是0，也可以是任意个。\n0个返回值\r#\r\rmain 函数就是一个无返回值的参数，没有函数能够接受main函数的返回值。 同时main也是一个没有参数的函数。\nmain end main function main() end function 在无返回值的函数中，依然可以使用关键字return，这时return关键字的作用是结束当前函数运行，返回调用函数处。\n任意数量的返回值\r#\r\r和参数不一样，函数的返回值个数是不需要提前定义好的。在程序执行到return处，才能确定返回值的个数和数据类型。\n所以一个函数在不同情况下调用，返回值的个数有可能不同。\n注意\n返回不同数量的值，影响程序后续维护，除非能够快速解决当前问题，否则建议函数总是返回相同数量的返回值。\n虽然返回个数不会保存，单调用函数时，必须接受每一个返回值，所以调用时，你必须知道这个函数将要返回的返回值的个数。\n\r返回值的返回，即return后面的常量或者变量，已,作为分隔符。\n例如，以下代码返回2020年的月份，如果当前不是2020年，则返回当前年份和月份。\nmain  define yy,mm integer  if year(current) == 2020 then  display currentYM()  else  call currentYM() returning yy,mm  display yy,mm  end if end main function currentYM()  if year(current) != 2020 then  return year(current),month(current)  else  return month(current)  end if end function 返回值类型\r#\r\r字符串、数值\r#\r\r作为基础类型，字符串和数值返回时使用对应的变量调用即可。\n如果变量和返回值数据类型不同，将发生隐式数据转换，如果转换错误，程序将报错停止运行。\n结构体\r#\r\r与参数对应，返回值数量也不建议太多，当需要返回大量资料时，建议使用结构体。\n如下，返回结构体时，和传参对应，已结构退变量.*的形式返回和接受结构体变量。\nmain  define l_ima RECORD LIKE ima_file.*  call a1() returning l_ima.* end main function a1()  define p_ima RECORD LIKE ima_file.*   let p_ima.ima01 = \u0026#39;123\u0026#39;  return p_ima.* end function 数组\r#\r\r在处理多笔资料时，当然也可以使用数组类型作为返回值，在返回和接受时和基础类型并没有什么区别。\nmain  define l_img dynamic array of RECORD LIKE img_file.*  call a1() returning l_img end main  function a1()  define l_img dynamic array of RECORD LIKE img_file.*   let l_img[1].img01 = \u0026#39;123\u0026#39;  return l_img end function 上述代码没有问题，但上一节我们了解到数组操作如果作为参数，传到函数中是内存地址，如果修改main中的数字的值也会变化。 所以上面代码除了用返回数组的形式，我们还可以将数组作为参数传到函数中，这样在函数中修改数组即可，不要再返回数组。\n如下：\nmain  define l_img dynamic array of RECORD LIKE img_file.*  call a1(l_img) end main  function a1(p_img)  define p_img dynamic array of RECORD LIKE img_file.*   let p_img[1].img01 = \u0026#39;123\u0026#39; end function 注意\n对数组进行操作时，建议传参数即可，这样可以省略数组返回值，减少代码量。\n\r"},{"id":23,"href":"/docs/BDL/2.medium/14.database/2.schema/","title":"2.数据表结构在BDL中的使用","section":"第十四章 数据库使用","content":"数据表结构在 BDL 中的使用\r#\r\r在数据库中，每个表的建立都会产生表结构文件，叫做schema文件。\n在我们使用数据库时，如果你需要大量的数据中的资料，不需要频繁的查询数据中的表结构，通过表结构中字段的数据类型去对应BDL中的数据类型。在BDL中已经为我们做好了这一步，ORACLE中大部分数据类型在BDL中都映射到指定的类型。\n我们只要使用数据库的schema文件，就能通过数据的字段去定义BDL中的数据类型。\n上一章我们学到了function main() end function这种main函数写法，只会使用表结构，而不连接到数据库，指得就是使用schema文件，而不连接到数据库。\n在 BDL 中使用 schema 定义变量\r#\r\r只要将之前定义变量中的数据类型修改为like ds:table.cloumn 即可定义这个变量类型为 ds 库中 table 这个表的 column 这个字段在数据库中的类型。\n其中ds:库名可以省略，如果省略，表示使用当前已经连接到的库。\n例如:\ndatabase ds main  define l_ima01 like ima_file.ima01  define l_ima02 like ima_file.ima02 end main 除了在使用ima_file字段时，可以依据ima_file字段的名称定义，在 TIPTOP 中，常用的字段类型都定义在了type_file中，可以根据 type_file 类型定义我们经常使用的变量，如金额、库存数量、单价这些常用变量。\n type_file字段清单如下\n    字段名称 数据类型 字段名称 数据类型     chr1000 varchar2(1000) chr6 varchar2(6)   chr1 varchar2(1) chr50 varchar2(50)   num5 number(5) chr37 varchar2(37)   num20_6 number(20,6) chr9 varchar2(9)   dat date chr12 varchar2(12)   chr18 varchar2(18) chr30 varchar2(30)   num10 number(10) chr14 varchar2(14)   chr8 varchar2(8) chr7 varchar2(7)   chr20 varchar2(20) chr10 varchar2(10)   chr21 varchar2(21) chr100 varchar2(100)   num20 number(20) chr200 varchar2(200)   chr3 varchar2(3) chr300 varchar2(300)   num26_10 number(26,10) chr500 varchar2(500)   chr2 varchar2(2) blob blob   chr4 varchar2(4) num15_3 number(15,3)   chr5 varchar2(5) row_id varchar2(18)    进阶使用\u0026ndash;record\r#\r\r在实际业务中，我们经常使用的场景是，查询一个表每个字段的数据，更新/新增一个表所有字段。\n有时候一个表的字段可能是几十个，这个时候我们再每个字段去单独定义，容易出错。并且之后表有所异动时，容易遗漏修改。\nBDL为我们设计了一个可以简化整张表定义的语法。\ndefine l_ima record like ima_file.*  注意这种方式定义时，没有end record\n ima_file.* 就表示这个表所有字段。必须和record配置使用。 l_ima的结构体自动就包含了ima_file中的所有字段，使用l_ima.ima01 l_ima.ima02 l_ima.ima021即可调用这些字段。\n注意事项\r#\r\rBDL 使用schema文件，在编译时，会自动的将schema文件中的数据类型映射到BDL中的数据类型。所以如果数据库数据类型变化，或者字段变动，那么 BDL 对应的文件也需要重新编译。\n 如果重新产生 schema 文件 TIPTOP GP\rr.s2 ds #ERP服务器中运行 T100\r\r "},{"id":24,"href":"/docs/BDL/2.medium/13.struct/2.type/","title":"2.声明结构体类型","section":"第十三章 结构体","content":"声明结构体类型\r#\r\r在上一章节，我们定义了两个相同的结构体变量。\n define zhangsan record  name varchar(20),  age integer,  email varchar(50)  end record  define lisi record  name varchar(20),  age integer,  email varchar(50)  end record 这两个变量成员以及每个成员的数据类型完全一样，除了成员的值其它内容都一样。\n现在成员数量少赋值一遍，还不算难，如果成员数量达到几十个的时候呢？\n如果后面我要增加一个成员，难道要先找到所有的结构体变量，一次增加吗？\n所以我们引用了一个新的功能\u0026mdash;结构体声明，关键字type，本章主要介绍它的使用方法。\n结构体如何声明\r#\r\r结构体声明的示例：\n type person record  name varchar(20),  age integer,  email varchar(50)  end record 看起来和结构体变量定义完全一样，只是将define换成了type。\n我们来看看如何使用：\n type person record  name varchar(20),  age integer,  email varchar(50)  end record  define zhangsan,lisi person  let zhangsan.name = \u0026#34;zhang san\u0026#34;  let lisi.name = \u0026#34;li si\u0026#34;  display zhangsan.name  display lisi.name 我们在定义zhangsan、lisi两个结构体变量是时，直接将person当作变量类型使用，类似于integer。\n这个时候我们要增加一条成员，只要在person中增加一条即可。使用person创建的变量，自动可以访问新增加的成员。\ntype 进阶使用\r#\r\rtype person record  name varchar(20),  age integer,  email varchar(50)  end record 之前我们的结构体声明了person类型，也许你会好奇，为什么还要加上record和end record呢？\n因为type还可以在其它类型中使用,array、dynamic array。甚至是基础数据类型integer、string。\ntype相当于给一个数据类型，起了一个别名。\n如果一个类型我们需要重复使用，或希望之后修改方便，我们都可以先用type取别名，然后使用别民去定义变量。\n编译运行以下代码，查看运行结果。\n type ssss string  define s ssss  type names dynamic array of string  define class1 names  define i integer   let s = \u0026#34;abc d \u0026#34;  let s = s.trimRight()  display \u0026#34;\\n\u0026#34;||s   let class1[1] = \u0026#34;zhangsan\u0026#34;  let class1[2] = \u0026#34;lisi\u0026#34;  let class1[3] = \u0026#34;wangwu\u0026#34;   for i = 1 to 3  display sfmt(\u0026#34;name is %1\u0026#34;,class1[i])  end for "},{"id":25,"href":"/docs/BDL/2.medium/12.string/2.practice/","title":"2.练习","section":"第十二章 字符串操作","content":"练习\r#\r\r将以下数组连接起来组织为依据通顺的英语句子\r#\r\r define a array[3] of string  let a[1] = \u0026#34;You\u0026#34;  let a[2] = \u0026#34;Welcome\u0026#34;  let a[3] = \u0026#34;Are\u0026#34; 编程实现，成绩输入系统\r#\r\r要求：\n 依次输入学生的姓名，语文成绩、数学成绩、英语成绩 按以下格式输出该学生的信息  姓名：小明 语文：80 数学：90 英语：85\r平均分：85.00 总分：255 进阶\n如果要输入3名学生的成绩，并按上面要求输出，你会做吗？\n\r"},{"id":26,"href":"/docs/BDL/2.medium/11.array/2.one-dimensional-array/","title":"2.一维数组","section":"第十一章 数组-同一类型的多个元素的集合","content":"一维数组\r#\r\r一维数组也称向量，用以组织具有一维顺序关系的一组同类型数据，在使用数组前，必须先声明数组，编译器根据声明语句为其分配内存，这样数组才有意义。\n一维数组如何定义\r#\r\r与简单数据类型一样，数组也由关键字define定义\ndefine 数组名 array [size] of 类型 --定长数组 define 数组名 dynamic array of 类型 --动态长度数组 数组由两种形式：\n 指定长度的定长数组 不指定长度动态长度数组  一位数组的访问\r#\r\r之前我们提过，数组越界的错误，对于定长的数组，超过原来长度的访问，或程序奔溃。对于动态长度的数组，访问未经过初始化的长度的时候，会对之前没有初始化的索引赋空值。\n我们通过一个例子看一下一位数组的访问方式：\n define score array [6] of integer  define sum,i integer  define average decimal(10,2)  prompt \u0026#34;请输入第1名学生的成绩\u0026#34; for score[1]  prompt \u0026#34;请输入第2名学生的成绩\u0026#34; for score[2]  prompt \u0026#34;请输入第3名学生的成绩\u0026#34; for score[3]  prompt \u0026#34;请输入第4名学生的成绩\u0026#34; for score[4]  prompt \u0026#34;请输入第5名学生的成绩\u0026#34; for score[5]  prompt \u0026#34;请输入第6名学生的成绩\u0026#34; for score[6]  for i = 1 to 6  let sum = sum + score[i]  end for  let average = sum/6  display sfmt(\u0026#34;\\n平均成绩：%1\u0026#34;,average) 数值的初始化\r#\r\r上面我们说过动态数组访问超界时会将之前数组都赋值为null，如果每次都是这样，那么不小心写了一次array[1000]，那么这个数组长度之后都从1000后开始用吗？\n这个时候我们就可以用到初始化数组，将数组重新初始化为0长度（动态数组初始化为0长度，定长数组初始化为全部null值数组）。\n具体语法如下：\ncall 数组名.clear() 你一定发现了，有一个()，难道clear是一个函数吗？\n没错，clear()这类可以通过变量后面跟.调用得函数，是一种特殊函数，它只能通过指定数据类型的变量调用。\n这种特殊的函数我们称为方法，clear()是数组类型的一个方法，方法除了调用时必须跟在变量后面，其它特性与函数是一样的，可以传参，也可以返回值。\n方法这类函数都是BDL语言是定义好的，你也可以通过引入java包等方式使用，但这属于进阶内容。 当前你可认为方法都为BDL定义好，只能调用不能修改即可。\n不合法的数组操作\r#\r\r 用一个数组对另一个数组赋值，即使两者类型一样   define a,b array[2] of integer  let a[1] = 1  let a[2] = 2  let b = a 编译报错\n../42m/czz_czzi001.4gl:6:13:6:13:error:(-4340) The variable \u0026#39;a\u0026#39; is too complex a type to be used in an expression. ../42m/czz_czzi001.4gl:6:9:6:9:error:(-4323) The variable \u0026#39;b\u0026#39; is too complex a type to be used in an assignment stateme. 对输出进行整体输出   define a array[2] of integer  let a[1] = 1  let a[2] = 2  display a 编译报错\n../42m/czz_czzi001.4gl:6:13:6:13:error:(-4340) The variable \u0026#39;a\u0026#39; is too complex a type to be used in an expression. 数组整体运算   define a,b array[2] of integer  define sum integer  let a[1] = 1  let a[2] = 2  let b[1] = 2  let b[2] = 3  let sum = a + b  if a\u0026gt;b then  display \u0026#34;\\na\u0026gt;b\u0026#34;  end if 编译报错\n../42m/czz_czzi001.4gl:9:15:9:15:error:(-4340) The variable \u0026#39;a\u0026#39; is too complex a type to be used in an expression. ../42m/czz_czzi001.4gl:9:19:9:19:error:(-4340) The variable \u0026#39;b\u0026#39; is too complex a type to be used in an expression. ../42m/czz_czzi001.4gl:10:8:10:8:error:(-4340) The variable \u0026#39;a\u0026#39; is too complex a type to be used in an expression. ../42m/czz_czzi001.4gl:10:10:10:10:error:(-4340) The variable \u0026#39;b\u0026#39; is too complex a type to be used in an expression. "},{"id":27,"href":"/docs/BDL/2.medium/10.function/2.diy-function/","title":"2.自定义函数","section":"第十章 函数入门-写程序就是写函数","content":"自定义函数\r#\r\r函数的调用可能是由另一个函数触发，但函数的定义都是平行的，包括main函数在内。所谓“平行”，有两层含义，一是“不允许把一个函数定义在另一个函数内”，这说明，函数定义都要在main函数外部，二是“不同函数定义放置位置没有关系”，可以定义在main函数之前，也可以定义在main函数之后。\n函数定义的语法\r#\r\r和变量一样，要想使用一个函数，定义是不可缺少的。\n函数定义有4个要素:参数列表、返回值、函数名和函数体， 参数列表和返回值对应着输入输出， 函数名用于和程序中其他程序实体区分， 而函数体是一段可执行的代码块，实现特定的算法或功能。\n函数的基本定义语法如下：\nfunction 函数名(参数列表)  define 参数... --参数类型定义  函数体 end function  输入：参数列表  参数列表的基本形式为：\n变量名1,变量名2,变量名3... 每个变量名在函数内必须定义数据类型，有些情况下，不需要像函数传递参数，此时，参数列表为空，但圆括号不能省略。 例如：\nfunction printa()\rdisplay \u0026#34;a\u0026#34;\rend function 输出：返回值  返回值用户返回函数的输出值。 格式如下:\nreturn 输出值1,输出值2,... 如果没有输出值，可以只写一个return这个时候函数结束，但不返回任何值。\n函数名  函数名用于标示该函数，和其它函数区分开来，因此和变量取名一样，函数名必须是合乎编译器命名规则的标识符。\n函数体  函数体是一段用于实现特定功能的代码块，比如局部变量声明和其它执行语句等。注意，在函数体内声明的变量不能和参数列表中的变量同名。\n函数体可以没有任何语句，此时称为空看书，表示占一个位置，以后可以将空能实现添加上。\n在做软件开发规划时，这是一个经常使用的方法，在开发初期，为了在功能木块切割的同时维护程序的总体性。常常时先使用一个个的空函数将程序的框架搭起来，再逐步添加功能使程序一步步完善起来。\n"},{"id":28,"href":"/docs/BDL/1.basic/9.over_and_over_again/2.for/","title":"2.for结构","section":"第九章 循环结构--一遍又一遍","content":"for结构\u0026ndash;更常用的循环结构\r#\r\r阅读代码时可以发现，for结 构是应用最多的一种 循环控制结构，这大抵是因为for结构提供的控制功能更为完善，而且，相比while结构，for结构写出的代码也更为简洁，可读性也稍好。\n基本形式\r#\r\rfor 变量 = 初始值 to 目的值 step 每次增加的量  循环结构 end for 注意 这里的step关键不写的时候，默认每次+1，step还可以跟负数，如果是负数，每次判断的就是小于目的值时跳出循环。\r\r用while表示同样的表达式:\nlet 变量 = 初始值 while 变量\u0026lt;=目的值  循环结构  let 变量 = 变量 + 每次增加的量 end while 由此可见，要写出同样功能代码，for结构比while结构简洁易读。\nfor结构执行流程图：\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rflowchart TD\ra[\"变量 = 初始值\"]--d{\"变量是否超过目的值\"}\rc[\"循环结构\"]\rc--b[\"变量增加\"]\rb--d\rd--\"yes\"--e[\"跳出循环\"]\rd--\"no\"--c\r其执行过程如下：\n 变量赋初始值 判断变量是否超过目的值，超过退出循环，进行第5步；不超过执行循环结构，执行第3步 自动变量增加指定的值 再判断第2步 循环结果，跳出for结构，继续向下执行  利用for结构改写我们之前计算1到100和的代码：\ndefine i,sum integer for i =1 to 100  let sum = sum + 1 end for display sfmt(\u0026#34;\\n结果是：%1\u0026#34;,sum) "},{"id":29,"href":"/docs/BDL/1.basic/8.condition/2.if-else/","title":"2.if else--两条岔路的选择","section":"第八章 条件判断-分支结构","content":"if else\u0026ndash;两条岔路的选择\r#\r\r还是拿买东西做比方，口袋里只有50块钱，想买一件衣服，衣服的价格标签不见了。这时，你也许会在心里盘算，问一下衣服的价格，如果价格低于50，就说“好，买了”，否则，就说“太贵了，算了”。这种“两条岔路中选一个”的流程，在BDL语言中对应着if else结构。\n关键在else\r#\r\r改写上一章的代码，使用if else 结构，如下：\ndefine price integer  prompt \u0026#34;请输入商品价格（正整数）：\u0026#34; for price  if price \u0026lt; 50 then  display \u0026#34;\\n好，买好了\u0026#34;  else  displau \u0026#34;\\n太贵了，算了\u0026#34;  end if 无论输入多少价格，输出的结果要么是好，买好了，要么是太贵了，算了。\n代码解析\n第一个代码中采用的是if结构，在price超过50的时候不做出任何反应，一声不吭地走开，如此看来，第二个代码中的顾客似乎更礼貌一点， 在price小于50这个 条件不成立时，会输出拒绝信息“太贵了，算了”。\n如果转为流程图如下：\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rflowchart TD\ra([\"开始\"])--b[/\"申明变量price，并输出提示信息，请求用户输入\"/]\rb--c[/\"接受用户输入\"/]\rc--d{\"pricee[\"输出：'好，买好了'\"]\rd--\"no\"--f[\"输出：'太贵了，算了'\"]\re--g([\"结束\"])\rf--g\r当程序流程来到if else结构时，首先计算关键字if后“表达式”的值，如果表达式的值为“真”(不为0)，代码段1被执行，否则，else关 键字后的代码段2被执行。\n"},{"id":30,"href":"/docs/BDL/1.basic/7.atoml_statement/2.structured-design-program/","title":"2.结构化设计程序","section":"第七章 语句-程序最小构成单元","content":"结构化设计程序\r#\r\r结构化程序设计的思想是:把一个需要解决的复杂问题分解成若干模块来处理，每个模块解决一个小问题，这种分而治之的方法大大降低了程序设计的难度。结构化程序设计的核心问题是算法和控制结构。\n什么是算法\r#\r\r所谓算法，指的是解决问题时的一系列方法和步骤。\n算法的思维体现在生活的各个方面,比如我们要去北京旅游，会问一些问题:“用什么交通工具?”“在哪里中转?”“是否要去奥运现场?”等，这都包含着算法。\n可见，算法的步骤间有一定的逻辑顺序，按这些顺序执行步骤便可以解决问题，达到目的。这种逻辑顺序，在BDL语言中体现为控制结构。\n算法的表示\r#\r\r抛开厚厚的教科书，不去谈哪些深奥无比的属性。 本章节讨论与算法使用最为相关的问题:算法如何表示。\n原则上，自然语言也可用于算法表示，但由于自然语言的多义性，不同的人对同-一个版本的描述可能有不同的理解，因此，一般不采用自然语言来描述算法，要求采用一种精确的、无歧义的机制。\n有两种广泛使用的算法表示方法，一是伪代码法，二是流程图法。\n算法的伪代码表示\r#\r\r伪代码是对自然语言表示的改进，给自然语言加上了形式化的框架，以一种简单、容易理解的方式描述算法的逻辑过程。用伪代码表示的算法无二义性，易于理解。\n使用伪代码表示算法无须遵守严格的语法规则，只要完整表达了意思，书写清晰，容易阅读和读懂即可。举例如下:\n用户输入：\r如果（用户输入的字符是Y）\r执行B操作\r否则\r执行C操作\r 上述代码便采用了伪代码表示方式，完成一种简单的分支选择结构\n算法的流程图表示\r#\r\r流程图法是种有效、直观的算法表示方法，利用不同的框代表不同的操作，利用有向线段表示算法的执行方向。\n现在通用的流程图符号画法采纳的是ANSI (美国国家标准化协会)的标准，如图所示。\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rflowchart LR\rid1([\"起止框，表示程序起始和结束\"])\rid2{\"判断框\"}\rid3[/\"输入输出框，表示输入输出数据\"/]\rid4[\"处理框，完成某些操作\"]\rsubgraph a[\"这是连接点，如果流程太长将用词截断\"]\rid5((...))\rend\rid6--\"程序执行方向\"--id7\r将前面的伪代码表示转换为流程图表示，如图所示。 和伪代码方式相比，流程图方式采用了图形化的方式，更为直观，可以很清晰地反映控制结构的运作过程。\n在描述基本结构时，本书尽量采用流程图方式。\n以上伪代码，用流程表示如下:\nflowchart TD\ra([\"开始\"])--b[/\"用户输入\"/]\rb--c{\"判断是否是字符Y\"}\rc--\"YES\"--d[\"C操作\"]\rc--\"NO\"--e[\"B操作\"]\rd--f([\"结束\"])\re--f\r三种控制结构\r#\r\r结构化程序设计提供了3种控制结构，分别是顺序结构、分支结构和循环结构，早在1966年，Bohm和Jacopini的研究证明，用此3种基本结构可以构成任意复杂的算法。 3种基本控制结构如图所示。\nflowchart TD\ra[\"语句1\"] -- b[\"语句2\"]\rb-- c[\"语句3\"]\rflowchart TD\ra{\"条件1\"}--b[\"语句1\"]\ra--c[\"语句2\"]\rflowchart TD\ra{\"条件1\"}--b[\"语句1\"]\rb--c[\"语句2\"]\rb--a\r顺序结构是最简单、最基本的结构，程序按书写的顺序 从上到下来执行，不进行任何跳转。假设代码行为:\n语句1\r语句2\r语句3 执行顺序为语句1→语句2-→语句3- \u0026hellip;\u0026hellip;分支结构又称选择结构，需要在某处做出判断，根据判断结构决定走哪条路，即按判断条件决定某些语句是否执行。选择结构先判断某个条件是否成立，若成立则执行，反之，不执行。其语句形式有3种:单分支、双分支和多分支，第八章将详细介绍分支结构。\n循环结构则用于一遍一遍重复执行程序的某个部分，即由某个循环控制条件来控制某些语句及代码段是否反复执行、执行多少次。 循环结构的语句形式有两种:当型循环和直到型循。第九章将详细介绍循环结构。\n算法示例\r#\r\r假设编程解决这么一个问题：在用户输入3各不同整数中选出一个最小的。\n以下流程可完成该任务\nflowchart TD\ra([\"开始\"])--b[/\"用户输入3个不同整数，存入变量x，y，z\"/]\rb--c{\"判断xy是否成立\"}\rc--\"yes\"--d{\"判断yz是否成立\"}\rc--\"no\"--e{\"判断xz是否成立\"}\rd--\"no\"--f[\"最小数是y\"]\rd--\"yes\"--g[\"最小数是z\"]\re--\"yes\"--g\re--\"no\"--h[\"最小数是x\"]\rf--i[/\"输出\"/]\rg--i\rh--i\ri--j([\"结束\"])\r"},{"id":31,"href":"/docs/BDL/1.basic/6.operators_and_expressions/2.relational-operator/","title":"2.关系运算符","section":"第六章 运算符和表达式-程序基本构成","content":"关系运算符和关系表达式\r#\r\r关系运算就是作比较，日常生活中经常遇到一些真假判断，比如说，“张三比李四高”，“济南到北京比到上海近”，“5大于2”，这些问题的答案是真或假。\n程序设计是对实际问题解决过程的模拟，长城需要左判断，像“如果这样，我就执行动作A，如果那样，我就执行动作B”。\n那么怎么判断这样那样呢？ 这就需要用到关系运算和关系表达式。\n关系运算符号种类\r#\r\r关系运算就是比较变量或常量是否符和预期，比较结果为一个逻辑值“真”或“假”。 举个简单的例子，说“x\u0026lt;10”，如果x值为9，“9\u0026lt;10”成立，故上述式子的值为“真”，若x的值为15，则“15\u0026lt;10”不成立，上述式子的值为“假”。\nBDL中，“真”和“假”也是用数值来体现的，0就是“假”，其它值为“真”。\n关系运算符\n   运算符 描述     is null 判断控制   like 如果字符串和给定的格式匹配成功返回true   matches 如果字符串和给定的格式匹配成功返回true   相同(==or=) 判断两个值是否相同   不相同(!=or\u0026lt;\u0026gt;) 判断两个值是否不相同   小于\u0026lt; 判断左边的值小于右边   小于等于\u0026lt;= 判断左边的值小于等于右边   大于\u0026gt; 判断左边的值大于右边   大于等于\u0026gt;= 判断左边的值大于等于右边   nvl() 如果第一参数为空，返回第二个参数   iif() 如果第一个参数为true,返回第二个参数，否则返回第三个参数   in() 判断值是否在一个范围内    运算顺序\r#\r\r关系运算符比算数运算符优先级低，这说明：\nx+5\u0026gt;y-7和(x+5)\u0026gt;(y-7)是等价的。\n以下是关系表达式的常见用法\n define a ,b ,f integer  define c ,d, e decimal(6,3)   define s string   let a = 1 let b = 2  let c = 1.51 let d = 2.5  let s = \u0026#34;darcyjoven\u0026#34;  display sfmt(\u0026#34;\\na\u0026lt;b=%1\u0026#34;,a\u0026lt;b)  display sfmt(\u0026#34;c\u0026lt;a=%1\u0026#34;,c\u0026lt;a)  display sfmt(\u0026#34;f is null\u0026#34;,f is null)  display sfmt(\u0026#34;s matches \\\u0026#34;darcy*\\\u0026#34; =%1\u0026#34;,s matches \u0026#34;darcy*\u0026#34;) 请键入以上代码观察输出结果。\n"},{"id":32,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/2.sfmt/","title":"2.display与sfmt函数","section":"第五章 利用键盘、鼠标与程序交互","content":"display与sfmt函数\r#\r\rdisplay函数已经接触过，是将后面的变量或者值显示到控制台的命令行中。\n请尝试下以下代码，看看运行的值有何区别\n define a integer  define b decimal(20,6)  define c varchar(20)  define d decimal(10,6)   let a = 1  let b = 1  let c = 1  let d = 1  display \u0026#34;\u0026#34;  display a  display b  display d  display c  let c = \u0026#34;1\u0026#34;  display c  let c = b  display c 运行后，会发现显示如下\n 1\r1.000000\r1.000000\r1\r1\r1.000000 是否很你想像中的不一样，我们没有输入空格，却打印了很多空格。\n 隐式转换字符串  display会将任何变量转换为字符串，如果后面不是字符串会自动转化为字符串格式。\n这个转换时隐式的，隐式转化字符串会将数字剩余长度用空格补上。所以\ndisplay a\rdisplay b\rdisplay c 这两句将补上对于数量的空格: integer 最大表示2147483647，10位，1只有一位所以补上9个空格，因为integer正负数都有可能，还要补上一个符号位值，一共10个空格。\ndecimal(20,6),decimal(10,6)整数部分分别有14，和4位，再加上1位符号位，分别是15，5。整数部分只有1位，所以补上14，4个空格。小数部分没有值部分补上0（小数补0在显示转换也会补上）。\n 隐式转换字符串  在BDL语言中，显示转换字符串，例如let c = 1，这种形式。 是不会补上前面少的位数和符号位\nlet c = b\rdisplay c 例如上面代码只显示1.000000。\n但是每次数字转字符串我们都显示的转化字符串let c = b，会导致代码多很多没有必要的行。 所以BDL语言为我们封装了一个函数sfmt(),之前我们已经见过这个函数。\n其中s是string字符串的意思,fmt是foramt的缩写，全称位StringFormat字符串格式化。\nsfmt(参数1,参数2,参数3...)sfmt接受至少2个参数，且所有参数传入时，都会显示的转为字符串处理。\n在之前的用例中，我们写过这样的代码:\ndisplay sfmt(\u0026#34;1+2+3+4+5=%1\u0026#34;,x) 这里一个参数\u0026quot;1+2+3+4+5=%1\u0026quot;,第二个参数x是正整数值为15。\n函数首先将所有参数显示转为字符串，15转为字符串\u0026quot;15\u0026quot;。\n注意第一个参数是中的%1，我们尝试以下代码\ndisplay sfmt(\u0026#34;1+2+3+4+5=%2\u0026#34;,15,0) 这是我们发现输出的结果如下：\n1+2+3+4+5=0 发现其中规律了吗？%n代表着从第n+1个参数的值。\n我们再将%2改为%3\ndisplay sfmt(\u0026#34;1+2+3+4+5=%3\u0026#34;,15,0) SFMT: Invalid index used. 报错了，因为没有第4个参数。你无法使用没有传入的参数，但是可以传入参数而不使用。\r\n好了，现在我们知道smft的用法了，后面我们将经常使用这个函数，因为它可以为我们减少很多不必要的代码。\n"},{"id":33,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/2.bite-bit/","title":"2.字节和位","section":"第四章 存储和获取数据","content":"字节和为\u0026ndash;计算机表示数据的方法\r#\r\r程序员编写的程序以及所使用的数据在计算机中是以二进制位序列的方式保存的。 典型的计算机内存段二进制位如下：\n...010010101010101010010001100111001100... 上面的二进制位序列中，每个数字，要么是0，要么是1。在计算机中，位（bit）是包含-或者1的一个单元。在物理上，它的值是一负或者一个正电荷。 也就是计算机中通过电压高低来表示以为所含有的值。 如果是0，则用低电压表示；如果是1，则用高电压表示。\n在上述的二进制位序这个层次上，位的集合没有结构，很难解释这些系列的意义。 为了能够从整体上考虑这些位，于是给这些位序列枪架上结构的概念，这样的结构被称为字节（byte）和字（word）。 通常，一个字节由8位构成，而一个字由32位构成，或者说4个字节构成。\n经常可能被问到的一个问题是：“存款有几位数了？”如果回答是4位数，那了不起也就是万元少点。如果回答是6位数，那就是几十万了。 日常生活中，通过十进制的位数，就可以发现要表达的数越大，需要十进制的位数也就越多。\n一个字节只有8位，一个字节能表达的最大数据也就是111111112，即8位数的二进制就是255。也就是说，一个字节最大能存储的证书是255。两个字节呢？11111111111111112的十进制是65535。四个字节呢？是4294967295。32位计算机中，一个整型需要4个字节博爱是，所以最大整数是4294967295，超过4294967295之后，比如4294967296在计算机中用一个整型就表示不了了。 在计算机中，需要表示的数越大，需要的二进制位也就越多，也需要更多字节来保存。\n26个英文字母可以用26个数字分别对应，如果算上大小写，也就52个数字。再加上英文标点符号和10个数字，总共加起来也不足127个字符。 于是美国有关的标准化组织就出台了所谓的美国标准信息交换码（ASCII编码），同意规定了上述常用符号用那些二进制数来表示。\n如果汉字要在计算机中表示，就没那么简单了。 汉字由上万个，用一个字节表示一个汉字的话，最多只能表示256个汉字，必须使用两个字节才能把所有汉字表示完全。 所以在计算机中，一个汉字用两个字节表示。 假设一篇文章由100个汉字组成，那么至少需要2*100=200个字节表示。\n计算机中物理内存的空间大小是有限的，现在内存条一般是8G大小。 硬盘的空间也有限，现在的硬盘一般都超过了512G大小。 在这里8G 和512G是什么意思呢？ 这里其实是一个简单的单位换算。\n1字节=8位\r1K字节=1024字节=2\u0026lt;sup\u0026gt;10\u0026lt;/sup\u0026gt;字节，也就是1K=1024\r1M字节=1024K字节=1024*1024字节=2\u0026lt;sup\u0026gt;20\u0026lt;/sup\u0026gt;字节，也就是1M=1024K\r1G字节=1024M=1024*1024*1024字节=2\u0026lt;sup\u0026gt;30\u0026lt;/sup\u0026gt;字节，也就是1G =1024M\r 所以如果一个512G大小的硬盘用来全部储存汉字，可以储存多少个字呢？ 512G =512*1024*1024*1024/2个汉字=274,877,906,944个汉字。\n"},{"id":34,"href":"/docs/BDL/1.basic/3.composition_of_bdl/2.annotation/","title":"2.为何要注释","section":"第三章 最简单bdl程序的组成","content":"注释\u0026ndash;为何有必要在代码里留下程序员的解释\r#\r\rdatabase ds --连接数据库 main # 入口函数  display sfmt(\u0026#34;hello world\u0026#34;) {打印} end main 以上代码中出现最多的是“\u0026ndash;”，“#”和“{}”后面或中间包含中文，这些就是注释。\n注释是用来帮助程序员阅读源代码和理解源代码的。 编译器在编译时候，会把注释剔除掉然后再进行编译，当前编译器是不会修改源文件，这些都是在内存中完成。 由于对于注释部分忽略不处理，就如同没有这些字符一样，所以注释不会增加编译后的文件长度，对程序运行不起任何作用。对于注释，有以下几点说明。\n BDL的注释 由“\u0026ndash;”，“#”行注释，和“{}”包裹起来的块注释对。 编译器将行注释后的任何文件，和块注释包裹起来的任何文件都不予处理。 例如  {\r这\r些\r都\r是\r注\r释\r}\r--这些都是注释\r#这个有 空格 注释可以放在任何地方。通常，把注释放在要描述的代码上方，比较合适。对比比较短的代码，也可以放在后面。 注释和代码一定要同步更新。 代码修改而注释不做改变，这样的事情再实际开发中经常看见，而这一的情况可能带来严重后果。 注释内部不能再出现注释  {\r{\r这是不允许的\r}\r} 适量和恰当的注释是良好的编程风格的重要体现。  注释可以用来概括程序的算法、标识变量和函数的意义，或者解释一段代码的意图。 但是在代码中混杂过多的注释会使得程序更难以理解，反而影响代码阅读。\n"},{"id":35,"href":"/docs/BDL/1.basic/2.first_code/2.environment_of_BDL/","title":"2.BDL开发环境","section":"第二章 第一行代码","content":"BDL开发环境\r#\r\r本书所有代码运行的环境都在fjs-fgl-2.4版本，开发环境为linux系统。 本书不涉及环境如何部署。\n项目目录结构\r#\r\rtiptop gp 和 t100 都有固定的项目结构，\r点此查看。 建议你在不影响正式使用的程序前提下，建立或修改程序代码。\ntiptop gp\r编译\r#\r\rtiptop gp环境中需在代码对应的4gl目录下，运行命令r.c2 czzi001，czzi001是你建立的程序编号。即4gl文件去掉后缀名后的内容。\n连接\r#\r\rtiptop gp连接命令为 r.l2 czzi001，注意：这里的czzi001不是4gl文件程序编号，而是在p_zz中注册的程序。所以在运行r.l2连接之前，你还需要做以下这些步骤。\n 新增p_zz资料 如果你现在还不知道p_zz作业的功能，没关系，现在你可以参考czzi001的内容，将czzi001替换为你的程序编号，czz替换为你的程序编号前三位。  \r 需要注意的时czzi001.4gl 一般放在czz/4gl目录下，同样azzi001.4gl 也放在azz/4gl目录下，在你更进一步理解BDL的目录结构前，就一直按照这种方式建立新程序。\n 点击维护链接资料建立连接资料 (链接和连接是同一种说法的不同翻译)  \r\r新建程序时，会提示你无资料，是否建立，这里选择是。 看到下方有一笔路径为$CUST/czz/42m/czz_czzi001.42m的资料。 当后续我们程序更复杂时，会主动添加更多需要的连接资料。\n最后保存时此弹窗的意思，是让你自动连接一次，可以选择是，连接失败也不要仅，只要资料有产生就可以。\nt100\r编译\r#\r\r\r开始编辑代码\r#\r\r以上设置好之后，你就可以编辑代码了。\n\r我用的vs code编辑器，配合Informix 4GL这款插件，所以代码可以高亮，不同的单次有不同的颜色，起到了提醒的作用。\n除了vscode，t100自带的开发平台T100 design、submlime text、4js官方提供的genero studio等工具也能有高亮样式。\ndatabase ds -- 指定数据库，因为t100和tiptop gp有部分功能必须使用数据，所以这里必须先连接数据库 MAIN --主函数 入口点  DISPLAY \u0026#34;Hello World\u0026#34; -- 打印字符串 END MAIN  也许你注意到了，database是小写，MAIN是大写，在BDL语言中，大小写是不区分了，类似于SQL。你甚至了混合使用。\n "},{"id":36,"href":"/docs/BDL/1.basic/1.before_all/2.how-learn-dbl/","title":"2.如何学好BDL语言","section":"第一章 踏上征程前的思想动员","content":"如何学好BDL语言\r#\r\r无论出于什么目的，一旦下定绝心学习BDL语言，就要端正自信，因为听过BDL用的少，和其它语言差异太多，所以觉得学不好，或者随便学学，是不可取的。只要你掌握一些方法，克服畏惧心理，不轻言放弃，是完全可以学好的。\n多动手多求人\r#\r\r所有的问题都可以通过自己编写代码观察结果解决。凡是可以通过编写代码观察到结果的问题，都不应该成为一个问题。不会的，也不要太固执，多问问有经验的人。\n多学习优秀代码\r#\r\rBDL相当灵活，即使写的代码不优秀，也可以编译后达到你的运行目标，但是有的代码可以使用更少的代码实现相同功能，或者代码更加具有复用价值。我相信你很容就能找到不错的BDL代码。\n多以人类的思考方法来类比计算机\r#\r\r计算机需要什么数据、如何获取这些数据、得到后如何存放、如何处理、处理后如何表现等，对这些问题要多问写为什么，一旦理解了计算机处理这些问题的过程，编程就是一件异常轻松的事情了。\n多了解可以直接使用的功能\r#\r\r如果你在使用tiptop gp t100，会有相当多的功能都已经做好成为函数，等待你的调用。请多了解有哪些函数可以使用。\n"},{"id":37,"href":"/docs/Practice/","title":"BDL练习题","section":"Docs","content":"BDL 练习题\r#\r\r请配合 BDL 教程使用，不能解决的问题不要灰心，请回顾教程后过一段时间再继续尝试。\n"},{"id":38,"href":"/docs/BDL/2.medium/17.interface/3.fglform/","title":"3.画面档文件的编译","section":"第十七章 用户界面","content":"画面档文件的编译\r#\r\r4fd文件是我们的使用studio开发后保存的文件，但我们无法直接调用这个文件。\n在BDL中我们最终能使用的画面档文件是42f，从4fd到42f还需要经历一个编译的过程。\n4fd 对应代码的文件的4gl\n42f对应代码文件的42m\nper文件\r#\r\r在上个世纪，和这个世纪初，编写画面档并不是鼠标拖拽这么简单，画面档也需要编写代码实现。\nper就是BDL之前的画面档文件，和4fd不同，per文件是纯代码编写。\n\r以上4fd文件，转为per描述如下：\nSCHEMA formonly  LAYOUT (text=%\u0026#34;Form\u0026#34;) VBox VBox1 Folder Folder1 Page Page1(text=%\u0026#34;Page1\u0026#34;) Grid Grid2 {   [label1 ]  } END -- Grid2 END -- Page1 Page Page2(text=%\u0026#34;Page2\u0026#34;) Grid Grid1 {   [label2 ]   } END -- Grid1- END -- Page2 END -- Folder1 Table Table1 { [edit1 |edit2 ] [edit1 |edit2 ] [edit1 |edit2 ] [edit1 |edit2 ] [edit1 |edit2 ] } END -- Table1 END -- VBox1 END -- Form  ATTRIBUTES Label label1:Label1, text=%\u0026#34;Label1\u0026#34;; Label label2:Label2, text=%\u0026#34;Label2\u0026#34;; Edit edit1=formonly.Edit1, tabIndex=1, title=%\u0026#34;Edit1\u0026#34;; Edit edit2=formonly.Edit2, tabIndex=2, title=%\u0026#34;Edit2\u0026#34;; END -- ATTRIBUTES  INSTRUCTIONS SCREEN RECORD Record1(formonly.Edit1,formonly.Edit2) END -- INSTRUCTIONS 可以看到per文件时相当复杂的，甚至会用空格的个数来控制栏位的大小。\n虽然限制per文件已经被4fd文件替代了，但是per依然可以使用，实际上这两种格式文件可以任意转化。\n但是并不是等价的，per文件的信息比4fd少。\n编译为42f\r#\r\rper，4fd文件都是可以编译为42f文件的\n# per fglform czzi001 # 4fd gsform czzi001 虽然命令不同，但都能生成42f文件\n4fd 与 per 转换\r#\r\r4fd \u0026ndash;\u0026gt; per\r#\r\r4fd 无法直接转为 per，但是per是编译为42f的中间产物，一般编译时都删除per文件，我们可以不删除，保留它。\ngsform -keep czzi001 per \u0026ndash;\u0026gt; 4fd\r#\r\rgsform -import czzi001 tiptop gp 的画面档编译方式\r#\r\r同r.c2，r.l2 一样，tiptop gp也封装了一些更方便的画面档编译命令。\n r.f2  一键编译画面档文件(不区分per和4fd)，在per文件或者4fd文件的目录下运行即可，可以编译为42f，并将文件放在对应的目录下。\nr.f2 czzi001  r.gf  任意目录下都可以运行，可以预览编译好的画面档文件。\nr.gf czzi001 2 p \r 2参数 为语言别 ，2 为简体中文 1 为英文 0 为繁体中文 p参数 为客制否 p 为标准模组 c 为客制模组  "},{"id":39,"href":"/docs/BDL/2.medium/16.module/3.p_link/","title":"3.p_link作业","section":"第十六章 模块","content":"p_link作业\u0026ndash;使用r.l2 链接作业\r#\r\r无论是链接所有42m文件，还是先链接为42r文件，再链接到主程序。都需要我们将需要调用程序链接起来，如果只运行一次还好。 但是编写程序过程中难免会出错，即使能力很强，能够保证每次不出错，后续新功能增加时，也需要重新连接编译。\n我们需要一种新的简单的方式去链接主程序。\np_link\r#\r\r之前我们使用r.c2命令时，此命令自动将42m文件放到42m目录下，如果链接也能够自动链接对应的文件就好了。\np_link就是方便程序链接的作业。\n你可以直接运行exe2 p_link打开作业，也可以再p_zz中维护链结档资料按钮中打开。\n让我们用tiptop gp方式重新编译链接czzi004.4gl文件。\n 建立p_zz资料  \r运行指令其实就是42r文件，$CZZi目录就是czz/42r目录。\n点击维护链结档资料  \r如果第一次建立，会提示生成链接档资料，选择是会打开p_link作业\n\r自动新增的p_link资料只包含czzi004.42m主程序文件。\nr.c2 s_czzi004并在p_link中新增  \r 必须先使用r.c2编译，42m目录中没有czzi004.42m的话，会报错 完整路径是由模组编号和程序代码组合生成的   输入完成后，会自动链接，如果有报错，先忽略报错，关掉报错窗口\n  回到命令行r.c2 czzi004编译主程序\n  database ds编译前在第一行增加这个语句，否则会报错\n链接主程序r.l2 czzi004  /u1/genero/fgl.dev/bin/fgl2p -o czzi004.42r libgre.42x WSHelper.42m lib.42x sub.42x qry.42x czz_czzi004.42m czz_s_czzi004.42m  czzi004.42r has been generated successfully! 上面为成功通知。\n我们看链接的过程，和我们直接fgllink有很多区别\n fgl2p r.l2 没有使用fgllink  fgl2p 相比fgllink除了有链接的功能，如果链接文件包含4gl文件，还可以自动将4gl编译为42m后再链接。\nlibgre.42x WSHelper.42m qry.42x  这几个也是类似lib和sub函数库。\n程序开发流程\r#\r\r\r\r\r\r"},{"id":40,"href":"/docs/BDL/2.medium/15.function_plus/3.life-cycle/","title":"3.生命周期","section":"第十五章 函数进阶","content":"函数生命周期\r#\r\r编程就是写函数，main的开始结束就是程序的开始结束。\n函数的开始就是函数调用，结束就是函数最后一行运行结束，或者运行到return处。\n调用\n call add() returning \u0026hellip; display add() let a = add() call minus(10,add()) \u0026hellip;  \r\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rgraph LR\ra0([\"开始\"])--a[\"调用\"]\ra--b[\"执行语句\"]\rb--c[\"end funtion/return\"]\rc--d([\"结束\"])\r变量的生命周期\r#\r\r编程就是写函数，函数本质是什么呢？ 函数的本质是输入、处理、输出\n输入的是变量，输出的是变量。处理的也是变量。\n如果程序中一直增加功能，那么变量的数量会一直增加，如果不停增加下去，内存迟早有用完的一天。\n但实际上一个规划良好的程序并不会将内存全部占用。\n这是因为，在BDL中变量不是一直加载到内存中，有些变量用到的时候才会分配内存，不用的时候，内存会释放掉。\n那么变量在定义时就会分配内存，那么什么时候释放其内存呢？\n变量所在的作用域，所有语句执行完成时释放内存，在BDL中最小的作用域是函数。\n  所以在函数中定义的变量，在函数执行完后，变量就释放内存了。所以我们需要返回值，并用变量接受这个返回值。\n  定义在main函数之前的函数，在main执行结束后才能释放内存。\n  函数中定义的变量 graph LR\ra[\"函数调用\"]--b[[\"分配内存\"]]\rb--c((\"...\"))\rc--d[\"end funtion/return\"]\rd--z[[\"释放内存\"]]\r"},{"id":41,"href":"/docs/BDL/2.medium/14.database/3.update-insert-delete/","title":"3.插入更新删除","section":"第十四章 数据库使用","content":"插入更新删除\u0026ndash;BDL操作数据\r#\r\r提前确认\r#\r\r在每次操作数据之前，请确认当前连接的数据库是否正确。\n不要更新错了库！\n 本节内容需要你了解SQL基础语法，如果不了解可以参考此教程\r一篇文章学会SQL。\n 插入INSERT\r#\r\r在BDL中操作数据库有两种方式，一种是直接使用SQL原生语句，另一种是使用BDL的SQL语句。\n原生语句\r#\r\r 将要执行SQL语句放到字符串中  let l_sql = \u0026#34;INSERT INTO demo_file (demo001,demo002,demo003) values(\u0026#39;mar-001\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39;)\u0026#34; prepare SQL语句  prepare demo_ins from l_sql -- demo_ins为标识符 执行SQL语句  execute demo_ins 检查SQL是否执行成功  在BDL中有一个特殊的全局变量sqlca用来记录SQL执行情况。\n define sqlca record  sqlcode integer, -- 报错代码 100 表示未找到 \u0026lt;0表示有错误  sqlerrm string, --错误消息数量  sqlerrp string,  sqlerrd array[6] integer,  -- 1. 未使用  -- 2. 最后一个Serial或错误代码  -- 3. 最后一条语句处理的行数  -- 4. CPU使用时间  -- 5. SQL文件错误偏移量  -- 6. 最后一行的ROWID  sqlawarn string  end record 更新时只要检查sqlca.sqlcode 为0 且 sqlca.sqlerrd[3]大于0，那么就是执行成功。否则有报错，或者没成功。\n原生语句中使用占位符号\r#\r\r在实际情况，我们可能要插入多条数据，且每条数据都不一样。这个时候如果每次都写一次sql，prepare一次，就不合理了。\n我们可以使用占位符，和sfmt(\u0026quot;%1 %2\u0026quot;,2,3)中的占位符号一样，SQL也可以有类似的语法，我们只要修改两个地方。\n 修改SQL语句  在BDL中，SQL的占位符为?，我们将所有要插入的字段值替换为?符号。\nlet l_sql = \u0026#34;INSERT INTO demo_file (demo001,demo002,demo003) values(?,?,?)\u0026#34; 执行SQL  prepare 语句不变，只要在执行时，我们加上我们要插入的数据即可。\nexecute demo_ins using \u0026#39;mar-001\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39; execute demo_ins using \u0026#39;mar-002\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39; execute demo_ins using \u0026#39;mar-003\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39; 我们可以每次插入不同的数据，记得每次检查SQL是否执行成功。\n注意\n这里USING 关键字虽然和格式化数字的USING一样，但是是不同的语法。这里要考虑USING 用在什么位置。即考虑上下文。\nexecute demo_ins using \u0026#39;mar-003\u0026#39;, 12 using \u0026#34;\u0026lt;\u0026lt;\u0026lt;\u0026lt;.\u0026amp;\u0026amp;\u0026#34; ,\u0026#39;xxx\u0026#39; 如上面语句，第一个using是 execute中将后面的值传入SQL语句代替占位符的意思。\n第二个using是格式化数字的意思。\n\rBDL的SQL语句\r#\r\r除了SQL原生语句，BDL也提供了更简单的插入数据语法。\n直接运行一下语句，也可以将资料更新到数据库中。\nINSERT INTO demo_file (demo001,demo002,demo003) values(\u0026#39;mar-001\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39;) 检查SQL执行成功否和原生SQL检查方法一样。\n原生SQL和BDL SQL比较\r#\r\rBDL 语法和原生SQL同时插入三次执行过程如下：\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rgraph LR\ra[\"原生SQL\"]--b[\"prepare\"]\rb--c[\"execute\"]\rc--3次--c\rA[\"BDL SQL\"]--B[\"翻译为数据库SQL\"]\rB--C[\"prepare\"]\rC--D[\"execute\"]\rD--3次--A\r注意\nBDL自带语法写着简单，但是效率没有原生SQL高。\n如果你要批量插入多笔数据，还是使用原生SQL，每次execute比较快。\n\r更新UPDATE\r#\r\r和插入一样，更新也可以写为两种方式。\n 原生SQL  let l_sql = \u0026#34;update demo_file set demo002 = ?,demo003=? where demo001= ? \u0026#34; prepare demo_upd from l_sql excute demo_upd using \u0026#34;yyy\u0026#34;,\u0026#39;yyy\u0026#39;,\u0026#39;mar-001\u0026#39; BDL SQL  update demo_file set demo002 = \u0026#39;yyy\u0026#39;,demo003=\u0026#39;yyy\u0026#39; where demo001=\u0026#39;mar-001\u0026#39; 删除DELETE\r#\r\r和插入一样，删除也可以写为两种方式。\n 原生SQL  let l_sql = \u0026#34;delete from demo_file where demo001 like ?\u0026#34; prepare demo_del from l_sql excute demo_del using \u0026#39;%00%\u0026#39; BDL SQL  delete from demo_file where demo001 like \u0026#39;%00%\u0026#39; "},{"id":42,"href":"/docs/BDL/2.medium/13.struct/3.nesting-record/","title":"3.结构体嵌套","section":"第十三章 结构体","content":"结构体嵌套\r#\r\r上一节中讨论的person结构相对简单，只包含了3个数据成员: name、age和email, 如果面对的是更为复杂的结构，将所有数据成员并排似乎不是个高效的方法。那能否使用结构体嵌套，一层层管理数据呢?\n结构体嵌套定义\r#\r\r顾名思义，结构体嵌套就是“结构体套结构体”，某个结构体的成员也是一个结构体变量，这样就可以按层次结构合理组织数据，举例如下：\ntype student record  score record  math integer,  english integer  end record,  info record  height,weight decimal(10,2)  end record end record student是个外层结构，内部包含着学生的数据，结构体student内又定义了两个结构体变量score (成绩)和info (基本情况),结构体中的成员应当是占据内存空间的变量实体，因此，score和info是student结构的数据成员，结构体scorestruct和infostruct只是两个类型名，不占据实在的内存地址空间。将上述代码如下改写似乎更好理解一点:\ntype score record  math integer,  english integer end record type info record  height,weight decimal(10,2) end record type student record  score score,  info info end record 在结构体内部申明的结构体类型是不可见的，只能通过外部结构体调用。\ntype student record  score record  math integer,  english integer  end record,  info record  height,weight decimal(10,2)  end record end record define zhangsan student 例如以上代码，你只能使用zhangsan.score.math来访问成员math，score无法省略，因为info结构体类型中也可以声明一个成员math，为了避免歧义，每层结构体的名称都必须显示的写出来，而不能省略。\n你也无法使用define lisi info这种形式定义一个只有info的结构体变量，因为info在student内部声明，你只能通过student来访问。\n"},{"id":43,"href":"/docs/BDL/2.medium/11.array/3.two-dimensional/","title":"3.二维数组","section":"第十一章 数组-同一类型的多个元素的集合","content":"二维数组\r#\r\r一维数组常称为向量，本节介绍二维数组。所谓二维数组，最简单的理解是“有两个下标’如果把一维数组理解为一行数据，那么，二维数组可形象地表示为行列结构，如图所示,左侧表示的是一个大小为M的一维数组：\n   A[1] A[2] \u0026hellip; A[M]    右侧表示的是-一个大小为M*N的二维数组：\n   A[0,1] A[0,2] \u0026hellip; A[0,N]     A[1,1] A[1,2] \u0026hellip; A[1,N]   \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip;   A[M,1] A[M,2] \u0026hellip; A[M,N]    二维数组的定义\r#\r\r和一维数组一样，定义二维数组时，要告诉编译器以下信息：数组名、元素类型、元素的个数。对二维数组来说，元素个数时两位大小的成绩。\n动态数组时只要定义数组的维度即可。\n示例如下：\n define a array [2,3] integer -- 定义一个2x3的定长数组，一共有2*3=6个元素。  define b dynamic with dimension 2 of string --定义一个二维的动态字符串数组 定长和动态二维数组都可以访问的语法都是一样的。\narray[m,n] 二维数组应用举例\r#\r\r查看以下代码，演示二维数组的使用方式。\n define score array[6,3] of integer --表示6个学生的3门成绩  define s array[3] of integer --每门课的总成绩  define i , j integer   -- 输入总共18门成绩  for i = 1 to 6  prompt sfmt(\u0026#34;请输入第%1位学生的成绩%2：\u0026#34;,i,1) for score[i,1]  prompt sfmt(\u0026#34;请输入第%1位学生的成绩%2：\u0026#34;,i,2) for score[i,2]  prompt sfmt(\u0026#34;请输入第%1位学生的成绩%2：\u0026#34;,i,3) for score[i,3]  end for   -- 计算每门课总成绩  for i = 1 to 3  let s[i] = 0  for j = 1 to 6  let s[i] = s[i] + score[j,i]  end for  end for   display \u0026#34;\\n平均成绩：\u0026#34;  for i = 1 to 3  display sfmt(\u0026#34;第%1门课的平均成绩为%2\u0026#34;,i,(s[i]/6 using \u0026#34;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;##.\u0026amp;\u0026amp;\u0026#34;))  end for 输出结果为：\n平均成绩：\r第1门课的平均成绩为268.00\r第2门课的平均成绩为120.33\r第3门课的平均成绩为169.17 请注意每次访问数组的时候，[]的索引是用的哪一个。\n"},{"id":44,"href":"/docs/BDL/2.medium/10.function/3.formal-actual/","title":"3.函数调用与返回","section":"第十章 函数入门-写程序就是写函数","content":"函数调用与返回\r#\r\r形参和实参\r#\r\r请观察一下代码：\nmain  define x,y,sum integer  let x = 5 let y = 7  call add(x,y) returning sum  display sum end main function add(a,b)  define a,b integer  return a + b end function 在上面代码中参数列表是a和b，而在函数调用时传递进来的参数是x和y，这两种参数是申明关系呢？ 打个形象的比方，这是角色和演员的关系。\n函数定义时列表中参数为形数，是“剧本角色”，而函数调用时传递进来的参数称为实参，是“演员”，函数执行的过程就是演戏的过程。\n程序刚开始执行的时候，系统并不为形参分配存储空间，因为它只是个角色，不是实体，一直要到函数调用时，系统为形参分配存储空间，并将实参的值复制给形参。\n结合代码上面代码可知，在call add(x,y) returning sum语句调用前，a和b都不是真正的程序变量，一直到add函数被调用，a和b才被创建，并分别用x和y为其赋值，在这种情况下，在函数内对a和b的处理并不影响x和y，这类似于“ 某个演员扮演的角色在戏中受伤，并不是说演员真的受伤了”，而且，在函数执行结束返回时，创建的形参被撤销，这类似于“戏演完 了，剧中角色自然也就停止了”。\n举例来看，下列示例代码先交换两个变量的值，但并没有成功，为什么?请试着用演员和角色的关系来解释一下。\n--视图交换两个变量的值 main  define num1,num2 integer  display \u0026#34;\u0026#34;  display sfmt(\u0026#34;num1 is %1,num2 is %2 \u0026#34;,num1,num2)  call swap2Variable(num1,num2)  display sfmt(\u0026#34;num1 is %1,num2 is %2 \u0026#34;,num1,num2) end mian function swap2Variable(a,b)  define a,b,c integer   display sfmt(\u0026#34;a is %1,b is %2 \u0026#34;,a,b)  let c = a  let a = b  let b = c  display sfmt(\u0026#34;a is %1,b is %2 \u0026#34;,a,b) end function 输出结果为：\nnum1 is 10,num2 is 5\ra is 10,b is 5\ra is 5,b is 10\rnum1 is 10,num2 is 5 代码解析\n在函数调用时，形参a和b才被创建，并分别用num1和num2为其赋值，而后，在函数内对a和b的交换成功，但这与外部的numl和num2完全无关，函数执行完毕退出时，形参a和b被撤销，再次输出num1和num2,两者的值并没有交换。\n形参和实参有如下特点：\n 即使同名，实参和形参也不共用一块内存，形参变量只有在函数被调用时才分配内存空间，由实参将数据传给形参，在函数调用结束后，立即释放形参占用的内存空间。 实参可以是变量、常量、表达式甚至是函数等，无论实参是何种类型的量，在进行函数调用时，其必须有确定的值，以便把这些值传给形参，因此，应预先用赋值、输入等方法使实参获得确定值。 对于自定义函数和库函数，形参的类型已经说明，调用函数时，形参和实参在数量、类型和顺序上应保持-致。特别强调类型一致，如果是可自动转换的类型差异，编译器将自动完成相互间的转换。如果对应的形参和实参类型不一致，且编译器无法完成其间的自动转换,编译器将报错。  函数返回\r#\r\r看一下以下代码：\n function add(a,b)  define a,b integer  return a + b  end function 既然说a和b都是形参，在程序调用时才创建，程序退出时便被撤销，那类似\u0026quot;return a+b\u0026quot;之类的返回语句岂不是没有意义，返回一个被撤销的量？\n函数的返回机制应如何理解呢？\n理解的关键词时“复制”，执行到return语句时，return的值被复制到某个内存单元或寄存器中，其地址是由系统来维护的，我们不用操心，也就是说，在a和b被撤销前，返回值被保存在某个地方，系统访问该内存单元即可知道函数的返回值。\n下属语句:\ncall add(x,y) returning z 实际上面代码完成下述一系列操作\n 将实参x和y以传值方式传人函数add中，函数触发 返回值的值复制保存到某个内存单元处，假设是M处 用M处保存的函数返回值复制给变量z  "},{"id":45,"href":"/docs/BDL/1.basic/9.over_and_over_again/3.cycle-in-cycle/","title":"3.循环嵌套","section":"第九章 循环结构--一遍又一遍","content":"循环嵌套\r#\r\r循环结构也支持嵌套，如果把简单的循环内容为“一遍又一遍”，那循环嵌套便可称为“一层又一层，一遍又一遍”。\n可以用始终来打比方，走一个代表执行一次循环，那么一小时里，分针又要走60个格，而分针每走一格，秒针也要走60格。\n如此，秒针的走动可以看成是内存循环，而分针的走动可看成是外层循环。\n嵌套示例\r#\r\r已for循环结构举例，限制想在屏幕上输出4*9个星号，这可以利用双重循环来做：\n define i,j integer  define s string  display \u0026#34;\u0026#34;  for i = 1 to 4  let s = \u0026#34;\u0026#34;  for j = 1 to 9  let s = s, \u0026#34;* \u0026#34;  end for  display s  end for 输出结果为：\n* * * * * * * * *\r* * * * * * * * *\r* * * * * * * * *\r* * * * * * * * * 代码解析\n上述代码中，采用双重循环来画出上述图形，第1层循环控制行，循环变量是i,从1循环到4，第2层循环控制列，循环变量是j，从1循环到9，输出“星号+两个空格”。\n初始时，i=1,满足外层循环条件i\u0026lt;=4，进人循环体，进入第一层循环体时，我们初始化变量字符串s，因为我们需要一个字符串保存每一行我们要输出的内容，否则输出的内容将自动换行，其循环体是由内层循环for结构和换行语句组成，内层循环开始执行，将9个星号都拼接到s字符串中，这和求和类似，当完成内循环，我们diplay处字符串的值；此时，转到执行外部循环体的自动变量增加，开始新一轮外层循环，以此类推，输出了4*9个星号图案。\n对循环控制结构来说，不仅可以双重嵌套，还可做到三重、四重甚至更多层次的嵌套，顺序、分支和循环3种结构互相搭配，组成的算法形式也各种各样，这为开发人员提供了极大的自由空间。\n嵌套的效率\r#\r\r在循环嵌套中，程序流程需要在内层循环和外层循环间跳转，每次跳转都要付出一定的开销，这体现在对CPU和内存的调度和占用上(具体涉及体系结构方面的知识，本书不再展开 述)。\n因此，在编程时应有意识地考虑嵌套的效率问题。 在多重循环中，如果有可能，一般将重复次数多的循环放在里层，循环次数少的循环放在外层，以减少内外层循环切换的次数，提高程序的效率。\n"},{"id":46,"href":"/docs/BDL/1.basic/8.condition/3.multi-branch/","title":"3.多分枝语句和分支语句嵌套","section":"第八章 条件判断-分支结构","content":"多分枝语句和分支语句嵌套\r#\r\r讲过了“2选1”， 那如果出现“3选1”， 甚至是“N选1”怎么办?可使用多分支语句和分支语句嵌套。此外，BDL语言还提供了开关语句case,这是一种特殊的选择分支结构，稍后一节会讨论case的用法。本节来看一下分支语句嵌套的问题。\n多分支\r#\r\r用实例说明似乎更好理解，假设需要编制-一个程序，根据学生的得分判定其类别，具体是:少于60分判为D (不及格)，60到74分判为C (一般)， 75到89分判为B (良好)，大于等于90分判为A (优秀)，学习分支结构后读者编写的代码可能如下所示。\n define mark integer  prompt \u0026#34;请输入该学生成绩：\u0026#34; for mark  if mark \u0026gt;= 90 then  display \u0026#34;A\u0026#34;  end if  if mark \u0026gt;= 75 and mark \u0026lt;90 then  display \u0026#34;B\u0026#34;  end if  if mark \u0026gt;= 60 and mark mark \u0026lt;75 then  display \u0026#34;C\u0026#34;  end if  if mark \u0026lt;60 then  display \u0026#34;D\u0026#34;  end if 代码解析\n代码的结果符合要求，但使用4个并列if结构在效率上会大打折扣，画出其流程图，如图所示。 \rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rflowchart TD\ra([\"开始\"])--b[\"申明变量mark、并输出提示，请用户输入\"]\rb--c[/\"接受用户输入\"/]\rc--d{\"mark=90?\"}\rd--\"yes\"--e[\"输出'A'\"]\rd--\"no\"--f{\"mark=75 and mark f\rf--\"yes\"--g[\"输出'B'\"]\rf--\"no\"--h{\"mark=60 and mark h\rh--\"yes\"--i[\"输出C\"]\rh--\"no\"--j{\"markj\rj--\"yes\"--k[\"输出'D'\"]\rj--\"no\"--l([\"结束\"])\rk--l\r不论用户输入什么样的成绩，都会经过4次判断。有时候，某些判断不是必须的，比如说，如果用户输人的是95，实际上输出A之后程序就可以结束了，后面的3个判断完全是多余的。基于这种思路，可对代码进行改进。\n改进的方法有多种:对于以上代码这种判断并执行对应代码块后就结束的程序，可以在代码块中display后调用exit program函数提前“毙掉”当前程序。\nexit program其功能是中止程序的执行，并在退出前对程序占用的资源进行必要的清理。 exit是一个无返回值的函数，其参数称为退出码，用以通知操作系统当前程序是正常终止(一般为0)还是非正常终止(一般为-1)。\n大多数情况下，在判断后程序并未结束，后面还有代码要执行，可以使用自由跳转语句goto,但这种太过自由的跳转的大量使用会使得程序如一团乱麻，理不清读不顺。因此，很多专家都反对使用goto语句，goto跳转 将在第9章中进行介绍，本节单就分支本身进行讨论。使用多分支if结构或分支结构嵌套来解决这一问题。\n分支语句嵌套\r#\r\r方if(或者if else)结构红执行语句又是if(或者if else)结构时，称为分支语句嵌套。 分支语句嵌套的样式有千万种，不可能一一列举，举个简单的例子：\nif 表达式1 then\rif 表达式2 then\r语句1\relse\r语句2\rend if\rend if 上述代码时在if结构内嵌套了if else结构，首先计算表达式1的值，如果过值为假（0），直接跳过结构，语句1和语句2都不会执行，如果其值为真（非0），则执行内部的if else结构。 计算表达式2的值，如果其值为真，执行语句1，否则执行语句2。\n可以看出，分支结构嵌套的执行流程实际上是个剥壳的过程，一层层地做出选择。有的读者可能会对上面的示例有所疑惑，两个if和一个else,它们的搭配关系是怎样的? BDL标准规定:else语句总是和它前面最近的if配对。\n练习\r#\r\r尝试将判断成绩的分支结构改为嵌套分支结构，减少不必要的判断语句计算。\n"},{"id":47,"href":"/docs/BDL/1.basic/7.atoml_statement/3.practice/","title":"3.练习","section":"第七章 语句-程序最小构成单元","content":"练习\r#\r\r根据以下伪代码，写一个小程序\r#\r\r 大于等于60分的输出“合格”，小于60分的输出“不合格”。\n 用户输入\r如果（用户输入的数值小于60）\r执行A操作\r否则\r执行B操作 "},{"id":48,"href":"/docs/BDL/1.basic/6.operators_and_expressions/3.logical-operator/","title":"3.逻辑运算符","section":"第六章 运算符和表达式-程序基本构成","content":"逻辑运算符和逻辑表达式\r#\r\r逻辑运算符\r#\r\r关系表达式的输出结果为“真”和“假”，但关系表达式毕竟只能判断一次，实际问题常常遇到多个条件判断情况。 例如，“如果从济南到北京比上海近，并且明天不下雨，就去北京旅游”。 BDL语言遇到这种情况，就要使用逻辑运算符和逻辑表达式。\n逻辑运算符\n   运算符 描述     not 如果右边表示大为true返回false，如果为flase，返回true   and 如果左边和右边表达式都为true,返回true,否则false   or 如果左边和右边表达式都为false,返回false,否则true    逻辑运算符\r#\r\r在计算机中，逻辑运算符可以理解为，``与 或 非`。\n 与（AND）  “表达式1 and 表达式2”，只有当两个条件都为 非0 时，运算结果为非0，否则结果为0。\n所有表达式是并且的关系，都成立时才认为成立，有任意一条不成立，就算不成立。\n或（or）  “表达式1 or 表达式2”，只有两个条件都为0时，运算结果才为0,否则为1。\n所有表达式是或且的关系，都不成立的时候才不成立，有任意一条成立，就算成立。\n非（not）  “not 表达式”，取反，当表达式为0时，结果为1，当表达式为1时，结果为0。\n所修饰的表达式成立那么就不成立，不成立就成立。\n逻辑真值表\r#\r\r   A B not A not B A and B A or B     真 真 假 假 真 真   真 假 假 真 假 真   假 真 真 假 假 真   假 假 真 真 假 假    总结以下：与运算就是“有一个假，结果为假”，或运算是“有一个真，结果为真”，非运算时“假变真，真变假”。\n下面，是逻辑运算的用法示例：\n define a , b integer  define c , d boolean   let c = a \u0026lt; b  let d = a+3 \u0026gt; b   display sfmt(\u0026#34;\\nnot c and d =%1\u0026#34;,not c and d)  display sfmt(\u0026#34;not (c and d ) =%1\u0026#34;,not (c and d ))  display sfmt(\u0026#34;a \u0026gt; 0 or b \u0026gt; 0 =%1\u0026#34;,a \u0026gt; 0 or b \u0026gt; 0) 请自己键入，编译后查看结果。\n"},{"id":49,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/3.format-number/","title":"3.数字的格式化","section":"第五章 利用键盘、鼠标与程序交互","content":"数字的格式化\r#\r\r之前我们说过日期在BDL语言也是储存为整数类型，请运行以下代码，观察其输出值\ndefine t date display t 发现其结果是\n1899/12/31  如果你的环境是1899/12/31，是因为DBDATE环境变量为Y2MD/，修改为Y4MD/之后就变为4位。不建议修改，因为已有代码可能是按照2位编写的。\n 日期类型会自动格式输出，那么我如果也想数字格式化输出字符串，应该如果写呢？\n本章就来介绍以下，数字的格式化方式。\n数字货币格式化\r#\r\r在介绍之前，我们尝试运行一下如下代码：\n define a integer  define b decimal(20,6)   let a = 12345  let b = 2345.1235  display sfmt(\u0026#34;a=%1,b=%2\u0026#34;,a,b)  display sfmt(\u0026#34;a=%1,b=%2\u0026#34;,a using \u0026#34;******\u0026#34;,b using \u0026#34;#####.###\u0026#34;) a=12345,b=2345.123500 a=*12345,b= 2345.124  使用了 using \u0026ldquo;******\u0026rdquo; 的12345 在最前面多了一个* 使用了 using \u0026ldquo;#####.###\u0026rdquo; 的2345.1235，整数前多了一个空格，小数保留了3位，且进了一位。  这里的数字/数字变量 using 格式化字符串的格式就是在格式化数字格式。\n格式化字符串中有固定的写法，如下：\n   类型 格式化规则     * 不足的位数补上*   # 不足的位数补上空格   \u0026amp; 不足的位数补上0   \u0026lt; 和\u0026amp;一样，但是左对齐   - 和#一样，但负数会加上-号   + 和-一样，但整数会加上+号   ( 和-一样，但负数会加上()号   ) 和(一样   $ 数值前加上一个币种符号   , ,号左侧有数字才显示,   . 可以限制小数位数   @ 显示多为币种符号    虽然开起来很复杂，但实际使用场景就只有几种\n 金额保留位数 数字左对齐或者右对齐 小数不足位数  常用的几种格式示例:\n --数量左对齐  a using \u0026#34;\u0026lt;\u0026lt;\u0026lt;,\u0026lt;\u0026lt;\u0026lt;,\u0026lt;\u0026lt;+.\u0026amp;\u0026amp;\u0026amp;\u0026#34; --整数部分最大9位，小数保留3位，小数不足补0，正数负数都要有+/-号  -- 金额右对齐  a using \u0026#34;###,###,##-.\u0026amp;\u0026amp;\u0026#34; --整数部分最大9位，小数保留2位，小数不足补0，负数显示-号 日期格式化\r#\r\r章节开头我们说过日期格式化是1899/12/31格式，是环境变量设置。 但如果我们一个程序中需要两种不同格式的日期格式该如果处理呢？\n其实date类型也能用using关键字格式化，格式化规则如下\n   类型 格式化规则     dd 两位表示日期，只有一位时会补0   ddd 表示因为英文星期   mm 同日期，两位月份，自动补0   mmm 三位英文月份   yy 两位月份   yyyy 四位年份   c1 在dd或者ddd后加上c1，可以使用从1912年开始计算年份（民国）    在年月日中，你可以加上合适的分隔符，时日期更好读。\ndisplay a using \u0026#34;yyyy年mm月dd日\u0026#34; 日期格式的运算\r#\r\r在定义日期时，我们知道日期是一个整型，所以如果第二天直接+1即可。\n但是我们在进行赋值一个日期时，还要计算要赋值日期和1899/12/31之前差多少天，也太不方便了。\n所以日期格式有一些更方便的计算和赋值函数(关键字)。\n   名称 使用方法     today() 值为今天的日期let a = today()   current 当前的时间let a= current,注意没有(),所以它是关键字。   date()1 let a = date(34000)``1899/12/31后的第34000天   date()2 let a = date(\u0026quot;1949/10/01\u0026quot;) 以字符串格式赋值日期，字符串的格式必须与DBDATE格式一致   mdy() let a = mdy(10,01,1949)以整型赋值日期，注意参数顺序   year() let a= year(current)取一个日期的年份   month() let a= month(current)取一个日期的月份   day() let a= day(current)取一个日期的日   weekday() let a = weekday(current)取日期的星期   extend(a,b to c) extend (today,year to fraction(4))将日期调整为year to fraction格式    "},{"id":50,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/3.data-types/","title":"3.数据类型","section":"第四章 存储和获取数据","content":"数据类型\r#\r\rBDL语言规定，程序中使用的每一个数据，必须指定其数据类型。\nBDL语言数据类型\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rgraph TD;\rBDL语言数据类型--构造类型\rBDL语言数据类型--基本类型\r构造类型--数组\r构造类型--结构体\r基本类型--字符串类型\r基本类型--数值类型\r数值类型--整型\r数值类型--浮点型\r\rgraph TD;\r整型--DATE\r整型--BINGINT\r整型--INTEGER\r整型--SMALLINT\r整型--TINYINT\r整型--BOOLEAN\rgraph TD;\r浮点型--c[\"FLOAT[(p)]\"]\r浮点型--d[\"SMALLFLOAT\"]\r浮点型--e[\"DECIMAL[(p[,s])]\"]\r浮点型--f[\"MONEY[(p[,s])]\"]\rgraph TD;\r字符串类型--a[\"CHAR[(n)]\"]\r字符串类型--b[\"VARCHAR[(n[,r])]\"]\r字符串类型--STRING\r字符串类型--BYTE\r字符串类型--TEXT\r 基本类型是最基础的简单数据类型，其值无法再分解为其它类型 构造数据类型：顾名思义，构造数据类型是根据已经定义的一个或读个数据类型用构造的方法来定义的。 构造数据类型有多个其它数据类型组合而成。 一个构造类型的值可以分解成若干个成员或元素。 其中每个成员要么是一个基本数据类型，要么又是一个构造类型。 再BDL语言中构造类型又以下几种：   数组类型：所有元素都是同一类型。即数组类型是统一数据类型元素的集合 结构类型：不同数据类型的组合  本节只介绍基本数据类型，其它数据类型再后续陆续介绍。\n整数类型\r#\r\r整数是日常生活和计算机中用得最频繁的数据类型，也比较容易理解。 整数从数学意义上来说就是从负无穷到正无穷之间的任意整型的数据，也就是任意自然数(如1、2、3、4、5)以及它们的负数或0。 如果用十进制表示一个自然数，十进制的位数越多，表示的整数也越大。 在计算机中用二进制表示数据，二进制的位数不能无限使用，所以在计算机中，整数有一定的大小限制，只能在一定的范围之内。 在以前内存“寸土寸金”的时代，哪怕是为了节约2个字节的内存，也是非常有必要的。\n所以BDL语言的整数类型，又分为BINGINT8，INTEGER4，SMALLINT2，TINYINT1。\n在BDL语言中，日期也是用整型标识的，DATE4,它和INTEGER4在内存中存储方式一致，并规定1899/12/31这一天为0，1900/01/01为1。\n除了这些比较大的整数还有一个1位的整型BOOLEAN，它只能保存1或者0。\n请验证以下代码的运行值，后续所有代码不需要的地方都不会在包括main函数：\ndefine a smallint let a = 32767 display a let a = a + 1 display a let a = a + 1 display a 整数的正负\r#\r\r浮点型\r#\r\r  FLOAT[(p)]8\n  SMALLFLOAT4\n  DECIMAL[(p[,s])]\n  BDL中一种特殊浮点数，p位整数的位数（10进制的位数），s位小数的位数（10进制的位数）。 利用这种方式我们实现就可以知道这个数可以储存的小数位数精确度。\n MONEY[(p[,s])]  MONEY是一种特殊的DECIMAL，唯一区别是scale默认位2。在显示时，根据DBMONEY环境变量的值显示对应的币种符号。\n字符串类型\r#\r\r CHAR[(n)]  固定大小字串，\u0026ldquo;a \u0026quot;\n VARCHAR[(n[,r])]  动态字串，\u0026ldquo;a\u0026rdquo;,r位保留字段，为了和数据库语法一致，一般不适用\n STRING  动态大小字串\u0026quot;a\u0026hellip;b\u0026rdquo;\n BYTE31  ~2.14 Gigabytes 二进制文件\n TEXT31  ~2.14 Gigabytes 文本文件\n转义字符\r#\r\r在计算机中，有一批特殊形式的不可打印字符、单引号、双引号、反斜杠、回车退格等，需要用转义系列表示。前面的章节中printf函数使用的\\n就是一种以“\\”开头的字符序列，代表换行的意思。这种非显示字符难以用一般形式的字符表示，所以C语言规定用“\\” 开头的字符其后跟随的字符用另外的意思代替，“\\” 及其后有特殊意义的字符序列称做转义字符。\n常见的转移字符：\n   字符形式 功能描述     \\n 换行   \\t 横向跳格，跳到下一个tab输出区   \\v 竖向跳格   \\b 退格   \\r 回车   \\f 换页   \\\\ 字符\\   ' 字符'   \u0026quot; 字符\u0026quot;    请尝试运行以下代码，看程序输出是否和你预期的一样：\n display \u0026#34;\u0026#34;  display \u0026#34;1abcdefghijklmn\\n\u0026#34;  display \u0026#34;\\t\\\u0026#39;\\\u0026#34;2opqrstuvwxyz01|------\\\u0026#34;\\\u0026#39;\u0026#34;  display \u0026#34;3mmmmmmmmmmmmmm\\n\u0026#34; "},{"id":51,"href":"/docs/BDL/1.basic/3.composition_of_bdl/3.main-function/","title":"3.main函数","section":"第三章 最简单bdl程序的组成","content":"main函数\u0026ndash;从哪里开始，到哪里结束\r#\r\r先看以下代码\nmain  display sfmt(\u0026#34;hello world\u0026#34;) end main 代码解析\nmain ...end main这一段是在定义BDL程序的主函数。 函数是可以完成一定功能的子程序。main函数是BDL语言程序的起始执行点。\n每一个BDL程序必须有且仅有一个main函数，它是由程序员提供的。\n请读者思考一个问题:操作系统是如何开始运行调用一个程序的?\n这个问题的意思是操作系统怎么知道一个程序的入口点在哪里?所谓入口点，就是程序的第一条指令。 操作系统调入程序二进制代码到内存后，从哪条指令开始运行程序呢?\n一种办法是从文件第一行开始，一行一行往下执行，直到文件结束。 很多语言就是采用这种方式。 比如QBASIC语言。 这种方法的好处显而易见，人类是怎么阅读的，计算机就是怎么执行的。 但是缺点也很多，当有两个源文件的时候，从哪个文件开始呢? 另一种办法是和运行程序的启动者协商一个规定的入口名字，从这个名字开始进入。这种方法就是BDL语言采用的方法。\nmain函数就是BDL程序的入口点。无论整个工程有多少个C源文件，必须编写且只能编写一个main函数。程序就是从main的第一条语句开始执行，然后在main函数中，顺序执行其他语句，在这些语句中，调用其他函数，从而使整个程序运行起来。 main函数结束了，整个程序也就结束了。 由此可见，写BDL程序，就是写main函数。\n 简单地说明一下定义函数的语法。对函数的详细讲解请参考后续章节。\n 对于BDL语言，定义函数的语法规则如下：\nfunction 函数名称(参数1，参数2)\r函数体\rreturn 返回值\rend function 对比上面的语法规则可以看出，在main这一行中，main是函数名称。 函数可以是BDL语言系统提供的系统函数，也可以是用户自己编写的函数。 用户自己编写的函数，函数名字可以自行决定。\n例如：\nfuntion add(x,y)  define x,y integer  return x+y end function 看以上代码，add为函数名，函数名后有小括号对“()，括号里是传递给函数的参数。\n类似初、高中学习的代数里的函数y=f(x)一样，x就是参数，f是函数名称。 参数可以是一个，也可以是多个，也可以没有参数。\n每个参数都有一个数据类型。本例中的参数的数据类型是integer（整数）。 在function ... end funtion之间的的代码就是add函数实现的功能，被称做函数体。 在函数体里能做哪些事情，也是有规定的。在函数一章里再详细说明。\n"},{"id":52,"href":"/docs/BDL/1.basic/2.first_code/3.see-your-program/","title":"3.编译运行","section":"第二章 第一行代码","content":"编译运行-欣赏你的杰作\r#\r\r使用之前我们说的编译连接命令，开始编译连接。如果成功将不会有错误提示，如果失败请检查一些你的代码，可以对比上一篇中的代码。\n在czz/4gl目录下输入exe2 czzi001,将会显示以下内容。\n\r"},{"id":53,"href":"/docs/BDL/1.basic/1.before_all/3.what-is-language/","title":"3.语言概述","section":"第一章 踏上征程前的思想动员","content":"语言概述\r#\r\r提到语言这个词，人们自然想到的是英语、汉语这样的自然语言，因为语言是任何人交互交流信息不可缺少的工具。而今天，计算机遍布了我们生活每一个角落，除了任何人之前的交互交流之外，我们必须和计算机交流。 用什么样的方式和计算机做最直接的交流呢？ 人们自然想到的是最古老也同时也是最方便的方式\u0026ndash;语言。\n什么是语言\r#\r\r类比人类的语言，汉语言、英语言、法语言等，可以总结出语言有如下特点。\n 语言是用来交流沟通的 语言有独特的语法规则  什么是机器语言\r#\r\r计算机是一个忠实的仆人，时刻等候着主人的命令。 如何才能使计算机听话呢？ 当然是用计算机听得懂的语言去命令它了。 计算的大脑或者说心脏就是CPU，它控制着计算机的运作。 每种CPU都有自己的指令系统。 这个指令系统就是该CPU的机器语言。 机器语言是一组有0和1系列组成的指令码，这些指令码是由CPU制作厂商规定出来的，然后发布出来请程序员遵守。如下是某CPU指定系统的两条指令：\n1000000 加\r1001000 减\r 要让计算机完成相应的任务，就得用这样的语言去命令它。这样的命令不是一条两条，而是二十上百条。 由于不同型号计算机的指令系统即机器语言是不相同的，按照一种计算机的机器指令编制的程序，不能在另一种计算机上执行。\n用机器语言编写程序，编程人员首先要熟悉所用计算机的全部指令代码和代码的含义。\n在编写程序时，程序员得自己处理每条指令和每一数据存储分配得输入和输出，还得记住编程过程中每步所使用得工作单元处理处在何种状态，这是一件十分繁琐的工作，编写程序花费的时间往往是实际运行时间的几十倍或者几百倍。\n而且，编出的程序全是0和1的指令代码，直观性差，还容易出错。\n什么是汇编语言\r#\r\r在用机器语言编程的实践中，一批顽强而聪明的先行者发明了汇编语言\u0026ndash;一门人类可以比较轻松掌握编程语言。 只是这门语言计算机并不认识，人类还不能使用这门语言命令计算机做事情。\n所以有一类专门的程序，既认识机器语言，又认识汇编语言，而且还很聪明，知道怎么把汇编语言翻译成机器语言。于是，人类和机器又有了一种新的交流方式，而且任何可以轻松地编写程序了。\n 上文提到过，不同CPU有不同指令系统，从而有不同机器语言与其对应。所以程序员用汇编语言编写程序，都要记住是在什么CPU上编写的。 程序员不仅要考虑程序涉及思路，还要熟记计算机的内部结构这种编程的劳动强度依然很大。\n 面向过程的语言\r#\r\r汇编语言和机器语言都是面向机器的，机器不同，语言也不同。 既然有办法汇编语言翻译成机器语言，难道就不能把其它更人性化的语言翻译成机器语言？ 1954年，Fortran语言出现了，其后续出现了其它类似语言。这批语言是程序员摆脱了计算机硬件的桎梏，把主要精力放在了程序涉及上，不再关注底层的计算机硬件。 这类语言被称为高级语言。同样得高级语言要被计算机执行，也需要由一个翻译程序将其翻译成机器语言，也就是编译程序。\n这类高级语言解决问题的方法是分析出问题所需要的步骤，把程序看作是数据被加工的过程。 基于这类方法涉及的语言称为面向过程语言。C语言就是一种面向过程的程序设计语言。\n什么是BDL语言\r#\r\rBDL语言相对于C语言，抽象程序更高，更少的代码可以做更多的事情。 但同样的由于抽象程序高，占用资源也比较高，无法与C语言这样比较底层的语言灵活处理问题，为了解决这个问题，BDL中可以直接调用C语言程序。\n"},{"id":54,"href":"/docs/TIPS/","title":"BDL宝典","section":"Docs","content":"BDL 宝典\r#\r\r程序组成\r#\r\r4gl\u0026ndash;\u0026gt;42m\u0026ndash;\u0026gt;42r 4fd\u0026ndash;\u0026gt;per\u0026ndash;\u0026gt;42f\n代码组成\r#\r\r   组成部分 说明     关键字 由代码规定的单词，每个都有特殊作用   符号 由代码规定，在不同地方可能有不同含义   标识符 由用户定义，用于标识变量名、常量名、函数名和由type定义的自定义数据类型   字面值(字面常量) 1.2、100 是数字的字面值，\u0026ldquo;hello\u0026rdquo;、\u0026ldquo;world\u0026quot;是字符串的字面值   注释 注释为说明性的文字，不参与编译   分隔符号 空格、换行、分号、tab 都为分割符号    关键字\r#\r\rACCEPT\rACTION\rAND\rARRAY\rBEFORE\rBEGIN WORK\rBIGINT\rBLOB\rBOOLEAN\rBREAKPOINT\rBYTE\rCALL\rCANCEL\rCASE\rCHAR\rCLEAR\rCLIPPED\rCLOB\rCLOSE\rCOLUMN\rCOMMAND\rCOMMIT WORK\rCONNECT\rCONSTANT\rCONSTRUCT\rCONTINUE\rCURRENT\rCURRENT WINDOW\rDATABASE\rDATE\rDATETIME\rDECIMAL\rDEFINE\rDIALOG\rDISPLAY\rDISPLAY ARRAY\rDISPLAY BY NAME\rDYNAMIC\rEND\rERROR\rEXIT\rFALSE\rFLOAT\rFOREACH\rFOR\rFUNCTION\rGLOBAL\rGOTO\rIF\rIMPORT\rINPUT\rINT_FLAG\rINTEGER\rIS NULL\rLET\rLIKE\rLINENO\rLOCATE\rMATCHES\rMENU\rMESSAGE\rMOD\rMONEY\rNEXT FIELD\rNULL\rON\rOPEN\rOPTIONS\rOR\rPRINT\rPROGRAM\rPROMPT\rQUIT_FLAG\rRECORD\rRELEASE SAVEPOINT\rREPORT\rRETURN\rROLLBACK WORK\rRUN\rSAVEPOINT\rSCHEMA\rSCROLL\rSET CONNECTION\rSKIP\rSLEEP\rSMALLFLOAT\rSMALLINT\rSPACES\rSQLCA\rSTATUS\rSTEP\rSTRING\rSTYLE\rTEXT\rTHRU\rTIME\rTINYINT\rTODAY\rTRUE\rTRY\rTYPE\rUNBUFFERED\rUNITS\rUSING\rVALIDATE\rVARCHAR\rWHENEVER\rWHILE 普通关键字\r#\r\r块级关键字（含有 end 结尾）\r#\r\r预定义变量（已经定义的变量）\r#\r\r数据类型\r#\r\r复杂类型\r#\r\r开发流程\r#\r\r普通开发流程\r#\r\rCR 报表\r#\r\r接口\r#\r\r常用代码\r#\r\r字符串操作\r#\r\r获取字符串长度\r#\r\r define a string  define b varchar(100)  let a = \u0026#34;hello world!\u0026#34;  let b = a   -- 使用内置函数,接受一个string类型,如果是varchar/char会转化为string,返回字符串长度  display length(b)   -- string 类型还可以直接使用下面方法,没有参数,返回字符串长度.  display a.getLength() 拼接字符串\r#\r\r define a varchar(100)  define b integer  define c string  -- a 初始值为\u0026#34;\u0026#34;  -- 将多个字符串拼接到一起  let a = \u0026#34;hello\u0026#34;,\u0026#34;world\u0026#34;,\u0026#34;!\u0026#34;  -- a 现在为 \u0026#34;hello world!\u0026#34;  -- 自拼接  let a = a,\u0026#34; darcy\u0026#34;  -- a现在为 \u0026#34;hello world! darcy\u0026#34;  -- 循环自拼接  while b \u0026lt; 10  let a = a,\u0026#34;.\u0026#34;  let b = b + 1  end while  -- a 现在为 \u0026#34;hello world! darcy..........\u0026#34;   -- 以上为varchar/char/string三种字符类型变量都可以使用的拼接字符串方式。  -- string类型除了上述，还有自己独有的方法   let c = c.append(\u0026#34;hello\u0026#34;)  let c = c.append(\u0026#34;world!\u0026#34;)  -- c的结果为\u0026#34;hello world!\u0026#34; 获取子字符串\r#\r\r define a string  define b varchar(100)  let a = \u0026#34;hello world!\u0026#34;  let b = a   -- string 与varchar/char 类型在取字串时不同。   -- 获取子字符串，subString方法接受两个参数，第一个为字串开始位置，第二位子串的长度  let a = a.substring(2,5)  -- a的结果为\u0026#34;ello \u0026#34;   -- varchar/char类型获取字串，用中括号截取，第一个数字位开始位置，第二个数字位字串长度  let b = b[2,4]  -- b的结果为\u0026#34;ello\u0026#34; 获取单个字符\r#\r\r define a varchar(100)  define b string  let a = \u0026#34;hello world!\u0026#34;  let b = a   -- 获取单个字符，一种方式是使用取子串方式，每次取长度为1的字串即可。  display a[3,1]  display b.subString(4,1)  -- 以上结果都是\u0026#34;l\u0026#34;   -- 除了取字串，string 还有取字符的方法  -- 方法接受一个参数，即要取得字符串位置  display b.getCharAt(5)  -- 以上结果为\u0026#34;o\u0026#34; 替换字符\r#\r\r define a string  let a = \u0026#34;hello world! darcy\u0026#34;  -- 替换字符串并没有一个方法，但`tiptop gp`有lib函数可以调用。  -- 函数接受三个参数，第一个参数为要替换得基础字符串，第二个参数为要替换的旧字符串，第三个参数为要替换得新字符串  let a = cl_replace_str(a,\u0026#34;darcy\u0026#34;,\u0026#34;joven\u0026#34;)  -- a的结果为\u0026#34;hello world! joven\u0026#34; 判断是否含有字串\r#\r\r define a string  let a = \u0026#34;hello world! darcy\u0026#34;   -- 判断字串,只有string可以使用  -- 该方法接受两个参数,第一个为要判断得子串,第二个为从第几位开始判断  -- 返回得结果是这个子串在原字符串中的位置，如果没有返回-1  display a.getIndexOf(\u0026#34;darcy\u0026#34;,1)  -- 结果为14 string 其它方法\r#\r\r define a string  let a = \u0026#34;hello world! darcy \u0026#34;   -- 字母转为大写  let a = a.toUpperCase()  -- 字母转为小写  let a = a.toLowerCase()  -- 去掉最左空格  let a = a.trimLeft()  -- 去掉最右空格  let a = a.trimRight()  -- 去掉全部空格  let a = a.trim() 数组操作\r#\r\r数组定义\r#\r\r -- define 变量名 dynamic array of 数据类型  -- define 变量名 array[数组长度] of 数据类型  define a dynamic array of integer  define b array[10] of integer 取指定位置数组\r#\r\r define a dynamic array of integer  define b integer   let a[1] = 10  let a[2] = 20  let a[3] = 30  for b = 4 to 10  let a[b] = b * 10  end for 数组方法\r#\r\r define a dynamic array of integer  define b integer   for b= 1 to 10  let a[b] = b * 10  end for   -- 在末尾增加一个元素  call a.appendElement()   -- 清空数组  -- 定长数组,只清空值,变长数组长度变为0  call a.clear()   -- 删除指定位置元素  call a.deleteElement(2)   -- 获得数组长度  display a.getLength()   -- 数组中间插入一个元素  call a.insertElement(8) 循环和数组\r#\r\r define a dynamic array of integer  define i integer   -- 循环输入10个整数到数组中  for i = 1 to 10  prompt i,\u0026#34;.请输入一个整数:\u0026#34; for a[i]  end for   -- 显示数组中所有得值  for i = 1 to a.getLength()  display a[i]  end for "},{"id":55,"href":"/docs/BDL/2.medium/17.interface/5.menu/","title":"4.MENU","section":"第十七章 用户界面","content":"MENU\r#\r\rGenero BDL 所提供的 MENU 命令，是一种环状显示的功能表（Ring Menu）。以下介绍如何操作并设定想要的功能。\nMENU 命令\r#\r\rMENU语法类似下面这样:\nMENU [title] ATTRIBUTE ( control-attributes )   BEFORE MENU   COMMAND option [comment]  [ HELP help-number ]   COMMAND KEY ( key-name )  option [comment]  [ HELP help-number ]   ON ACTION action-name   ON IDLE idle-seconds  END MENU 说明：\n 在一个 MENU 中，可以定义 menu 的属性，STYLE 属性预设\u0026rsquo;default\u0026rsquo;。  属性包括:\n   属性 描述     STYLE = string 定义 menu 型态，值可以为\u0026rsquo;default\u0026rsquo;， \u0026lsquo;dialog\u0026rsquo; or \u0026lsquo;popup\u0026rsquo;   COMMENT = string 定义 menu show 出来的讯息   IMAGE = string 定义选单中的图示     BEFORE MENU 可以不写，若有一些特别的控管如隐藏某些menu 功能或参数控管是否进入某menu 功能时， 可在BEFORE MENU 来下一些menu-statemenu 来控管menu 部份。\n  功能表仅为让使用者选择要执行的功能用，其他功能则不在此指令支援的范围中，例如：支援完整的TABLE 或SCROLLGRID 显示（使用时，若存在超过荧幕可一次显示的资料量，则只能显示前几笔，卷轴是无效的）等。\n  示例：\nmain  define ls_flow_pic string  open window act_w with form \u0026#34;czz/42f/czzi001\u0026#34;  attribute(style = \u0026#34;tiptop.4st\u0026#34; )  menu \u0026#34;before menu test\u0026#34;   before menu  hide option \u0026#34;del\u0026#34; #隐藏del 功能  #show option \u0026#34;del\u0026#34; #显示del 功能  #：  on action add   on action del   on action quit  exit menu   on action modi   end menu  close form a1  close window act_w end main \rMENU-OPTION\r#\r\r在MENU中你可以定义多种的MENU-OPTION，每个MENU-OPTION 代表一个功能。\n当触发到这个option，就会运行option后的功能。\n  COMMAND option：定义MENU 功能名称及定义进入某功能快速键，透过COMMAND 指令清楚掌握USER ACTION。\n  COMMAND key：定义MENU 功能快速键，且不须show 在menu 上\n  database ds main  open window act_w with form \u0026#34;czz/42f/czzi001\u0026#34;   menu \u0026#34;\u0026#34;  command \u0026#34;a.add\u0026#34; #menu 功能名称\u0026#34;a.新增\u0026#34;，a 为快速键  message \u0026#34;a.add\u0026#34;   command \u0026#34;u.modi\u0026#34;  message \u0026#34;u.modi\u0026#34;   command \u0026#34;q.qry\u0026#34;  message \u0026#34;q.qry\u0026#34;   command key (control-a) # control-a 为快速键且  message \u0026#34;control-a\u0026#34; #此功能不show menu 上   command \u0026#34;exit\u0026#34;  close window act_w  exit program  end menu end main \rON ACTION：跟COMMAND 指令功能一样，不同是COMMAND 可以重复定义COMMAND KEY，执行时以最后定义为主，但是ON ACTION 不能重复定义，compiler 会产生错误，两者定义名称时都不分大小写  database ds main  open window act_w with form \u0026#34;czz/42f/czzi001\u0026#34;  menu \u0026#34;\u0026#34;  on action add  message \u0026#34;act_a\u0026#34;  on action modi  message \u0026#34;modi\u0026#34;  on action quit  exit program  end menu  close window act_w end main \rON IDLE：在menu 中主要来控管停留在menu 段的时间是否闲置太久，透过ON IDLE 指令时间一到，可执行系统指定的IDLE 处理程序（如执行强制中断程序或 显示违规警示等），以减少可执行权（license）被占用或系统资料被锁定等相关问题。  database ds main  define l_chr varchar(4)  open window act_w with form \u0026#34;czz/42f/czzi001\u0026#34;  menu \u0026#34;\u0026#34;  on action add  call act_a()  on idle 3 #闲置时间超过3 秒处理流程  prompt \u0026#34;idle 3 second，exit menu?(y/n) \u0026#34; for l_chr  if l_chr=\u0026#39;y\u0026#39; or l_chr=\u0026#39;y\u0026#39; then  close window act_w  exit program  else  continue menu  end if  end menu end main \rMESSAGE\r#\r\r在这一节中，你应该能看到很多地方调用了message语句，它的功能就是将后面的字符串显示在屏幕上，并且不会影响程序的执行。\n\rmessage不像on action 这类语法要以来menu块语句中。 它并不依赖于上下文，但使用也有一个前提，必须打开一个画面文件。 它像是一个display命令的GUI版本。\nattribute\r#\r\rmessage除了默认样式还支持一些字体颜色的设置。 如下：\n{ BLACK | BLUE | CYAN | GREEN\r| MAGENTA | RED | WHITE | YELLOW\r| BOLD | DIM | INVISIBLE | NORMAL\r| REVERSE | BLINK | UNDERLINE\r| STYLE = \u0026quot;style-name\u0026quot;\r}\r 具体用法如下：\nmessage \u0026#34;i\u0026#39;m red blod\u0026#34; ATTRIBUTE (RED BOLD) "},{"id":56,"href":"/docs/BDL/2.medium/17.interface/4.window-form/","title":"4.Window\u0026Form","section":"第十七章 用户界面","content":"Window \u0026amp; Form\r#\r\r在上一章节介绍如何编辑画面，但 WINDOWS 与 FORM 本身是无法执行的，它必须透过 Program 去启动它，以下介绍在程序中启动及显示 WINDOWS \u0026amp; FORM 的指令。\n本节用到画面档时\rczzi001.4fd，你也可以自己创建一个喜欢的样式。\nWINDOW\r#\r\rOPEN \u0026amp; CLOSE\r#\r\rdatabase ds -- 之后的代码默认都通过r.c2 编译，都必须指定数据库 main  open window czz_w with form \u0026#34;czz/42f/czzi001\u0026#34;  sleep 10  close window czz_w end main 如果你直接运行发现，并没有打开作业，请通过 debug 调试模式重新运行一下查看。\n注意\nBDL 中如果没有指定使用操作画面语句块，那么直接打开画面是看不见的。\n\r运行一下代码：\ndatabase ds -- 之后的代码默认都通过r.c2 编译，都必须指定数据库 main  open window czz_w with form \u0026#34;czz/42f/czzi001\u0026#34;  call cl_ui_init() -- 这lib函数为初始化画面，如果不调用会出现一个空窗口。  menu \u0026#34;\u0026#34;  on action test  message \u0026#34;test\u0026#34;  on action untest  message \u0026#34;untest\u0026#34;  on action close  exit menu  end menu  close window czz_w end main MENU 就是一个画面操作语句块，后面会讲到，它的功能就是生成一些按钮，tiptop gp 将这些按钮放置到了右侧。\n\r运行结果应该如上图，close未生成按钮的原因是，window 系统中右上角的关闭就对应了 BDL 中的on action close。你可以在 debug 调试模式中验证这一点，如果点击右上角的关闭，exit menu程序会立即运行到这一行。\nOPEN 除了直接打开一个 42f 文件外，还有其它可选的语法。\nOPEN WINDOW window-id [AT line, column ]  WITH [ FORM form-file | height ROWS, width COLUMNS ]  [ ATTRIBUTES ( window-attributes ) ]  window-id：定义这个 window name 名称。 AT line, column：表示让画面开启的起始坐标，仅限于 Console 上执行有效。 form-file：经过编译后的画面档文件名称(不含附档名)，之前可以指定放置路径。 height ROWS, width COLUMNS：实际画面档不存在时，可先指定画面占用行数及栏数，其他部份待 4GL 执行时再行动态设定。 ATTRIBUTES ( window-attributes )：可以加上属性设定。  ATTRIBUTE 属性\n   Attribute 系统 Default 说明     TEXT = string NULL 将 string 显示在视窗标题列   STYLE = string NULL 读取 string 的画面设定属性    CLEAR\r#\r\r在目前所显示的画面上，清除指栏位变量内容。\n有两种使用方式：\n CLEAR field-list  清除指定控件名的变量内容\nCLEAR FORM window-id  清除整个FORM 的所有控件变量内容\nCURRENT WINDOWS\r#\r\r如果一个BDL中打开了多个窗口，只有当前窗口时可以操作的，如果不想关闭当前窗口，又想操作其他窗口，可以使用CURRENT WINDOWS命令。\nCURRENT WINDOW IS *window-id*\n示例：\nmain  open window w1 with form \u0026#34;edit\u0026#34;  open window w2 with form \u0026#34;topmenu\u0026#34;  menu \u0026#34;change windows\u0026#34;  on action edit  current window is w1  call act1_a()  on action topmenu  current window is w2  on action exit  exit menu  end menu  close window w1  close window w2 end main 上述代码只作为示例，缺少文件，无法运行。\nFORM\r#\r\rFORM 在Genero BDL 中的定义是简单的WINDOW，它被定义为不需长时间出现在画面上，用在与使用者交谈些简单的问题上，它与WINDOW 功能相比，少了切换视窗的功能等。\nTIPTOP GP 多使用WINDOW。\nFORM 只有三个语法，且不存在可选的其它语法\n  OPEN FORM form-id FROM “file-name”\n  DISPLAY FORM form-id\n  CLOSE FORM form-id\n  上面czzi001画面档，改写未open form 如下：\ndatabase ds -- 之后的代码默认都通过r.c2 编译，都必须指定数据库 main  open form czz_w from \u0026#34;czz/42f/czzi001\u0026#34;  display form czz_w  menu \u0026#34;\u0026#34;  on action test  message \u0026#34;test\u0026#34;  on action untest  message \u0026#34;untest\u0026#34;  on action close  exit menu  end menu  close form czz_w end main "},{"id":57,"href":"/docs/BDL/2.medium/16.module/4.module/","title":"4.BDL中的模块","section":"第十六章 模块","content":"BDL中的模块\r#\r\rBDL源代码从编译主程序、子程序，链接主程序，过程中会产生多个文件。\n所以按照模块可以将BDL程序划分为不同的块，一个程序的执行往往依赖大量的模块。\n\r\r\r\rglobals\r#\r\r如果说不同文件之间的通过链接的形式，组成不同模组最终组成了一个可执行程序。\n那么globals就是使不同模块中共享变量不可缺少的关键字。\n我们已知的变量最大的作用域，也就是函数外，即全局变量。在本文件中所有函数都可以使用。但是随之我们编写程序复杂度增加，我们使用很多不同文件，不同的模块，这个时候即使是全局变量也无法在不同文件中使用。\nglobals就是解决这个问题的，在globals中定义的变量，在程序整个运行周期都是可用的，无论你是哪个文件、模块中的函数。\nglobals是一个块语句，它有对于的end globals结束语。只能定义在函数外。 它的用法是，在块中包裹变量或者自定义类型\u0026ndash;即define和type语句。\n使用方法有两种\n 在源代码中直接定义  globals  define g_cnt integer end globals main end main 定义一个globals文件，然后在源码中引入文件   文件czzi004.global  globals  define g_cnt integer end globals  文件czzi004.4gl  globals \u0026#34;./czzi004.global\u0026#34; main end main 第二种方式是我们常用的方式，这样不同文件只要引入同一个global文件即可，不需要每次修改globals变量，都修改所有文件。\n练习\r#\r\r观察分析azz/4gl/p_zz.4gl和lib/4gl/cl_null.4gl文件中globals的使用。\n"},{"id":58,"href":"/docs/BDL/2.medium/15.function_plus/4.practise/","title":"4.练习","section":"第十五章 函数进阶","content":"练习\r#\r\r生成一个长度为100的整数数组，并输出数组中可以被5整除的个数\r#\r\r 长度100的整数数组，每个元素都为随机数，大于0且小于1000的整数  提示\nutil.Math.rand(100)可以获取小于等于100的随机整数。\nimport util main  display util.Math.rand(100) end main \r\r生成随机数功能写为一个函数，且接受两个参数，生成数组的长度和随机数最大整数  生成一个长度为50的整数数组，并从小到大排序，排序后输出到屏幕\r#\r\r 随机数生成请参考上一题  "},{"id":59,"href":"/docs/BDL/2.medium/14.database/4.select-single-row/","title":"4.查询单笔资料","section":"第十四章 数据库使用","content":"查询单笔资料\r#\r\rBDL SQL\r#\r\r同插入一样，查询时BDL SQL也有特殊的语法，但仅可以查询单笔资料，如果查询结果包含多笔，程序报错退出。\ndefine l_ima01 like ima_file.ima01 define l_ima02 like ima_file.ima02 select ima01,ima02 into l_ima01,l_ima02 from ima_file where rownum = 1 在select关键之前from关键字之后，可以使用into关键字，后面可以指定查询保存到哪些变量。\n我们在定义变量类型时有使用过一下语法\ndefine l_ima record like ima_file.* 在查询时我们也可以将表中所有内容查询出来。\ndefine l_ima record like ima_file.* select * into l_ima.* from ima_file where rownum = 1 EXECUTE\r#\r\r除了BDL自带SQL语法，我们依然可以使用数据库的原生语法，和插入语法类型，我们需要将SQL放到字符串中。\ndefine l_sql string define l_ima record like ima_file.* let l_sql = \u0026#34;select * into l_ima.* from ima_file where rownum = ?\u0026#34; prepare ima_sel from l_sql execute ima_sel using 1 into l_ima.* 查询和插入的区别在于，execute最后可以使用into语法接收查询的结果。\nFETCH\r#\r\r以上两种方式都可以查询单笔数据，但限制有些大，每次查询结果只能有一笔。 在实际查询中，我们通常要查询多笔资料。\n为了应对多笔查询的场景，BDL提供了一个特殊的FETCH语法。可以灵活查询多笔SQL查询结果。 FETCH查询需要实现定义游标(cursor)，游标定义之后，在数据库中就确定了SQL的结果，之后通过FETCH查询，就不会重新查询一遍，只要在游标中抓取指定的那一笔即可。\n游标\r#\r\r游标定义有三种方式，效果都是相同的。\n 由prepare定义  let l_sql = \u0026#34;select * into l_ima.* from ima_file where rownum = ?\u0026#34; prepare ima_sel_p from l_sql declare ima_sel_cur cursor for ima_sel_p ima_sel_cur为游标的名称，为自定义的标识符\n由字符串定义  declare ima_sel_cur cursor from \u0026#34;select * into l_ima.* from ima_file where rownum = ?\u0026#34; 利用字符串定义，将cursor for 改为cursor from即可。\n由BDL SQL定义  declare ima_sel_cur cursor for select * into l_ima.* from ima_file where rownum = 1 由BDL SQL定义可以直接跟在cursor for即可。\ncursor在事务提交时将关闭，这时再使用会报错。如果cursor资料内容被修改，再使用cursor也会报错。\nOPEN CLOSE FREE\r#\r\r游标的状态有3中操作，OPEN、CLOSE、FREE。\n OPEN 开启游标，如果SQL含有占位符，使用using 将参数传入 CLOSE 关闭游标，关闭cursor，如果要使用需要再OPEN FREE 释放游标，再次使用时需要重新DECLARE  SCROLL / WITH HOLD\r#\r\rcursor的定义还有两个可选选项scroll with hold\ndeclare ima_sel_cur1 cursor with hold for select ima01 from ima_file where rownum =1 declare ima_sel_cur2 scroll cursor with hold for select ima01 from ima_file   with hold 关键字在cursor后添加，可以使cursor事务提交之后也不关闭\n  scroll 关键字，在cursor前增加，这个是由使用fetch 可以灵活去不同位置的资料。\n  scroll 和 with hold 可以同时使用\n  示例\r#\r\r 灵活取任意笔数  declare ima_sel_cur2 scroll cursor with hold for select ima01 from ima_file FETCH NEXT c1 into cust.* --取下一笔 FETCH PREVIOUS c1 into cust.* -- 取上一笔 FETCH FIRST c1 into cust.* -- 取第一笔 FETCH LAST c1 into cust.* -- 取最后一笔 FETCH ABSOLUTE 10 c1 into cust.* -- 取第10笔 "},{"id":60,"href":"/docs/BDL/2.medium/13.struct/4.record-in-array/","title":"4.结构体数组嵌套","section":"第十三章 结构体","content":"结构体数组嵌套\r#\r\r在上一章节例子中，我们使用student类型定义了两个变量zhangsan,lisi。 但是我们需要的变量不止两个，例如，我需要一个班上50个学生，是不是场景很熟悉？没错，变量。\n我们使用变量嵌套结构体，示例：\ntype student record  score record  math integer,  english integer  end record,  info record  height,weight decimal(10,2)  end record end record define students array[50] of student 数组中的结构体\r#\r\r入上面代码，结构体声明是一种自定义的数据类型，在数组\n结构体中的数组\r#\r\r"},{"id":61,"href":"/docs/BDL/2.medium/11.array/4.multi-dimensional/","title":"4.多维数组","section":"第十一章 数组-同一类型的多个元素的集合","content":"更高维的数组\r#\r\r在了解二位数字定义、初始化和引用之后，不难将概念引申到三维，思维，甚至是更高维数组，本章讨论更高维数组的使用方式。\n高维数组的定义和元素访问\r#\r\r细心的读者不难发现，如果数组是N维，就需要N个下标来访问数组中的元素，同样，在声明高维数组时，除了和一-维、二维数组声明一样要指定元素类型和数组名外，还要指定每一维的大小，以帮助编译器确定到底要分配多大的内存块。\n举例来说，要声明一个int型3维数组sz,大小为345,代码如下:\n define sz array[3,4,5] of integer 多维数组在内存中如何排列元素\r#\r\r维度决定了数组中元素的组织方式及访问元素所用的下标个数，但本质上讲，所有的数组在内存中都是一维线性的，所有元素都是连续排列的，中间没有间隔。\n以二维数组为例，内存中是先放第一行的元素，再放第二行的元素。下面给出了大小为3*4的二维数组A的排列顺序：\nA[1,1]-\u0026gt;A[1,2]-\u0026gt;A[1,3]-\u0026gt;A[1,4]-\u0026gt; A[2,1]-\u0026gt;A[2,2]-\u0026gt;A[2,3]-\u0026gt;A[2,4]-\u0026gt; A[3,1]-\u0026gt;A[3,2]-\u0026gt;A[3,3]-\u0026gt;A[3,4] 多维数组的存储方式与此类似，可以将下标看成是-一个计数器，像计数的万位、千位、百位、十位和个位一样，右边的下标(靠后的下标)是低位，每一位都在上下界间变化，变化的范围是1到声明时指定的下标值，当某一低位计数器超出范围时(达到声明时指定的下标值)，左边下标加1，同时该低位计数器及其右边的更低位计算器置1 (回到下界)。这样，最左边一维下标变化是最慢的，最右一维 下标变化最快。\n下面给出2*3*2的三维数组B中元素在内存中的排列顺序:\nB[1,1,1]-\u0026gt;B[1,1,2]-\u0026gt;\rB[1,2,1]-\u0026gt;B[1,2,2]-\u0026gt;\rB[1,3,1]-\u0026gt;B[1,3,2]-\u0026gt;\rB[2,1,1]-\u0026gt;B[2,1,2]-\u0026gt;\rB[2,2,1]-\u0026gt;B[2,2,2]-\u0026gt;\rB[2,3,1]-\u0026gt;B[2,3,2] "},{"id":62,"href":"/docs/BDL/2.medium/10.function/4.process-oriented/","title":"4.面向过程编程","section":"第十章 函数入门-写程序就是写函数","content":"面向过程的程序结构\r#\r\r在20世纪60年代计算机发展的初期，程序设计是少数聪明人的工具，程序员可以根据自己的喜好，像捏泥巴一样进行程序设计，注释几乎是一行没有，想到哪写到哪，大多数程序代码组织混乱，可以说只有设计者本人可以看懂，有的甚至设计者读起来也不知所以，常被称为“意大利面条式编程”。\n这种个人英雄主义的单打独斗在解决小规模问题时勉强可以，但程序规模的不断扩大，一大堆的问题凸显出来:程序质量低下，进度延误，预算严重超支，就是“软件危机”，给程序开发的前景蒙上了一层暗淡的色彩。\n结构化程序设计方法就是在这个背景下提出的，除了前面章节中讲过的3种控制结构:顺序、分支和循环外，结构化程序设计的另-一个关键概念是模块化设计。\n模块化\r#\r\r生活中常常接触到模块化的概念，模块化程序设计大致有点像小时候玩的积木游戏，用木块组合的方式很容易地就构筑起了“大厦”。模块化至少有两点好处: 一是封装，“积木块”是“基本砖块”的组合，对外是个整体，使用方便，二是可复用，“柱子”封装好后，既可以用在这个建筑上，又可以用在那个建筑上。程序设计也可以借鉴这一思想，用模块化的方法进行程序设计，函数正是模块化方法的体现。\n虽说语句是BDL语言的基本单位，但从程序设计总体把握上来看，将函数视为一个整体，大大降低了问题的复杂程度。在解决复杂问题时，首先考虑的是问题的概貌，而不是微小细节，这是人的思维和行动习惯，程序设计也是如此，先将问题分割成-一个个函数，每个函数实现特定的功能，确定函数之间的联系和依赖关系，这是从整体解决某个问题。其次才是考虑每个函数怎么写，算法流程怎么走这些问题，这就是“分而治之、逐步求精”的设计方法学。\n函数的调用过程\r#\r\rBDL语言是由函数组成的，本章前面以及介绍了函数的定义、声明和调用等基础只是，下面来看一下函数的调用过程，即不同函数是和配合的。如图：\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rflowchart TD\rsubgraph a[\"main\"]\re[\"函数1\"]--f[\"函数2\"]\rend\rsubgraph b[\"函数1\"]\ri[\"语句1\"]--g[\"函数3\"]\rg--h[\"语句2\"]\rend\rsubgraph c[\"函数2\"]\rj[\"...\"]\rend\rsubgraph d[\"函数3\"]\rk[\"...\"]\rend\re--\"call\"--b\rb--\"return\"--e\rf--\"call\"--c\rc--\"return\"--f\rg--\"call\"--d\rd--\"return\"--g\r一个入库一个出口\r#\r\r结构化程序设计主张使用顺序、选择、循环3种基本结构来嵌套连接成具有复杂层次的“结构化程序”，严格控制goto语句的使用。\n需要强调的一点是，对单个模块而言，只有一个人口，一个出口。这是一种从上到下的流程式方法，减少了模块间的相互联系，使模块可作为插件或积木使用，降低程序的复杂性，提高可靠性。\n封装和可重用\r#\r\r可作为插件或积木使用的模块具有很强的可重用性，完全可用在其他同类型的问题中，省却了将算法重写一遍的麻烦。对一些规模较大的商业软件公司来说，模块的积累是笔巨大的财富，到达一定的规模后，解决问题时要重新写的代码和模块很少，从库中挑选出需要的模块，拼装组合就形成了满足要求的程序。而且，如果在模块编制中注重算法的效率等因素，采用这种插件组合的方式可以很容易产生出高质量的软件产品。\n下面来看一下封装性。在模块化程序设计中，模块内部的结构，对其他模块来说是不重要的，以函数为例来说明，BDL语言中，函数可看成是一个封装体，将一系列相关的、实现某一功能的代码封装起来，并提供了一个使用方法(程序开发中常称接口)，通过该接口可以在程序的任何地方使用这些代码完成特定的功能，至于函数是如何编写的，可能并不是用户关心的重点，用户真正关心的是这个函数如何使用。这就意味着，函数内定义的变量等，外部是不能访问的，为此，引入“内聚”和“耦合”的概念。\n高内聚，低耦合\r#\r\r既然模块化设计有那么多的好处，那是不是可以不管三七二十-地把整个程序简单地分解成一个个程序段呢?答案是否定的，模块的划分有条准则，即“相对独立，功能单一”。也就是说，一个好的模块必须具有高度的独立性和相对较强的功能，这通常用“耦合度\u0026quot;、“内聚度”两个指标从不同侧面而加以度量。\n耦合度，是指模块之间相互依赖性大小的度量，耦合度越小，模块的相对独立性越大。内聚度，是指模块内各成分之间相互依赖性大小的度量，内聚度越大，模块各成分之间联系越紧密，其功能越强。\n在模块划分时应当做到“耦合度尽量小，内聚度尽量大”。\n"},{"id":63,"href":"/docs/BDL/1.basic/9.over_and_over_again/4.cycle-and-flow-control/","title":"4.流程转向控制语句","section":"第九章 循环结构--一遍又一遍","content":"流程转向控制语句\r#\r\r之前我们了解到BDL中除了判断语句，循环语句，还有大量的流程转向控制语句。\n他们是continue、exit、goto语句，本章节会一一讲述。\nexit\u0026ndash;跳出循环\r#\r\r如果把重复结构视为一层壳，那么exit的作用可说是“破壳而出”，当流程执行到循环结构中的break语句时，循环结构提前结束，程序转而执行循环结构之后的那条语句，用流程图来表示，如图所示。\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rflowchart TD\ra{\"?\"}--b{\"exit?\"}\rb--\"no\"--d[\"语句\"]\rb--\"yes\"--c[\"...\"]\rd--a\r图中，如果在循环体内部执行了exit语句，程序流程会直接从循环结构中跳出，转而执行循环结构后面的语句，这类似于电路中的“短路”。\n前面讲过，“如非故意为之，不要让循环成为死循环”，那这“故意为之”是怎么回事?如何“从死循环中跳出”，可用break语句实现，见示例代码：\n define i integer  display \u0026#34;\\n\u0026#34;  while 1  display \u0026#34;Hello\u0026#34;  let i = i + 1  if i \u0026gt; 5 then  exit while  end if  end while 尝试编译运行，你会发现，while 1看起来是个死循环，但是我们再循环结构中，增加了一个可以exit的机会。\ni每次循环都会+1，当i大于5时，就会运行到exit，退出循环。\n注意 当循环有多层时，exit只能剥一层“壳”，向外跳出一层。\r\rcontinue\u0026ndash;重来一次\r#\r\rexit语句时结果整个循环结构，而continue语句结束的只是当前一次循环，形象的说时“再来一次”，流程图如下：\nflowchart TD\ra{\"?\"}--b{\"continue?\"}\rb--\"yes\"--a\rb--\"no\"--c[\"语句\"]\rc--a\r比较和之前exit，很容易发现两者的不同，continue短路只是本次循环后的内容，不会跳出循环结构，所以，continue语句被称为循环继续语句。\n以下代码演示了continue语句的用法：\n define i integer  display \u0026#34;\u0026#34;  for i = 0 to 20  if i mod 3 != 0 then  continue for  end if  display sfmt(\u0026#34;%1能被3整除\u0026#34;,i)  end for 输出结果为：\n0能被3整除\r3能被3整除\r6能被3整除\r9能被3整除\r12能被3整除\r15能被3整除\r18能被3整除 代码解析\n代码使用的是for循环结构，如果控制变量i不能被3整除，调用continue语句结束本次循环，重新开始循环，否则，输出提示信息。\ngoto\u0026ndash;随心所欲\r#\r\rgoto是“go to”的缩写，称为自由转向语句，使用goto语句可将流程转到程序的任何地方。\n和goto相关的一个概念是“标号”，这相当于现实的地址，更形象点说是“门牌号”， 标号的基本定义形式为:\nlabel 标号名:\r语句 在程序其他地方使用“goto+标号名”的形式将流程转到标号定义处。\n很多程序员甚至权威人士都不赞成使用goto语句，认为它破坏了程序的良好结构，转来转去会让代码读起来像一团乱麻，加上已经证明：使用顺序、分支和循环结构这3种基本流程控制足以写出任意复杂度的算法一不管其有多复杂。\n在是否使用goto语句上，可谓见仁见智，相信读者也有自己的看法，不过，goto语句有 个特殊用法值得注意，前面说过，使用exit语句跳出循环结构时，只能剥一层壳，在循环嵌套时，如果想一次性从中跳出，可使用goto语句，见示例代码：\n define i integer  while 1  while 1  diplay \u0026#34;*\u0026#34;  let i = i +1  if i \u0026gt; 3 then  goto outside  end if  end while  end while  label outside: 代码解析\n上述代码用于在屏幕上输出4个星号，为了说明goto语句的用法，采用了两重循环结构嵌套，在内层中判断计数整型变量i的大小，当i\u0026gt;3条件成立时，程序从循环中跳出，到outside标号处。\n"},{"id":64,"href":"/docs/BDL/1.basic/8.condition/4.case/","title":"4.case--开关语句","section":"第八章 条件判断-分支结构","content":"case\u0026ndash;开关语句\r#\r\r用多分支if结构和if结构嵌套都可实现“多选1”,但带来的负面影响是程序的可读性差，面对一大堆的if和if else搅和在一起，很多读代码的人都会觉得头皮发麻，要耐心地去“脱壳\u0026quot;。 实际上，BDL语言还提供了另\u0026ndash;种更简洁的多分支结构，即case结构。\n一般形式\r#\r\rcase机构一般形式为:\ncase 表达式1  when 常量表达式1  语句1  when 常量表达式2  语句2  when 常量表达式3  语句3  ...  default  语句4 end case 语句执行时，首先对case后的表达式进行计算，将计算的结果逐个与when后的常量表达式进行比较，当表达式的值与某个常量表达式的值相等时，即执行该when后的对应的代码段，如果表达式的值与所有when后的常量均不相同时，则执行default后的语句。\ncase 的算法流程如下：\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rflowchart TD\ra[\"表达式计算\"]--b{\"常量表达式1\"}\rb--\"no\"--c{\"常量表达式2\"}\rc--\"no\"--d{\"常量表达式3\"}\rd--\"no\"--e{\"常量表达式n\"}\re--\"no\"--f[\"defalut:语句m+1\"]\rb--\"yes\"--g[\"语句1\"]\rc--\"yes\"--h[\"语句2\"]\rd--\"yes\"--i[\"语句3\"]\re--\"yes\"--j[\"语句m\"]\r来看一个具体的应用实例，由用户输入一个1到7之间的数字，程序自动输出对应星期几的英文形式，如输入1，程序输出Monday。如果用户输入的数字不在1到7之间，提示出错，如下:\n define index integer  prompt \u0026#34;请输入一个1到7之间的整数：\u0026#34; for index  display \u0026#34;\u0026#34;  case index  when 1  display \u0026#34;Monday\u0026#34;  when 2  display \u0026#34;Tuesday\u0026#34;  when 3  display \u0026#34;Wednesday\u0026#34;  when 4  display \u0026#34;Thursday\u0026#34;  when 5  display \u0026#34;Friday\u0026#34;  when 6  display \u0026#34;Saturday\u0026#34;  when 7  display \u0026#34;Sunday\u0026#34;  default  display \u0026#34;请检查输入是否正确\u0026#34;  end case 代码解析\n上述代码中，读者可以改变when子句的先后顺序，程序的执行结构不会受到影响。\n进阶\r#\r\rcase 语句除了when后面可以根常量，还有一种跟逻辑表达式的写法，见下面代码：\n define index integer  prompt \u0026#34;请输入一个1到7之间的整数：\u0026#34; for index  display \u0026#34;\u0026#34;  case  when index==1  display \u0026#34;Monday\u0026#34;  when index==2  display \u0026#34;Tuesday\u0026#34;  when index==3  display \u0026#34;Wednesday\u0026#34;  when index==4  display \u0026#34;Thursday\u0026#34;  when index==5  display \u0026#34;Friday\u0026#34;  when index==6  display \u0026#34;Saturday\u0026#34;  when index==7  display \u0026#34;Sunday\u0026#34;  default  display \u0026#34;请检查输入是否正确\u0026#34;  end case 请编译运行看运行结果是否一样。\n"},{"id":65,"href":"/docs/BDL/1.basic/6.operators_and_expressions/4.assignment-operator/","title":"4.赋值运算符","section":"第六章 运算符和表达式-程序基本构成","content":"赋值运算符和赋值表达式\r#\r\r赋值运算时BDL中常见运算，一般用来改变变量的值。 BDL中提供了赋值运算符号let =，和函数返回值赋值returning两种估值方式。\n赋值表达式\r#\r\r let = 赋值  之前我们已经多次使用let a = 1对变量进行赋值，我们可以看到使用这种方式赋值的方式，=左边是我们要赋值的变量，且只有一个。 =右边是我们要赋予的值。\nlet a = a + 1之前我们还是用过这样的方式进行求和，=右边作为一个整体计算结果之后，再赋值给=左边。\nreturning 函数返回值赋值  函数之后会详细讲解，我们现使用我们已经用过的sfmt()函数作为说明。\n运行以下代码：\ndatabase ds define a,b,c integer MAIN  define s string  call to_day() returning s  display s  sleep 1 --这里是暂停一秒的意思，防止时间太接近而无法区分  let s = to_day()  display s END MAIN  function to_day()  return current end function 我们可以看到以下内容，s的值被赋值了两次。\n2023-07-19 16:03:11.275 2023-07-19 16:03:12.276 这说明使用let s = 函数()和call 函数() returning s两种方式都可以赋值给s，那么为什么还要使用第二种方式呢。\n这是因为在BDL中允许返回多个值，当多个值返回时，就只能用returning进行赋值了。\n左值与程序实体\r#\r\r程序实体是内存中的一块可标识的区域，左值是左值表达式的简称，是指明一个程序实体的表达式。 判断一个表达式是否左值的方法是看其能否放在赋值号的左边。 能放在赋值号左边的表达式都是左值，它指明了一块内存区域，而赋值运算实质上是改变这一区域内容的操作。\n但应注意，能放在赋值号左边的表达式都是左值，但左值并非一定可以放在赋值号左边，const常量是左值，但不能将其放在赋值号左边，这是个例外。\n如“define a float;\u0026ldquo;声明了一个浮点型变量a，则a是左值，因为它指明了一个程序实体，可放在赋值号的左边，但表达式“a+3”和“a=1\u0026rdquo; 就不能放在赋值号的左边，不是左值。\n"},{"id":66,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/4.input/","title":"4.输入","section":"第五章 利用键盘、鼠标与程序交互","content":"输入\u0026ndash;键盘与鼠标的交互\r#\r\r之前的程序，我们都是在输出，输入的值，我们都是编写在程序中。\n但这让程序每次输出的结果都一样，如果我们要其它结果就要重新编写代码。\n为了解决上述问题，我们引入BDL语言可以支持的输入方式。\nPrompt\u0026ndash;初次接触用户界面\r#\r\r请运行一下代码，查看输出情况，运行前请确保打开GDC客户端\ndefine birth date prompt \u0026#34;请输入你的生日:\u0026#34; for birth display birth using \u0026#34;yyyy年mm月dd日\u0026#34; 是否出现了这个弹窗，如果未出现，请检查GDC安全性设置，调整为最低，且端口为6400。\n\r随便输入一点东西试试看，报错了！String to date conversion errr.。 字符串转日期格式失败，它可以帮我自动转为日期格式！而且会检查是否正确！\n\r我们尝试输入19900101或者900101。\n现在查看控制台，成功转为了日期！\n1990年01月01日 代码分析\nprompt \u0026quot;请输入你的生日:\u0026quot; for birth 这一行为我们做了不少事情，我们来分析一下\n 弹出一个新窗，且有一个可以输入的地方和确定取消按钮。 可入处有输入说明。 可输入的地方只能输入能转为日期的内容，否则无法确定并完成。 将输入的内容转为birth变量的数据类型。  仅一行代码，就可以做这么多事情，这就是一开始说的BDL抽象级别比较高。 将大量的常使用功能集成到一起，不需要我们为重复的事情编写代码。\n让我们试一试下面这些代码:\ndefine birth date define name varchar(6) define sex varchar(1) prompt \u0026#34;请输入你的生日:\u0026#34; for birth prompt \u0026#34;请输入你的姓名:\u0026#34; for name prompt \u0026#34;你是男生吗y/n:\u0026#34; for sex display sfmt(\u0026#34;\\n%1你好,你是否是男生(%2),你的生日是%3\u0026#34;,name,sex,birth using \u0026#34;yy/mm/dd\u0026#34;) 你会发现，prompt除了可以转换资料类型，还能够限制可以输入的字数。（一个中文汉字需要yi\\一个varchar(3)）\n练习\r#\r\r 编写一个程序，首先输入一个日期a，然后输入一个整数b，计算a经过这个b天后的日期是哪一天。计算后将结果在控制台打印。  "},{"id":67,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/4.variable/","title":"4.变量","section":"第四章 存储和获取数据","content":"变量\r#\r\r变量定义\r#\r\r变量定义，变量申明，都是同一个意思的两种翻译方法。\n在定义变量的时候，需要给这个变量-一个名字。有了名字之后才能使用这个变量。回顾曾经编写的BDL语言代码，可以发现这些代码中，凡是用双引号括起来的部分，都是字符串。 那些没有用引号括起来的单词，一部分是C语言提供的关键字，比如integer，string等， 还有一部分是BDL语言提供的符号，如=、+、-、()、{}等，这些单词和符号就是BDL语言的核心部分，编译器生来就认识它们。 另外没有使用双引号括起来的单词，如define a integer,其中的integer是关键字，a就是非BDL语言的关键字，对于编译器来说，它是不认识的。 要让编译器知道这个单词是什么意思，所以有了定义(define)。\n对于变量来说，变量的定义会使得编译器在变量符号表中新增一条记录。 这样编译器在后面如果读入了一个变量名，通过查询符号表，就知道是否声明过了。\n 一行可以定义多个变量  define a,b,c integer  一样也可以拆成两行  define a,  b,  c integer  每行也可以只定义一个变量  define a integer define b integer define c integer  变量定义的顺序可以打乱  define b integer define a integer define c integer  不同类型可以定义在同一个define中，但必须指定每个不同类型变量的数据类型  define a,  b integer  c varchar(10) 定义变量的意义\r#\r\rBDL为什么要规定要先定义变量呢？ 为什么要指定变量的名字和对应的数据类型呢？\n 建立变量符号表  通过声明变量，编译器可以建立变量符号表，如此一来，程序中用到了多少变量，每个变量的类型是什么，编译器非常清楚。如果使用了没有声明的变量，编译器在编译期间就可以发现，从而帮助程序员远离由于疏忽而将变量名写错的情况。下面演示了写错变量名后编译器编译时的提示信息。\ndefine a integer let a = 1 let b = a * 10 display b 编译提示变量未定义\nczzi001 .............. ../42m/czz_czzi001.4gl:5:5:5:5:error:(-4369) The symbol \u0026#39;b\u0026#39; does not represent a defined variable. ../42m/czz_czzi001.4gl:6:9:6:9:error:(-4369) The symbol \u0026#39;b\u0026#39; does not represent a defined variable. The compilation was not successful. Errors found: 2.  The file \u0026#39;../42m/czz_czzi001.err\u0026#39; has been written. 变量的数据类型指示系统分配多少内存空间  变量需要存储空间来存储。不同的数据类型占据不同的空间大小。在声明变量时需要指定变量的数据类型，因而可以准确地为变量分配确定大小的内存空间。 比如integer x,则分配4个字节的空间: float y，则y占用了8个字节的空间。\n变量  变量的数据类型指示了系统如何解释存储空间中的值。 读者已经明白，同样的数值，不同的类型将有不同的解释。 integer占 据4个字节，float也占据4个字节，在内存中同样也是存储的二进制数，并且这个二进制数也没有标志区分当前是integer型 还是float型。 如何区分?就是通过变量的数据类型来区分。 由于声明建立了变量符号表，所以系统知道变量该如何解释。\n 变量的数据类型确定了改变了的取值范围\n  不同的数据类型有不同的操作\n  例如：整数可以做除法，但字符串就不可以，编译时就报错\n标识符和关键字\r#\r\r在定义变量时，要高速编译器变量的名字。\n这个名字被称作标识符，简单地说，标识符就是一个名字，一个在某范围内唯一的名字， 通过这个名字，就能找到一个唯一与之对应的对象。 变量名，通过名字可以找到变量的值;符号常量名，通过名称可以找到符号常量代表的实际值:函数名，通过名字可以调用函数;数组名、类型名、文件名等都是一个标识符。 在很多时候，将标识符简称为ID,就是identifier的前两个字符的缩写。 标识符必须在某个范围内是唯一的，所谓某个范围内，在以后的章节会继续讲述。 正如在中国，身份证是一个人的ID，在全中国唯一，通过身份证ID就能找到一个具体对应的人。\nBDL语言规定，标识符只能由字母(26个小写字母和26个大写字母)、数字(0~ 9共10个数字)和下划线(_)3种字符组成。 并且标识符的第一个字符不能是数字，也就是只能是字母或者下划线。 BDL语言规定，标识符不区分大写字母和小写字母，即大写定义的标识符小写也可调用，反之亦然。\n合法标识符：\nsum,yes,no,success,student 不合法标识符：\n1year,#year,M.D,m-d BDL语言中的关键字保留不能用作标识符。\n变量标识符规则\r#\r\r  变量名一般小写\n  不同作用域以不同开头命名\n 在main函数之外定义的参数，一般以g_开头（global），例如g_index,g_age 在mian函数中，或者其它function函数中，以l_开头（local），例如：l_count 在function函数中定义的参数，一般以p_开头(parament),例如：p_name    对于多个词构成的标识符号，有多种可选写法，没有规则，但应该保持一致\n 驼峰 g_printEmployeePaychecks 下划线 g_print_employee_paychecks 帕斯卡 g_PrintEmployeePaychecks    变量在内存中占据的空间和变量的值\r#\r\r变量在内存中要占据-定的内存空间。 不同的变量类型，其空间大小占用也不同。前面章节已经说了很多次了。 现在的计算机，一般可以访问从0~ 64GB空间大小的内存，这64GB的内存空间，如何划分不同的区域，是非常有讲究的。\n计算机也一样，管理这么大的内存，也要分段管理。 就是说，从内存某地址开始到某地址结束，是操作系统使用的内存区域，普通程序想要使用那是难上加难。 在普通程序使用的内存区域里，又有很多类型的内存区域。 一般可以认为被分成了堆、栈、全局/静态存储区和常量存储区几个区域。 这些区域有各自的特点。 常量当然是放在了常量存储区里，所以保证了数据不被修改。 变量放在其他的几个区域。\n所谓“栈”，就是那些在需要的时候由系统分配，在不需要的时候自动清除的变量存储区。 里面的变量通常是局部变量、函数参数等。 注意是编译器在编译的时候分配的。在“栈”中分配内存，其内存大小在编译的时候就知道。\n所谓“堆”，就是那些由程序员调用系统内存分配函数分配的内存块。 编译器并不知道需要分配多大的内存，在程序运行的时候，根据需要来动态分配。这些分配的内存，完全由程序员管理，编译器不会释放。\nfunction foo()  define x integer  let x=3  display x end function 这是一个函数定义。 当该函数被调用时，系统根据函数的定义，将x在内存分配了一块4字节的内存。 x的生存周期时foo函数的生存周，当end fucntion结束后，函数就结束了。 这个时候，x在内存分配的预对于x来说已经无效了，x就不存在了，与x关联的内存空间可以被其它变量关联了。\n如果对以上叙述不理解的话，可暂时不用深究，有这个映像就可以了。\r\r读者要分清楚变量名和变量的值。let x=3 此时x是变量名，3是常量，通过赋值符“=”,使得变量x的值变为了3。 在BDL语言中，直接通过变量名，可以访问到变量的值。 display x 通过变量x， 得到了变量x的值了。\n变量赋初值\r#\r\r在程序设计中，经常要对一写变量预先设置初值。 所谓初值，就是分配内存后填入的第一个值。\nBDL语言中每个类型的初始值不同：\n integer 默认初始值为 0 float/decimal/string/varchar/char 初始值为null  "},{"id":68,"href":"/docs/BDL/1.basic/3.composition_of_bdl/4.call-function/","title":"4.函数调用","section":"第三章 最简单bdl程序的组成","content":"函数调用\r#\r\r看如下代码\n display sfmt(\u0026#34;\\nhello world\u0026#34;) 这一行我们调用了，一个sfmt的函数，小括号中内的双引号括起来的文字是sfmt函数的参数。\n该函数的功能就是把小括号的文字变为字符串，而display的功能就是将一个字符串功能打印出来。如果双引号内容改变，打印在控制台的内容也会改变。\n说明\n“\\n”在这里有特殊的含义，读者可以发现“\\n”并没有在屏幕中打印出来。\n“\\n”中的“\\”是转义字符，表示其后面紧跟的字符有专门的意思。“\\n” 表示将光标移到第二行第一格。也就是回车换行的意思。\n\r请读者注意函数定义和函数调用有如下的不同之处。\n 简单地说，所谓函数定义就是程序员编写程序代码，去实现函数的功能。  请读者注意，定义好的函数不-定会被调用。\n比如BDL语言提供的大批库函数都已经实现，但是程序员编写程序并不会用到库函数中的每一个函数，只是从中挑选有用的库函数来使用。\n函数调用就是调用已经编写好的函数，这些已经编写好的函数，可以是程序员自己编写的，叫做自定义函数；有的是BDL语言系统提供的函数，叫做库函数；有的是第三方提供的函数，叫做第三方库函数。BDL语言系统向程序员提供了非常丰富的库函数，以方便程序员使用。  本例中，sfmt函数被主函数main调用。sfmt函数的定义读者是看不见的，当然也看不见sfmt函数的代码，也就不清楚sfmt函数是如何实现的。\n"},{"id":69,"href":"/docs/BDL/1.basic/2.first_code/4.debug/","title":"4.调试排错","section":"第二章 第一行代码","content":"调试排错-查看代码如何一步步执行\r#\r\r程序员的主要工作之一是编写代码。 代码从无到有，需要逐个字符输入，工作量显然比较大。 但实际上，编码容易调试难。\n代码编写完毕后，程序员将会花费大量时间进行错误或者问题的排查、修改。 在电脑系统程序中，将隐藏着的一些未发现的缺陷、问题或者错误，成为bug。\ndebug\u0026ndash;由来\r#\r\r马克2号（Harvard Mark II）编制程序的格蕾丝·霍珀（Grace Hopper）是一位美国海军准将及计算机科学家，同时也是世界最早的一批程序设计师之一。有一天，她在调试设备时出现故障，拆开继电器后，发现有只飞蛾被夹扁在触点中间，从而“卡”住了机器的运行。于是，霍珀诙谐地把程序故障统称为“臭虫（BUG）”，把排除程序故障叫DEBUG，而这奇怪的“称呼”，竟成为后来计算机领域的专业行话。\n调试水平的高低，很大程度上显示出程序员能力的高低。 可以说，不会调试的程序员，是不会开发出好的软件的。\n幸好，无论tiptop gp还是t100都集成了调试工具，运行r.d2+ czzi001(t100为r.dg czzi001)。\n\r看，除了我们写的代码还多了一些代码，这些是tiptop gp自动加上的代码，是已经打包在编译连接中的代码，所以我们无法去除，这也是我们必须要写第一行database ds的原因，这些自动增加的代码中需要连接数据库。\n设置断点\r#\r\r断点是为了方便程序员在调试过程中观察程序内容个状态而专门设置的一种调试手段。\n也是在调试模式下运行程序的过程中，当程序语句运行到设置的断电时，暂停程序运行，但是程序当时的内容、寄存器、上下文环境等数据都被保存，并且代码中指示出当前停留在代码哪一行。然后程序可以不慌不忙地利用调试器查看程序内部状态。\n如何设置断点\r#\r\r在调试器中设置断点，先用鼠标或者方向键，将活动行移动到你需要设置断点的代码行上，然后按下F9键、点击Toggle按钮或者双击当前行即可设置断点，重复操作即可取消断点。\n调试运行\r#\r\r设置完断点之后，可以通过F5键(Run/Cont按钮)在调试器中启动程序。程序启动后，当运行到断点代码行后，程序暂停\n\r 此时程序暂停于当前设置的断点代码行处，可以发现一个小箭头标识在终端行左侧。这表示当前运行的代码行。 此时这个程序已经运行起来，不过出于暂停状态，可以看到控制台没有“Hello World”输出，这表示当前代码行还未运行。 按F10键（Step Over按钮），可单步运行。每按一次F8键，就运行一行代码，直到程序运行结束。如果不想单步运行，可以直接F5键接着运行到下一个断点。如果后续没有断点，会直接运行到程序结束。 运行结束，程序提示正常退出   "},{"id":70,"href":"/docs/BDL/1.basic/1.before_all/4.program-life-cycle/","title":"4.程序开发生命周期","section":"第一章 踏上征程前的思想动员","content":"程序开发生命周期\r#\r\r在windows 下，利用记事本这个软件，输入并编辑文件可以保存一个.txt后缀名的文件。类似的还有.xlsx。它们都可以通过记事本或者excle这类的软件打开，但本身是无法运行或者展现内容的。\n那么你有没有想过如何产生一个.exe可执行文件呢。\n聪明的你一定知道了。 是的，通过编写某种语言的源代码，编译成功通过后，在经过链接，成功后就可以产生一个可执行的文件。这就是所谓的程序。\n编写BDL源代码\r#\r\r关于环境的说明\n如果你是使用鼎捷系列软件，那么你需要新建一个程序代码，如何建立本书不会介绍。\n如果你要学习，可以见TIPTOP相关书籍，本书只介绍代码部分。\n由于t100与tiptop gp编译和链接代码也不同，所以本书以tiptop gp命令为主，如果你使用不同的系统，请自行替换为你系统的代码。\n例如：tiptop gp 使用r.l2 连接，t100使用r.l 连接。\n为什么不以底层fgllink写呢，因为license原因，有的环境可能不允许使用这类命令，所以不再赘述。\n\r编辑BDL源代码\r#\r\r编辑BDL源代码就是做如下工作：\n 逐个输入字符，如汉字、英文、标点符号或者其它可以用键盘输入的字符 通过插入、删除、移动、复制、粘贴等方法修改已经输入的字符 将输入修改完毕的所有字符保存到硬盘上  一篇由汉字、英文、标点符号或者其它可以用键盘输入的字符的内容被称作文本。 能够进行文字编辑的软件被称作编辑器。\n通俗的将，源代码就是程序员输入编写的符和BDL语言语法规则的文本。 如下片段就是一段源代码:\nmain  display smft(\u0026#34;Hello World!\u0026#34;) end main 扩展名用.4gl标识其为一个BDL源代码文件。源代码文件简称源文件。\n编辑器的功能很大程度上能够帮助程序员提高工作效率。只要能输入文字的文本编辑软件都可以作为源代码编辑器。 如记事本软件、字处理软件Word、vs code等。但是专业程序员一般采用专业源代码编辑器，如业界鼎鼎有名的编辑工具由VI/VIM、Emacs/XEmacs等。 一个好的源代码编辑器、要求具备关键字着色功能（可以使用不同颜色标识代码的不同部分）、优秀的代码跳转功能、代码自动补全功能等。\n编译BDL源代码\r#\r\r编译时BDL源代码翻译成用二进制指令标识的目标文件。 这里的目标文件与机器语言还有一段距离，并不是真正的机器语言，所以不能被计算机直接运行。\n编译过程由编译系统程序完成。编译程序简称为编译器。编译程序运行后，自动对源程序进行句法和语法检查，当发现错误是，就将错误的类型和所在位置显示出来，帮助修改程序中的错误。 用户可以继续利用编辑器对源程序进行修改。修改后，重新编译，直到编译通过为止。\n连接目标文件\r#\r\r多个源代码文件经过编译后产生了多个目标文件，此时还没有将其组合装备为一个可以运行的整体，因此计算机还是不能执行。\n连接过程是用连接程序将目标文件、第三方目标文件、BDL语言提供的运行时的一些函数装配为一个完成的可执行的目标程序。\n编译连接过程示例\r#\r\r有时候为了叙述方便，将编译和连接两个步骤，统一用编译一个词语代替，读者应该清楚实际经历了两步。\n  当源代码没有报错是，编译连接过程如下：   当编译时，不会产生目标文件，如下：    现在你可能还看不懂提示信息的含义，不用担心，后面章节会慢慢了解到。现在你只要关注如果源代码错误，会出现什么情况即可。\n 有时候编译通过了，但连接不一定通过。如下：   运行程序\r#\r\rBDL程序部署在服务器，在服务器端运行，需要本地电脑开启GDC客户端，并确定端口正确。\n运行的命令为exe2 czzi001,czzi001为程序编号。\n"},{"id":71,"href":"/docs/BDL/2.medium/16.module/5.preprocessor/","title":"5.预编译","section":"第十六章 模块","content":"预编译\r#\r\r预处理器指令通常用于简化源程序在不同的执行环境中的更改和编译。 源文件中的指令告知预处理器采取特定操作。 例如，预处理器可以替换文本中的标记，将其他文件的内容插入源文件，或通过移除几个部分的文本来取消一部分文件的编译。 在扩展宏之前，将识别并执行预处理器行。 因此，如果宏扩展到类似于预处理器命令的内容，该预处理器无法识别该内容。\n预编译指令在编译之后就不影响程序了，所以不会影响程序运行效能。\n预编译执行可以在程序任何位置写入。\n\u0026amp;include 文件引入\r#\r\r在编写函数中，我们有些重复的逻辑，又无法封装为一个函数的场景。为了避免重复代码，我们可以使用\u0026amp;include。\n\u0026amp;include并不是一个语法，而是一个预编译指令\u0026ndash;在编译时就生效。\n\u0026amp;include用法是，后续跟需要导入的源代码文件，当编译时，编译到\u0026amp;include指令行数时，将后面文件原样导入到当前文件中。所以此指令不会影响到运行时效率。在编译后此指令依据不存在了。\n当然这样也有缺点，我们在debug调试的时候，无法通过step in进入到\u0026amp;include中查看了，为排查错误带来了负向影响。\n\u0026amp;define 宏定义\r#\r\r宏定义的时将任意一个东西替换为宏定义内容，宏定义并不是定义常量，而是将定义的内容原样替换。\n\u0026amp;define MAX_TEST 12 \u0026amp;define HW \u0026#34;Hello world\u0026#34;  MAIN  DEFINE i INTEGER  FOR i=1 TO MAX_TEST  DISPLAY HW  END FOR END MAIN 你甚至可以定义\u0026amp;define mian main 这样你代码中所有的mian都会替换为main。而替换后的main可以正常使用。\n\u0026amp;define mian main mian  display \u0026#34;123\u0026#34; end main 字符串替换符号#\r#\r\r在宏定义中可以使用#，类似参数传递，会将内容转化为字符串\n\u0026amp;define disp(x) DISPLAY #x disp(abcdef) 如以上代码将输出abcdef\n标记粘贴运算 ##\r#\r\r在宏定义中使用##可以将两个标记合并。\n\u0026amp;define disp(x) DISPLAY ok##x main  define ok34 string  let ok34 =\u0026#34;ok is ok !\u0026#34;  disp(34) end main 已定义的宏定义\r#\r\r LINE  程序运行的当前行\n FILE  程序运行的文件，相对目录\n以上代码输出结果为ok is ok !\n条件编译\r#\r\r利用\u0026amp;ifdef/\u0026amp;ifndef可以在编译时，灵活选择是否编译哪些代码。\n在不同数据库时经常使用到，其中identifier是定义好的宏定义标记。\n\u0026amp;ifdef/\u0026amp;ifndef identifier ... [\u0026amp;else ...] \u0026amp;endif \u0026amp;define IS_DEFINED \u0026amp;ifdef IS_DEFINED DISPLAY \u0026#34;The macro is defined\u0026#34; \u0026amp;endif 如上带出输出The macro is defined\n"},{"id":72,"href":"/docs/BDL/2.medium/14.database/5.select-rows/","title":"5.多笔查询","section":"第十四章 数据库使用","content":"多笔查询\r#\r\r在上一节中我们学会了多种方式查询数据中数据，且即使多条结果，也能够灵活查询。\n这节我们将重点介绍多笔查询的注意点，和进阶查询语法FOREACH。\nFETCH\u0026ndash;进行多笔查询\r#\r\r在上一节中我们用FETCH可以查询一条数据，也可以查询多比数据。\n现在我们假设有一个需求，查询数据中ima_file中字段ima01以E开头的所以资料。并将查询的结果保存到一个数组中。\n让我们利用上一节的FETCH来完成上述需求。\ndefine l_ima dynamic array of record like ima_file.* define l_cnt,l_i integer define l_sql string  -- 获取查询结果的资料总笔数 let l_sql = \u0026#34;select count(*) from ima_file where ima01 like ? \u0026#34; prepare ima_cnt from l_sql execute ima_cnt into l_cnt using \u0026#34;E%\u0026#34;  -- let l_sql = \u0026#34;select * from ima_file where ima01 like ? \u0026#34; declare ima_sel cursor from l_sql  open ima_sel using \u0026#34;E%\u0026#34; for l_i = 1 to l_cnt  fetch absolute l_i ima_sel into l_ima[l_i].*  -- 有任何错误退出，并提示  if sqlca.sqlcode then  message sqlca.sqlcode  exit for  end if end for 我们使用fetch能够完成上述需求，但查询多笔资料时，我们需要提前知道查询结果的总笔数，否则在查询超过笔数的资料时，会报错并退出程序。\n上面代码我们使用了大量的代码，来避免查询时因为笔数而导致报错。实际上我们还有另一个语法专门用来只查询多笔资料。\u0026ndash;FOREACH\nFOREACH\u0026ndash;多笔资料查询语法\r#\r\rFOREACH语法专门用来查询多笔资料，它的语法如下：\nforeach cusor1 (using para1,...) into ...  ... end foreach 它是一个块语法，类似FOR循环。它的开始类似于fetch语句，不过它还可以接受一个可选的using参数。\n在foreach和end foreach之间，你可运行任何你想要运行的语句，你也可以任何语句都不写。\n我们将之前需求，用foreach语法改写：\ndefine l_ima dynamic array of record like ima_file.* define l_sql string define l_cnt integer  let l_sql = \u0026#34;select * from ima_file where ima01 like ?\u0026#34; declare ima_sel cursor from l_sql  let l_cnt = 1 foreach ima_sel using \u0026#34;E%\u0026#34; into l_ima[l_cnt].*  if sqlca.sqlcode then  message sqlca.sqlcode  exit foreach  end if  let l_cnt = l_cnt + 1 end foreach 上面代码比起FETCH语法减少了不少长度和变量的使用，SQL语句也减少了一个。\n在进行查询结果的每笔资料都需要的场景，我们建议是直接使用FOREACH语句。\n如果你的查询可能并不是每笔资料都需要，例如：你只想要看第一笔，然后调到最后一笔，或者从最后一笔向前看几笔。这种场景一般使用FETCH语法。\n"},{"id":73,"href":"/docs/BDL/2.medium/11.array/5.practice/","title":"5.练习","section":"第十一章 数组-同一类型的多个元素的集合","content":"练习\r#\r\r定义一个字符串数组，并输出每个字符串字符对应ASCII的值\r#\r\r字符串数组的值分别为\u0026quot;A\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;d\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;F\u0026quot;,\u0026quot;G\u0026quot;\n写出下列代码输出结果\r#\r\r define i,j integer  define a array[4] of integer  let a[1]=1 let a[2]=2 let a[3]=3 let a[4] =4  for i = 1 to 4  for k = 1 to i  let a[i] = a[j] - a[i]  end for  end for  for i = 1 to 4  display sfmt(\u0026#34;%1\u0026#34;,a[i])  end for "},{"id":74,"href":"/docs/BDL/2.medium/10.function/5.practice/","title":"5.练习","section":"第十章 函数入门-写程序就是写函数","content":"联系\r#\r\r自定义一个函数，计算你的存款利率。\r#\r\r例如输入10000块钱，定期存款3个月，那么3个月后你拥有多少钱？\n 假设月利息3.1%\n "},{"id":75,"href":"/docs/BDL/1.basic/9.over_and_over_again/5.practice/","title":"5.练习","section":"第九章 循环结构--一遍又一遍","content":"练习\r#\r\r以下代码输出结果是什么\r#\r\r define i,j integer  let i = 1 let j = 3  while j\u0026lt;5 or i\u0026gt;3  let i = i + 1  let j = j + 1  display \u0026#34;*\u0026#34;  end while 根据以下代码，写出变量a和b的值\r#\r\r define a,b integer  while a \u0026gt; 0  let b = b + 1  let a = a - 2  end while  display sfmt(\u0026#34;\\na=%1,b=%2\u0026#34;,a,b) 已以下这种格式控制台打印99乘法表\r#\r\r1*1=1\r1*2=2 2*2=4\r1*3=3 2*3=6 3*3 =9\r...\r1*8=8 2*8=16 3*8=24 ... 8*8=64\r1*9=9 2*9=18 3*9=27 4*9=36 ... 9*9=81 "},{"id":76,"href":"/docs/BDL/1.basic/8.condition/5.practice/","title":"5.练习","section":"第八章 条件判断-分支结构","content":"练习\r#\r\r#\r\r"},{"id":77,"href":"/docs/BDL/1.basic/6.operators_and_expressions/5.type-conversion/","title":"5.类型转换","section":"第六章 运算符和表达式-程序基本构成","content":"类型转换\r#\r\r前面章节中大家已经廖家，整数和浮点数在计算机中表示方法不同，占据的内存空间大小也有所不同。\n如果某下时候，需要将一个integer类型数据存储到decimal类型变量中。此时就需要进行转换。这种不同类型的数据进行转换就称作类型转换。\n自动转换\r#\r\rBDL中为了使编程简单，几乎所有数据类型都可以自动转换。 例如你可以写这种代码\n define a integer  let a = \u0026#34;12345.23\u0026#34; 字符串将自动转为整数12345，同样，整数也会自动转为字符串。\n 不过要注意之前我们说using的时候，数值类型转字符串会自动补空格。\n 但是如果我们要是一个无法理解的内容，会如何自动转换呢？\n define a integer  let a = \u0026#34;你好\u0026#34; 如果你在debug中查看会发现a的值会变为null，如果非法值转换，所有变量都会变为null，这将丢失之前变量的值!\n哪些情况会自动转换呢\r#\r\r 赋值  无论是let还是returning都会自动转换为目的变量类型\n传参  参数部分后续会详细讲，sfmt(\u0026quot;%1\u0026quot;,1)这个函数中\u0026quot;%1和1就叫做参数，1会自动转为字符串。\nSQL语句  select ima01 from ima_file where ima01 = 2234 SQL语句后续会详细讲，这里先知道有印象就好\n字符串拼接  字符串可以用两种方式凭借,和||，这两种方式都会自动转为字符串\n"},{"id":78,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/5.practice/","title":"5.练习","section":"第五章 利用键盘、鼠标与程序交互","content":"练习\r#\r\r 输出一下样式的数据   +------------------+-----+\r| 姓名| 年纪|\r+------------------+-----+\r| 小| 10|\r| 小蜜蜂| 9|\r| 小明| 8|\r| 小刚| 12|\r| 小红| 24|\r+------------------+-----+ 输入身份证号，输出身份证号的后4位。  "},{"id":79,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/5.practice/","title":"5.练习","section":"第四章 存储和获取数据","content":"练习-几个与变量相关的经典算法\r#\r\r几乎每一个程序 都必须使用到变量，因为程序就是处理数据的，而数据必须存储在变量中。 本节仅举几个简单的变量使用的例子。 这些例子都是一些经 典的做法，请读者深刻理解并记住。\n累加和累乘\r#\r\r所谓累加，就是将一系列的数字分别相加，最后得到一个结果。 如计算1+2+3+4+5：\n define x integer  let x = x + 1  let x = x + 2  let x = x + 3  let x = x + 4  let x = x + 5  display sfmt(\u0026#34;\\n1+2+3+4+5=%1\u0026#34;,x) 编译运行，结果为：\n1+2+3+4+5=15 代码解析\n不要认为这道算术题如此简单，让计算机来计算是大材小用。 读者要知道，通过一些简单的算术计算，可以理解编程中的一些基本技巧，为今后的真正开发软件打基础。\n这些简单的数学题，是在锻炼读者的编程能力。\ndefine x integer 定义了x为整型，整型的默认初始值为0。\n重点来关注:\nlet x = x + 1 这行代码就使用到了一个非常经典的累加算法。 这行代码是一个赋值语句。就是将赋值号“=”右边计算后所得的值，赋给左边的变量。再重申一次，这里的等号“=”是BDL语言中的赋值号，不是数学里表示相等的等号。\n该语句的运算过程是:\n 先计算x+1的值，计算得到数值1。 将x+1的值(也就是1)赋给变量x。变量x现在的值是1。  来仔细分析这个过程。\n在运行该语句之前，变量x的值是0。这个是赋的初值。\n计算x+1的步骤如下:\n 从内存中取得变量x的值，得到0。 CPU计算0+1,得到1。  然后将1赋值给变量x。此时变量x的值变为1。\nlet x = x + 2 同样的，这也是一个累加，取得变量x的值1，相加后赋给x，x的值是3。\n这样一直累加下去，最后得到1+2+3+4+5的值为15。 通过类似let x = x + e，就将一系列数字统统累加起来。 就像一个篮子，接受了所有丢进去的东西。\n累乘和累加类似，如计算1x2x3x4x5。如下：\n define x integer  let x = 1  let x = x * 1  let x = x * 2  let x = x * 3  let x = x * 4  let x = x * 5  display sfmt(\u0026#34;\\n1x2x3x4x5=%1\u0026#34;,x) 编译运行结果如下：\n1x2x3x4x5=120 代码解析\n如果对累加理解的话，这里就不需要赘述了。 需要注意的是，累乘初始值就不能从0开始了。\n交换两个变量的值\r#\r\r假设有两个变量，x=10， y=3， 现在要求使得x=3, y=10， 该如何交换两个变量的值呢?这也是非常经典的交换算法。这些算法都是今后进行更深的算法学习的基础。 显然这里需要使用第三个变量来临时保存数值。\n如图所示， 引入第三个变量z。\n\rmermaid.initialize({\r\"theme\": \"neutral\"\r})\rgraph TD;\rsubgraph x\rX[10]\rend\rsubgraph y\rY[3]\rend\rsubgraph z\rZ[0]\rend\r graph TD;\rsubgraph x\rX[10]\rend\rsubgraph y\rY[3]\rend\rsubgraph z\rZ[10]\rend\rX--Z\r graph TD;\rsubgraph x\rX[3]\rend\rsubgraph y\rY[3]\rend\rsubgraph z\rZ[10]\rend\ry--x\r graph TD;\rsubgraph x\rX[3]\rend\rsubgraph y\rY[10]\rend\rsubgraph z\rZ[10]\rend\rz--y\r 为初始转台，x=10，y=3 ，z不重要假设为0. 将x的值复制到z中，这样一来，x的值就可以放心修改。已经已经有一个备份了。 将y赋值给x，此时x已经得到y的值了。 而y可以从z中得到x的值。 4个步骤之后，x和y的值交换。 用完之后z也不需要了。  define x,y,z integer  let x = 10  let y = 3  display sfmt(\u0026#34;\\nx=%1,y=%1\u0026#34;,x,y)  let z = x  let x = y  let y = z  display sfmt(\u0026#34;\\nx=%1,y=%1\u0026#34;,x,y) 编译后运行结果如下：\nx=10,y=3\rx=3,y=10 代码解析\n最重要的交换值得几行代码，可以仔细对照代码因为在日常计算中交换数据经常出现，请务必掌握。\n练习题\r#\r\r计算100+102+104+106+108+110得累加值\r#\r\r已知一个原得半径是3.0，请输出圆的面积\r#\r\r 圆周率，请取7位小数\n "},{"id":80,"href":"/docs/BDL/1.basic/3.composition_of_bdl/5.count-1+1/","title":"5.计算1+1","section":"第三章 最简单bdl程序的组成","content":"计算1+1\u0026ndash;小有作为\r#\r\r以下代码实现了计算1+1的值。\ndatabse ds main  define a,b integer --定义a,b 为整型  define y integer --定义y为整型   let a = 1 --将变量a赋值为1，此时a的值为1  let b = 1 --将变量b赋值为1，此时b的值为1  let y = a + b --将a，b的值分别取出来，计算结果后，赋值给变量y  display sfmt(\u0026#34;\\na+b=%1\u0026#34;,y) --将y的值打印出来 end main 编译运行后，程序结果如下a+b=2\n代码解析\n 和之前代码一样，包含了database ds，同样也只有一个main函数。这是BDL语言规定，必须编写main函数。 define a,b integer定义a，b两个整形变量 define y integer定义y整形变量 空行用于分隔变量声明部分和接下来的函数实现部分。主要是逻辑分隔，利于程序员阅读代码，对编译器来说并无意义。 let a=1 给变量a赋值1，此时a的值为1,let是BDL的规定，赋值时必须使用。 let b=1 给变量b赋值1，此时b的值为1 let y = a + b 将a，b的值分别取出来，计算结果后，赋值给变量y display sfmt(\u0026quot;\\na+b=%1\u0026quot;,y),将y的值打印出来。这个sfmt和以前代码中的用法不同，简单说明下，更详细的解释参见后续章节。 双引号中的“\\n”，时回车换行。 “a+b=”原样输出。 “%1”中的%是格式化的起始字符，只在sfmt函数中这样用，意思是将y在这个位置显示出来。所以最后的输出是：  a+b=2 "},{"id":81,"href":"/docs/BDL/1.basic/1.before_all/5.write-your-fisrt-program/","title":"5.开始你的第一个程序","section":"第一章 踏上征程前的思想动员","content":"开始你的第一个程序\r#\r\r 使用你自己的编辑器，写一个输出\u0026quot;Hello World\u0026quot;的程序。  display \u0026#34;Hello World\u0026#34; 将你写的程序上传到服务器，并进行编译等一系列操作后，运行并测试是否能输出\u0026quot;Hello World\u0026quot;  "},{"id":82,"href":"/docs/BDL/2.medium/17.interface/6.display/","title":"6.DISPLAY","section":"第十七章 用户界面","content":"DISPLAY\r#\r\r在之前终端执行程序时，我们一直使用DISPLAY讲字符串显示到终端。 在程序升级到GUI版本后，我们不需要再回去看终端了，DISPLAY有了新的用法。\n注意\n因为BDL中，表格和非表格的控件方式有明显区别，所以讲非表格控件称为表单,表格称为表格。这并不是通用的定义，仅为了在本教程中方便区分两种。\n 表格 表单  \rDISPLAY 表单\r#\r\r\r\r4fd文件\ndatabase ds main  define sr record  FFLabel1 varchar(40),  ComboBox1 varchar(40),  DateEdit1 date,  Edit1 varchar(40),  CheckBox1 varchar(40)  end record  open window act_w with form \u0026#34;czz/42f/czzi001\u0026#34;   menu \u0026#39;\u0026#39;  on action quit  exit menu  on action setvalue  let sr.FFLabel1 = \u0026#39;FFLabel1 \u0026#39;  let sr.ComboBox1 = \u0026#39;Item2\u0026#39;  let sr.DateEdit1 = today  let sr.Edit1 = \u0026#39;Edit1\u0026#39;  let sr.CheckBox1 = \u0026#39;1\u0026#39;  on action dispall  display by name sr.*   on action displayedit  display sr.DateEdit1 to DateEdit1  display \u0026#34;OK\u0026#34; to Edit1 ATTRIBUTE (BOLD)   on action displaycombo  display by name sr.ComboBox1   on action clear  clear form  end menu  close window act_w end main 运行尝试一下每个按钮功能 在上述代码中，我们可以看到display显示到GUI表单中有两种用法。\n  display to\ndisplay 值1,值2,\u0026hellip; to 控件名1,控件名2,\u0026hellip;\n  能将任何值直接显示到指定的控件上\n display by name\ndisplay by name 值1,值2,\u0026hellip; display by name 结构体变量.*\n  这种方式并没有指定控件名，所以你的变量名必须和控件名一样，否则不会显示。\n如果你的变量是结构体，那么成员名必须和控件名一样。且如果结构体所有变量都要显示到控件上，那么可以简写为结构体变量.*。\nDISPLAY 表格\r#\r\r\r\r4fd文件\ndatabase ds main  define list dynamic array of record  Edit1 varchar(40),  Edit2 varchar(40),  Edit3 date,  Edit4 varchar(40)  end record  open window act_w with form \u0026#34;czz/42f/czzi001\u0026#34;   let list[1].Edit1 = \u0026#39;row1.edit1\u0026#39;  let list[1].Edit2 = \u0026#39;row1.edit2\u0026#39;  let list[1].Edit3 = today  let list[1].Edit4 = \u0026#39;1\u0026#39;   let list[2].Edit1 = \u0026#39;row2.edit1\u0026#39;  let list[2].Edit2 = \u0026#39;row2.edit2\u0026#39;  let list[2].Edit3 = today  let list[2].Edit4 = \u0026#39;0\u0026#39;   let list[3].Edit1 = \u0026#39;row3.edit1\u0026#39;  let list[3].Edit2 = \u0026#39;row3.edit2\u0026#39;  let list[3].Edit3 = today  let list[3].Edit4 = \u0026#39;1\u0026#39;   display array list to Record1.*   before display   on action quit  exit display   on action clear  clear form   on action edit1  let list[1].Edit1 = \u0026#39;edit1\u0026#39;   on action edit2  let list[1].Edit1 = \u0026#39;edit2\u0026#39;   end display   close window act_w end main \rdisplay array是一个语法块，除了将一个数字显示到表格上，还可以生成按钮功能。\ndisplay array中的变量必须是一个结构体数组，且结构体数组成员的变量的名称、顺序必须要和4fd中的screen record一致。当然变量的类型也需要一样，但是有些类型可以自动转换。\n触发语句\r#\r\rdisplay array 还支持大部分的MENU功能，上面代码中就使用了 on action 功能。在有表格的场景，display array一般代替menu。\n BEFORE DISPLAY 运行一次 AFTER DISPLAY 运行一次 BEFORE ROW 到新的一行时触发 AFTER ROW 离开当前行触发 ON IDLE idle-seconds 超时触发 ON ACTION action-name 按钮触发 ON FILL BUFFER 缓存化学 ON APPEND 插入时触发 ON INSERT 新增时触发 ON UPDATE 更新时触发 ON DELETE 删除时触发 ON EXPAND 树状图展开触发 ON COLLAPSE 树状图关闭触发 ON DRAG_START ( dnd-object ) 拖拽时才可用 ON DRAG_FINISH ( dnd-object ) 拖拽时才可用 ON DRAG_ENTER ( dnd-object ) 拖拽时才可用 ON DRAG_OVER ( dnd-object ) 拖拽时才可用 ON DROP ( dnd-object ) 拖拽时才可用 ON KEY ( key-name [,\u0026hellip;] )  \r看起来可用的语法有很多个，单实际上，很简单，你需要的时候拿来用即可。 可以把DISPLAY ARRAY看为一个转盘路，这些触发性的语法，是在转盘路之中的红灯，你遇到红灯需要花费时间将这些触发语法下面的语句运行完成，再继续上路。\n退出display\r#\r\rDISPLAY ARRAY就是进入转盘路的开始，而exit display和accept display就是退出转盘路的出口。 在上面程序中除了自己定义的按钮还额外多了一个OK和一个Cancel按钮，这两个按钮分别对应就是这两种退出方式。\n OK 确认 自动运行 accept display 内置的变量int_flag赋值为0 Cancel 取消 自动运行 exit display 内置的变量int_flag赋值为1 注意\nOK、Cancel还分别对应了ON ACTION accept和ON ACTION Cancel。如果你要写上着两个action,exit display和accept display就不会自动运行了，你可以自己写上或者运行其它逻辑也可以。\n\r  ATTRIBUTES\r#\r\r和基础DISPLAY、DISPLAY TO 语法一样，DISPLAY ARRAY一样支持ATTRIBUTES属性。\nDISPLAY ARRAY g_ima to s_ima.* ATTRIBUTES(BLOD)  ... END DISPLAY 除了字体样式，在DISPLAY ARRAY中还支持更多配置参数\n{ ACCEPT [ = boolean ] -- 确认按钮 | CANCEL [ = boolean ] -- 取消按钮 | KEEP CURRENT ROW [ = boolean ] -- 焦点不在表格时，还突出显示当前行 | HELP = help-number | COUNT = row-count -- 使用定长数组时，需要指定显示行数 | UNBUFFERED [ = boolean ] -- 修改变量自动显示到画面，而无需再次DISPLAY } "},{"id":83,"href":"/docs/BDL/2.medium/16.module/6.practise/","title":"6.练习","section":"第十六章 模块","content":"练习\r#\r\r使用cl_null()、cl_replace_str()、cl_digcut()、cl_get_env()\r#\r\r p_findfunc作业可以查询tiptop gp中常用sub、lib函数 请注意以上函数需要的参数和返回值数量  新增一个lib函数cl_get_runtime_line()\r#\r\r 无参数 以下方式返回一个字符串，czz_czzi001.4gl为当前运行的文件名称，7为代码运行的当前行  file:czz_czzi001.4gl line:7 可以使用__FILE__ __LINE__ 两个宏定义标记  "},{"id":84,"href":"/docs/BDL/2.medium/14.database/6.practise/","title":"6.练习","section":"第十四章 数据库使用","content":"练习\r#\r\r创建学生资料表student\r#\r\r   字段 数据类型 字段说明     name varchar(20) 姓名   grade varchar(4) 年级   course varchar(40) 课程名称   score number(5) 得分    输入学生资料信息，插入到数据库\r#\r\r 如果相同已经有该姓名、年级、课程名称的资料那么更新已有成绩 如果得分小于0，或者大于100，报错，跳过这笔资料 当有20笔资料时，停止录入     姓名 年级 课程名称 得分    查询每门课的最高成绩，和平均成绩，并以以下格式显示\r#\r\r课程名称 平均分 最高分\ra 67 90\rb 87 99\r 查询按照课程名称和成绩倒序排列显示成绩单\r#\r\r姓名 年级 课程名称 成绩\r小米 4 数学 78\r小红 5 语文 98\r "},{"id":85,"href":"/docs/BDL/1.basic/6.operators_and_expressions/6.operation-priority/","title":"6.运算符优先级","section":"第六章 运算符和表达式-程序基本构成","content":"运算符优先级\r#\r\rBDL中运算符具有不同优先级和结合性。\n在表达式中，各运算量参与运算的先后顺序不仅要遵守运算符优先级别的规定，还要受运算符集合的制约，以便确定自左向右进行运算还是自右向左预算。\n优先级、结合性汇总\r#\r\r   优先级 运算符 结合性 说明 用法     13 units 左 间隔转换 (12) units day   12 ** 左 幂 x**5   12 mod 左 求余数 x mod 2   11 * 左 乘法 x*y   11 / 左 除法 x/y   10 + 左 加法 x+y   10 - 左 减法 x-y   9 || 左 连接符 \u0026ldquo;ab\u0026rdquo;   8 like 右 字符串比较 mystring like \u0026ldquo;A%\u0026rdquo;   8 matches 右 字符串比较 mystring matches \u0026ldquo;A*\u0026rdquo;   7 in() 左 清单比较 var IN(\u0026lsquo;CA\u0026rsquo;,\u0026lsquo;NY\u0026rsquo;)   6 \u0026lt; 左 小于 a\u0026lt;10   6 \u0026lt;= 左 小于等于 a\u0026lt;=10   6 \u0026gt; 左 大于 a\u0026gt;10   6 \u0026gt;= 左 大于等于 a\u0026gt;=10   6 == 左 等于 a==10   6 \u0026lt;\u0026gt; or != 左 不等于 a\u0026lt;\u0026gt;10   5 is null 左 控制判断 a is null   5 is not null 左 控制判断 a is not null   4 not 左 非 not(a=b)   3 and 左 与 a=b and a=c   2 or 左 或 a=b or a=c   1 ascii() 右 ascii值 ascii(32)   1 clipped 右 尾部去空格 \u0026ldquo;as \u0026quot; clipped   1 column 右 空白字符 display column 32,\u0026ldquo;a\u0026rdquo;   1 spaces 右 空格 a = \u0026ldquo;a\u0026rdquo;(5)space   1 sqlstate 右 sql状态 if sqlstate=\u0026ldquo;ix000\u0026rdquo;   1 sqlerrmessage 右 sql错误信息 display sqlerrmessage   1 using 右 格式化字符串 today using \u0026ldquo;yy/mm/dd\u0026rdquo;    这些不需要死记硬背，你可以随时来查看，在你不确定的时候，直接用()讲需要优先运行的包裹起来，就避免要考虑太复杂情况。\n"},{"id":86,"href":"/docs/BDL/1.basic/3.composition_of_bdl/6.variable/","title":"6.变量","section":"第三章 最简单bdl程序的组成","content":"变量\u0026ndash;数据从哪里来，又到那里去\r#\r\r在计算机程序设计中，经常要用到变量。比如在屏幕中移动光标，需要存储光标的x，y坐标，每次移动光标，就需要对坐标修改，也就是x、y的值要改变;为了得到当前光标的坐标，就需要从x、y中得到当前的值。在程序设计中这些值都是通过变量来完成的。\n变量在内存中的表现形式\r#\r\r变量是指其值可以变化的量。在计算机中，指令代码、数据都存储于内存中。变量也需要存储在内存中。\n类比人类的思维过程，也很容易明白为什么需要内存空间存储变量:假设现在有3个数据，分别是a=3,b=4,c=5，需要读者去计算“a+b+c\u0026quot;的值。 读者首先回忆a的值是3，b的值是4,c的值是5，然后分别用3、4、5作为计算的数得到“3+4+5=12”。\n这是一个很简单的过程，思考过程几乎不花费时间。如果计算的变量超过100个，估计大部分读者都记不住这么多数据的值，需要把这些数据及其对应的数值记录在纸上或其他地方，当需要用到某个数据的时候，再去查看其对应的值。计算机中变量的作用与它类似。\n在计算机中，每个变量都被分配了一块内存空间，在这些空间里存储的就是变量的值。 变量之所以可以变化，就是这个存储空间可以存储不同的数值。存储空间里的值变化，则变量对应的值也变化。 同一个时间，内存空间里只能保存一份值，新值冲掉了原来的旧值。 每个内存单元都有编号，这些是内存的地址。如图所示。\n\r编译器使用变量符号表\r#\r\r在源代码中，每个变量都有变量名。 实际上，编译后的目标代码里并没有变量名字，而是记录着变量在内存空间中的地址。 在BDL语言中，通过变量名就可以访问到变量的值，对变量名的访问，就是对变量值的访问。\n在编译的过程中，编译器会建立-张变量符号表，该表记录的数据是:变量类型、变量名、变量地址等信息。\n变量及其使用\r#\r\r变量有不同的类型，如记录英文字母及标点符号，就需要字符类型(varchar)的变量； 记录整数需要整数类型integer的变量； 记录实数有decimal类型的变量。 这些变量都是数值类型，BDL语言还提供了其他类型的变量，详细讲解请参见后续章节的论述。\n通过上述的简单叙述，读者可以对变量有了一个大概的感性认识。再回过头来看看源代码中每行的意思。\ndatabse ds main  define a,b integer --定义a,b 为整型  define y integer --定义y为整型   let a = 1 --将变量a赋值为1，此时a的值为1  let b = 1 --将变量b赋值为1，此时b的值为1  let y = a + b --将a，b的值分别取出来，计算结果后，赋值给变量y  display sfmt(\u0026#34;\\na+b=%1\u0026#34;,y) --将y的值打印出来 end main  define a,b integer  这是向编译器声明，以下程序将会用到两个整型变量，其名字为a和b。此时并不会进行真正的内存分配动作，也就是此时并没有内存地址与变量名关联。\n“define”是BDL语言提供的关键字，需要定义变量时必须使用。\n“integer”是BDL语言提供的关键字，是integer (整数)的缩写，表示为整数数据类型，简称整 型。\n其后紧跟的是变量名称，变量名由程序员命名。变量名称也必须是字母开头，其后的部分可以是字母、数字、下划线的组合。 在同一行中可以声明多个变量，变量间用逗号分隔。\ndefine y integer  同样是向编译器声明，以下程序会用到整型变量y。变量可以一行声明多个，也可以一行声明一个，多个变量分多次声明，意义都一样。\nlet a = 1  这是给a赋值。 “let”是是BDL语言提供的关键字，需要给变量赋值是必须使用（后面也有其它办法赋值）。 请读者注意等号“=”，“=”是BDL语言提供的运算符。 在BDL语言里的“=”不同于数学里的等号“=”。 数学中的等号是说“=” 两边相等，左右等价，可以交换。 计算机中的“=”是赋值符号，有一个运算顺序，是先计算“=” 右边的表达式的值，然后把数值赋给左边。左右不能交换。 所谓赋值，就是把运算所得的数值存储在内存中。\n当第一次访问变量的时候，编译器将给变量分配内存。所谓访问，就是“存取”，“存”，是把数据存储在内存中，“取”，是从内存中把数据取出来。\n注意\n从内存中取数据的“取”和从篮子里把南瓜“取”出来有些区别。 南瓜从篮子里取走后，篮子里不再有任何东西，南瓜被拿走了。 而计算机内存中的取，是把数值复制出来，内存空间里面的数值并不会变化，也就是从内存空间里把数值“读”出来。\r\rlet b = 1  同样的，编译分配内容空间给变量b，然后将数值1放到对应的空间中。\nlet y = a + b  这里的“+”，也是BDL语言提供的运算符号。同数学里的四则运算中的“+”一样，进行加法运算。\n注意本行代码运算顺序：\n 先获取a的值。a是变量名称，查询变量符号表，得到地址，再从地址中取到数值1。则a的值为1\u0026ndash;let y = 1 + b  再获取b的值。同样的过程，b的值也为1\u0026ndash;let y = 1 + 1 计算 1 + 1，得到数值2\u0026ndash;let y = 2 把数值2赋给ylet y = 2  display sfmt(\u0026quot;\\na+b=%1\u0026quot;,y) 把y的值打印出来。 这里同样要访问变量y去获取其值。  "},{"id":87,"href":"/docs/BDL/2.medium/17.interface/7.input/","title":"7.INPUT","section":"第十七章 用户界面","content":"INPUT\r#\r\rINPUT 和DISPLAY 一样可以将资料显示在已打开的画面上。\n和DISPLAY不同的地方在于，DISPLAY中用户只能点击按钮操作，而INPUT中每个栏位(entry设置为\u0026rsquo;Y\u0026rsquo;)都变为可输入的状态，用户输入后将输入的内容赋值给INPUT中的变量。\n和DISPLAY和语法一样，INPUT也有两种语法。\nINPUT 表单\r#\r\rINPUT p_employee.no FROM no\nINPUT BY NAME p_employee.no\n以上两种语法和DISPLAY一致，INPUT BY NAME语法中，结构体的成员名称必须和画面中控件名称相同。\n除了以上语法INPUT也支持块语法END INPUT。\nINPUT variable-list FROM field-list  BEFORE INPUT   AFTER INPUT   BEFORE FIELD field-list   AFTER FIELD field-list   ON CHANGE field-list   ON ACTION action-name   ON IDLE idle-seconds  END INPUT 因为在表单录入时，我们需要校验字段值、或者指定字段输入顺序、带出默认值等限制性操作，所以在表单时就提供了块级别语法，在块语法中，我们可以加上我们想限制的语法。\n注意\n块语法中所有内容都是可选的，如果任何语句都没有，那么和不写END INPUT是一样的。\n\rINPUT额外支持语法\r#\r\rDISPLAY 中所有语法INPUT都支持，除了之前讲过的语法，还支持以下语法：\n BEFORE FIELD field_name  BEFORE FIELD ima01在焦点到ima01字段之前会运行到此处\n AFTER FIELD field_name  AFTER FIELD ima01在焦点要离开ima01字段之前会运行\n ON CHANGE field_name  ON CHANGE ima01在焦点要离开ima01字段前，如果字段被修改过会运行\n NEXT FIELD field_name  NEXT FIELD ima01 焦点调到指定字段处，这个语法是独立运行的，需要在控制语法后运行\nINPUT 表格\r#\r\rINPUT 同样有INPUT ARRAY语法，可以显示并输入表格格式控件。\nINPUT ARRAY array [ WITHOUT DEFAULTS ] FROM screen-array.*  [ HELP help-number ]  [ ATTRIBUTE ( {display-attribute | control-attribute }  [,...] ) ]  BEFORE INPUT  AFTER INPUT  AFTER DELETE  BEFORE ROW  AFTER ROW  BEFORE FIELD field-list  AFTER FIELD field-list  ON ROW CHANGE  ON CHANGE field-list  ON IDLE idle-seconds  ON ACTION action-name  BEFORE INSERT  CANCEL INSERT  AFTER INSERT  CANCEL INSERT  BEFORE DELETE  CANCEL DELETE END INPUT ATTRIBUTE\r#\r\rATTRIBUTE 除了DISPLAY中的语法，额外还支持以下语法：\n APPEND ROW [ =bool]  是否需要中间插入资料\n DELETE ROW [ =bool]  是否允许删除行\n INSERT ROW [ =bool]  是否运行新增一笔资料\n MAXCOUNT = row-count  可以录入的最大行\n额外支持的控制语法\r#\r\rINPUT ARRAY支持INPUT的所有控制语法，INPUT ARRAY还支持以下控制语法：\n AFTER DELETE  删除之后运行\n BEFORE ROW  焦点在任意行之前运行\n AFTER ROW  焦点离开任意行之后运行\n BEFORE INSERT  插入资料之前运行\n AFTER INSERT  资料插入之后运行\n BEFORE DELETE  删除资料之前运行\n额外其它语句\r#\r\r以下语句不是控制语句，可以用在控制语句后。\n CANCEL DELETE  取消删除\n CANCEL INSERT  取消插入\n"},{"id":88,"href":"/docs/BDL/1.basic/6.operators_and_expressions/7.practice/","title":"7.练习","section":"第六章 运算符和表达式-程序基本构成","content":"练习\r#\r\r测试以下代码输出\r#\r\r define m,n integer  define x,y decimal(20,6)  let m = 1 let n = 2  let x=1.41 let t=2.5   display sfmt(\u0026#34;\\nm\u0026lt;n and y-1\u0026gt;x=%1\u0026#34;,m\u0026lt;n and y-1\u0026gt;x)  display sfmt(\u0026#34;m\u0026lt;n or y-1\u0026gt;x=%1\u0026#34;,m\u0026lt;n or y-1\u0026gt;x)  display sfmt(\u0026#34;not (y-1\u0026gt;x)=%1\u0026#34;,not (y-1\u0026gt;x)) 用笔计算处以下代码运行结果，然后键入系统。\r#\r\r 看看笔算的结果和系统计算结果一样\n  define a,b integer  let a=5 let b=4   display sfmt(\u0026#34;\\n最后输出的结果是%1，但是a的值是%2\u0026#34;,a=2*8,a/4)  let a=2*8  let a=a/4  display sfmt(\u0026#34;a的值是%1\u0026#34;,a)  display sfmt(\u0026#34;a和b的比较结果是=%1\u0026#34;,a==b) "},{"id":89,"href":"/docs/BDL/1.basic/3.composition_of_bdl/7.create-a-function/","title":"7.设计一个BDL函数","section":"第三章 最简单bdl程序的组成","content":"设计一个BDL函数\r#\r\r用BDL语言库函数和第三方提供的函数组装程序是程序设计的\u0026ndash;条捷径和重要方法。但是，一个BDL程序不可能只由一个main函数组成，不能在main函数中实现所有的功能。编写程序，更多的时候需要程序员自己动手创建新的函数。\n在main函数中计算3个整数的平均数\r#\r\r先看以下代码\ndatabse ds main  define a,b,c,y integer --定义abc为整型  let a = 1 --赋值  let b = 2 --赋值  let c = 3 --赋值  let y = (a+b+c)/3 --进行数字计算  display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y) end main 编译后运行，程序输出为\nthe average is 2 代码解析\n main 不再赘述 define a,b,c,y integer 定义变量为整形， let ...= 1,2,3 变量赋初始值 let y = (a+b+c)/3  向编译器声明变量y为整型变量。计算a+b+c的值得到6，再整除3，得到2。 然后将2赋值给y。 “()\u0026ldquo;在这里同数学里的四则运算中的小括号“()”一样，表示需要优先运算。 “/”相当于四则运算中的除法运算。\ndisplay sfmt(\u0026quot;\\n the average is %1\u0026rdquo;,y)  在控制台中打印出y的值 这段代码计算1、2、3三个整数的平均值，最后正确打印出结果来。\n在main函数中分3次计算3个整数的平均值\r#\r\r如果需求变化为先计算1、2、3这3个整数的平均值后，再计算1234、2345、3456这3个整数的平均值，最后计算9876、2345、1这3个整数的平均值呢?\n方法一以下所示。\ndatabse ds main  define a,b,c,y,a2,a3,b2,b3,c2,c3,y2,y3 integer --定义abc为整型  let a = 1 --赋值  let b = 2 --赋值  let c = 3 --赋值  let a2 = 1234 let a3 = 9876  let b2 = 2345 let b3 = 2345  let c2 = 3456 let c3 = 1   let y = (a+b+c)/3 --进行数字计算  let y2 = (a2+b2+c2)/3 --进行数字计算  let y2 = (a3+b3+c3)/3 --进行数字计算  display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y)  display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y2)  display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y3) end main 编译运行后输出如下：\nthe average is 2\rthe average is 2345\rthe average is 4074 自编函数实现计算3个整数平均值\r#\r\r关注以下3行代码：\nlet y = (a+b+c)/3 let y2 = (a2+b2+c2)/3 let y2 = (a3+b3+c3)/3 这3行代码将求平均值的公式使用了3次。重复的代码将使得以后的代码维护困难，因为一个地方修改，其他重复的地方也要修改。这3行代码的功能相同，虽然很简单，但是可以将其抽取出来形成一个函数。\n具体以下所示。\ndatabse ds main  define a,b,c,y,a2,a3,b2,b3,c2,c3,y2,y3 integer --定义abc为整型  let a = 1 --赋值  let b = 2 --赋值  let c = 3 --赋值  let a2 = 1234 let a3 = 9876  let b2 = 2345 let b3 = 2345  let c2 = 3456 let c3 = 1   let y = average(a+b+c) --进行数字计算  let y2 = average(a2+b2+c2) --进行数字计算  let y2 = average(a3+b3+c3) --进行数字计算  display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y)  display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y2)  display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y3) end main -- 函数定义：具体函数实现 -- 函数名：average -- 参数：a,b,c三个整形参数 -- 返回值：整形，返回3个整数的平均值 function average(a,b,c)  define a,b,c integer  return (a+b+c)/3 end function 编译运行代码，结果和之前一样。\n如何自编写函数\r#\r\r对上面的代码说明如下：\n 函数调用  let y = average(a+b+c)\rlet y2 = average(a2+b2+c2)\rlet y2 = average(a3+b3+c3) 着3行就是在调用函数average。 2. 函数定义部分\nfunction average(a,b,c)  define a,b,c integer  return (a+b+c)/3 end function 函数定义的语法规则如下：\nfuntion 函数名(参数1,参数2...)  define 参数1,参数2... --参数类型定义  函数体部分 end funtion 代码解析\naverage是函数名称。 名称由程序员自己决定，符合命名规则即可。 小括号内的“a,b,c”是3个参数的列表。 function下一行中，define a,b,c integer 表示3个参数都是整数类型。\nreturn是BDL语言提供的关键字。 其功能是终止函数的执行，从函数中返回到调用它的地方，并可以向调用者返回其后表达式的值。 return 作用有两个：   返回 返回值  "},{"id":90,"href":"/docs/BDL/2.medium/17.interface/8.construct/","title":"8.CONSTRUCT","section":"第十七章 用户界面","content":"CONSTRUCT\r#\r\r为了避免SQL注入安全问题，BDL提供了CONSTRUCT语法，用来输入SQL查询条件的场景。\nCONSTRUCT运行时，会先清空输入字段的所有资料内容，然后根据录入的内容组成SQL查询条件。\nCONSTRUCT并不区分表单还是表格，因为表格也只能录入第一行资料。\nCONSTRUCT 有两种写法，两者只在开头处有区别，块语法中无区别，所以放在一起讲\n BY NAME ON  CONSTRUCT BY NAME variable ON column-list  [ ATTRIBUTES ( { display-attribute  | control-attribute }  [,...] ) ]  [ HELP help-number ] [ dialog-control-block  [...] END CONSTRUCT ]  ON FROM  CONSTRUCT variable ON column-list FROM field-list  [ ATTRIBUTES ( { display-attribute  | control-attribute  } [,...] ) ]  [ HELP help-number ] [ dialog-control-block  [...] END CONSTRUCT ] "},{"id":91,"href":"/docs/BDL/1.basic/3.composition_of_bdl/8.statement/","title":"8.语句","section":"第三章 最简单bdl程序的组成","content":"语句构成程序\r#\r\rBDL语言有以下5中类型语句。\n 表达式语句。 BDL语言中，操作者或动作可成为表达式。 例如以下示例都是表达式语句：  define a integer\rdisplay \u0026#34;hello world\u0026#34; BDL还有很多中流程控制语句。 如if-else，for循环语句，while循环语句，continue，结束本次循环语句，break跳出循环语句，switch多路分支语句，goto专项语句，return返回语句。 学习到画面规格后，还将设计到input输入语句，display显示语句（这里display与现在的display不同），dialog交互等画面控制语句。 函数调用构成的函数调用语句 符和语句，将以上语句写在同一行的语句  BDL语言中最小的程序单元是语句。 另外在源代码中有一些是指示编译器如何编译的预处理器指示命令，如\u0026amp;ifdef \u0026amp;endif \u0026amp;include等。 BDL语言源代码，就是由语句和这些指示命令构成的。\n"},{"id":92,"href":"/docs/BDL/2.medium/17.interface/9.practise/","title":"9.练习","section":"第十七章 用户界面","content":"练习\r#\r\r学生成绩录入作业\r#\r\r 功能录入每个学生三门成绩，语文、数学、英语 每次录入完毕在后台显示改学生出成绩 成绩为0~100的整数 学生姓名不能重复录入  进阶\r#\r\r请将上述资料建立合适的表，并保存到数据库\n利用表格显示学生成绩\r#\r\r 可修改成绩，但不能修改学生姓名 不可增加、删除 可以查询，学生栏位可以开窗选择  "},{"id":93,"href":"/docs/BDL/1.basic/3.composition_of_bdl/9.code-style/","title":"9.代码风格","section":"第三章 最简单bdl程序的组成","content":"代码风格\u0026ndash;向优秀程序员看齐\r#\r\r所谓代码风格，是编写代码时对代码的排版布局、如何命名代码中的变量名称、函数名称等。 一个优秀的程序员，除了代码质量高、错误少之外，另一个非常重要的标准就是代码风格。\n在很多时候，代码风格比程序的效率更加重要，代码风格的好坏可以直接看出一个程序员编程 的素质。\n优秀的代码风格如同一身得体的打扮，能够给人以良好的印象。\n初学程序设计，首先必须建立良好的编程习惯，这其中就包括代码风格。\n代码风格是很个性化的，每个程序员都会有自己的喜好和见解。\n在本书后续章节的相关内容中，将介绍一些编程中需要注意到的一些代码风格。 一些通用的风格，如每行尽量不超过80个字符，这个标准是有历史原因的，以前的编辑器一行只能显示80个字符，所以超过80字符，就得滚动才能看全。 现在的编辑器已没有这个限制，但是一行中有太长的代码依旧不利于程序员阅读;\n使用有描述意义的变量名函数名，尽量不要使用简写。\n"},{"id":94,"href":"/docs/BDL/1.basic/3.composition_of_bdl/10.practice/","title":"10.练习","section":"第三章 最简单bdl程序的组成","content":"练习\r#\r\r自定义一个函数，实现两个整数求和\r#\r\r找出以下代码的错误\r#\r\rdatabase ds  main()  define a,b integer  define y integer  let a = 10 let b= 20  let y = add(a,b)  display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y) end main  function add(a,b)  define a,b integer  a+b end function "},{"id":95,"href":"/docs/BDL/4.actual-combat/1.%E5%8D%95%E6%A1%A3/","title":"第一章 单档","section":"BDL实战","content":" 表单 表格  "},{"id":96,"href":"/docs/BDL/1.basic/1.before_all/","title":"第一章 踏上征程前的思想动员","section":"BDL基础","content":"第一章 踏上征程前的思想动员\r#\r\r首先恭喜你入坑，无论出于什么原有，选择了BDL语言，但我想大部门原因是因为鼎捷的ERP（tiptop gp,T100）。\nBDL是一门比较小众的语言，更新换代不算频繁，运行效率比较低的语言，开发其公司网址为\r4js。因为其定位是一门商业开发语言，同类型的还有SAP的abap。\n但与缺点相对的，因为商业开发语言，配套的工具（studio开发工具、数据库驱动、客户端、报表甚至移动端开发）都是完备并且打包好，有成熟的解决方案，只要你舍得套必要的费用。\n所以本书只介绍BDL语言特性，环境以及开发工具等，一概不涉及到。\n"},{"id":97,"href":"/docs/BDL/1.basic/2.first_code/","title":"第二章 第一行代码","section":"BDL基础","content":"第一行代码\r#\r\r在本章，我将带领你一起，一步步创建一个没有实际意义，但是却极其常见的程序\u0026ndash;HelloWorld。 在初学一门编程语言的时候，写一个\u0026quot;Hello World!\u0026ldquo;程序是最常见的入门方法。\n"},{"id":98,"href":"/docs/BDL/4.actual-combat/2.%E5%8F%8C%E6%A1%A3/","title":"第二章 双档","section":"BDL实战","content":" 上表单下表格 双表格  "},{"id":99,"href":"/docs/BDL/1.basic/3.composition_of_bdl/","title":"第三章 最简单bdl程序的组成","section":"BDL基础","content":"最简单bdl程序的组成\r#\r\r在第二章，大家一起创建了第一个可运行的程序。 你对源代码可能一头雾水，不止所以，所以本章解释了第二章中Hello Wordl的源代码，先回顾以下第二章的源代码。\ndatabase ds main  display sfmt(\u0026#34;hello world\u0026#34;) end main 这里我们增加一个单词sfmt，运行一下，你会发现和之前的输出一样。\n"},{"id":100,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/","title":"第四章 存储和获取数据","section":"BDL基础","content":"存储和获取数据\r#\r\r上一章中我们对BDL语言有了一个大概的了解，认识了函数、关键字、变量和数据类型。 书和操作是构成程序的两个最基本的要素。本章详细讨论BDL语言描述数据的形式和对数据的基本操作。\n"},{"id":101,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/","title":"第五章 利用键盘、鼠标与程序交互","section":"BDL基础","content":"利用键盘、鼠标与程序交互\r#\r\r计算机的主要功能，是获取输入，将输入的数据计算处理后输出结果。 计算机的输入，最常见的是通过键盘和鼠标;输出，最常见的是显示器。 本章介绍如何显示字符和字符串到显示器屏幕上，以及如何接收用户的键盘输人。\n"},{"id":102,"href":"/docs/BDL/1.basic/6.operators_and_expressions/","title":"第六章 运算符和表达式-程序基本构成","section":"BDL基础","content":"运算符和表达式-程序基本构成\r#\r\r计算机的主要工作之一就是运算。 这里所说的运算，不仅仅指简单的算术运算如加、减、乘，除，还包括其他的运算，如关系运算、逻辑运算等。 本章将介绍一些比较基础的运算。 另外有一些运算留在后续章节慢慢介绍。 不同的运算有不同的写法，也有不同的规则，这些规则是程序员必须遵守的规则。\n表达式是对运算进行表达的句式，经过计算，最终有一个确定的值。 在BDL语言中，表达式也有很多种，当然也有很多规则，也是需要程序员遵守的。\n"},{"id":103,"href":"/docs/BDL/1.basic/7.atoml_statement/","title":"第七章 语句-程序最小构成单元","section":"BDL基础","content":"语句-程序最小构成单元\r#\r\r如果把程序和写小说类比、常量、变量等可以堪称是字和词，函数可以看成一个段落，运算符等可以看作是字词的组合方式规则，那么，字词组成的句子就是小说的最小独立单元，表达了一定的意思。 同样，程序的最小独立单元式“语句”，每个语句表达出完整的意思。\n"},{"id":104,"href":"/docs/BDL/1.basic/8.condition/","title":"第八章 条件判断-分支结构","section":"BDL基础","content":"条件判断-分支结构\r#\r\r3种基本控制结构中，顺序结构是最简单的一个，只要沿着指定的语句序列一路向下即可，无须选择、拐弯或者折回，而分支结构和循环结构相对要复杂一点，分支结构涉及从多条岔路中选择合适的语句执行，而循环结构则会重复执行某块语句，也就是说，在执行完后还要折回，再次执行。本章主要讨论几种常见的分支结构和它们的用法。\n"},{"id":105,"href":"/docs/BDL/1.basic/9.over_and_over_again/","title":"第九章 循环结构--一遍又一遍","section":"BDL基础","content":"循环结构\u0026ndash;一遍又一遍\r#\r\r所谓“循环”，就是重复多次地执行某块代码段，循环结构是C语言程序书写中常用的一种重要控制结构。\nBDL语言提供了2种循环结构，分别是while结构和for结构，本章将对其展开讨论。\n"},{"id":106,"href":"/docs/BDL/2.medium/10.function/","title":"第十章 函数入门-写程序就是写函数","section":"渐入佳境","content":"函数入门-写程序就是写函数\r#\r\r相信读者大致都了解一点数学意义上“函数”的概念，比如“y=f (x)”\u0026quot;，且不论f的具体形式如何，其基本特点是“对一个x (输入), 有一个y (输出)与之对应”。 BDL语言中，“函数”是个重要的概念，是模块化编程的基础。\n"},{"id":107,"href":"/docs/BDL/2.medium/11.array/","title":"第十一章 数组-同一类型的多个元素的集合","section":"渐入佳境","content":"数组-同一类型的多个元素的集合\r#\r\r在实际的程序设计和代码编写中，经常会用到大批同类型的数据，比如某个班学生的成绩等。为方便解决这类问题，BDL语言提供了数组这一数据结构，这里的数据结构，可理解为数据的存放和管理方式。\n和普通变量一样，在使用数组前必须先对其声明以开辟所需要的内存空间，由于数组是很多数据的集合，这些数据对应的内存单元是如何排列的，这都是本章要讲解的内容。\n"},{"id":108,"href":"/docs/BDL/2.medium/12.string/","title":"第十二章 字符串操作","section":"渐入佳境","content":"字符串操作\r#\r\r在各种编程语言中，字符串都占据着十分重要的地位，为方便用户处理字符串，BDL语言标准库函数提供了很多字符串处理函数。\n"},{"id":109,"href":"/docs/BDL/2.medium/13.struct/","title":"第十三章 结构体","section":"渐入佳境","content":"结构体\r#\r\r程序设计中，如何合理组织数据是门学问，前面介绍过的数组是种组织数据的方式，但数组只适用于同类型的数据，如果类型不同又当如何?而且在现实中，很多对象都具有不同的属性，以人为例，像姓名、性别、身高等都是其属性。如何合理存储并方便地访问这些信息，是本章要介绍的内容。\n"},{"id":110,"href":"/docs/BDL/2.medium/14.database/","title":"第十四章 数据库使用","section":"渐入佳境","content":"本章我们将介绍在BDL中使用数据库：\n 连接数据库 *** record like ***** 插入数据、更新数据、删除数据 ***** 查询单条数据 ***** 查询多条数据 ***** 事务 **** 临时表 ***  "},{"id":111,"href":"/docs/BDL/2.medium/15.function_plus/","title":"第十五章 函数进阶","section":"渐入佳境","content":" 无参数无返回值函数 无参数有返回值函数 有参数无返回值函数 有参数有返回值函数 数组作为参数 数组作为返回值 结构体作为参数 结构体作为返回值  "},{"id":112,"href":"/docs/BDL/2.medium/16.module/","title":"第十六章 模块","section":"渐入佳境","content":"模块\r#\r\r fglrun,fglcomp,fgllink,(fglform) 认识，了解有这个命令，不要求记忆或使用 debug 需要熟练使用  断点 watch b call step step in step out   globals 需要学会使用 sub/lib 需要完全了解、理解、并使用  "},{"id":113,"href":"/docs/BDL/2.medium/17.interface/","title":"第十七章 用户界面","section":"渐入佳境","content":"用户界面\r#\r\r 4fd/per 文件，genero studio的使用 **** menu ** input ***** display ***** construct ***** prompt *** dialog **** Drag \u0026amp; drop *  \r参考文档\n"},{"id":114,"href":"/docs/BDL/3.advance/20.build-in-packages/","title":"第二十章 标准包","section":"BDL进阶","content":" base  Channel 文件操作 StringBuffer 文本操作 StringTokenizer 字符串分割 TypeInfo 类型操作   om xml节点操作  DomDocument DomNode NodeList XmlReader XmlWriter   util  DateTime 时间操作 Math 数学公式   os.Path 路径操作 com   WebService Class HTTP TCP   xml  "},{"id":115,"href":"/docs/BDL/1.basic/2.first_code/5.practice/","title":"5.练习","section":"第二章 第一行代码","content":"练习\r#\r\r编程输出中文“你好，世界！”\r#\r\r输出5个空行，不显示任何字符或字\r#\r\r输出数字1、2、3、4、5，但是每行显示一个数字\r#\r\r"}]