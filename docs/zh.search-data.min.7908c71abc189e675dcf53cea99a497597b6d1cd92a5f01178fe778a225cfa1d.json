[{"id":0,"href":"/docs/BDL/2.medium/15.function_plus/1.parameter/","title":"1.函数的参数","section":"第十五章 函数进阶","content":"\r函数的参数\r#\r在BDL中除了变量定义，其它所有操作都需要在函数中进行。\n所以能够灵活使用函数是编程能力重要体现，使用函数时，除了程序逻辑需要考虑，如何定义函数的结构也是值得考虑的。\n函数的结构包括两部分，参数与返回值。\n参数个数\r#\r函数的参数个数是无上限的，且不是必须含有参数。\n如果你的函数不受程序的上下文影响，或者说不需要考虑调用之前做了哪些操作，那么你的函数就不要参数。\nBDL自带函数中有不少类似函数如下：\nfgl_lastkey() --获取最后一次按下的按键 "},{"id":1,"href":"/docs/BDL/2.medium/14.database/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/","title":"1.数据库连接","section":"第十四章 数据库使用","content":"\r数据库连接\r#\rTIPTOP GP/T100 在按照时会配置号数据库，一般为ORACLE DB，也可能是postgresql。\n本章所有内容都是基于ORACLE DB，但大部门内容应该是通用的。\n数据库已经配置的连接可以在文件$FGLPROFILE中看见，这里配置好的数据库都是可以在BDL中使用的。\n连接数据库\r#\r在已有的BDL代码中我们经常见到在main函数外，有一个databse ds语句。\ndatabase就是连接数据库的语句，ds就是要连接的数据库。ds为TIPTOP中一个特殊的数据库，此数据保存了所有表的表结构，和同义词表的数据。\n同义词值得是不同库之间都可以使用的一个表，但此表实际只保存在ds库，每个库查看的数据内容都是相同的。\ndatabase ds1即可切换到ds1数据库中。\nmain funtion main()的区别\r#\rmain end main 还可以写出function的格式function main() end function。\n这两者在连接数据库时是有区别main end main 会自动连接到 main之外的databse ds数据库。 而function main() end function只会用到databse ds的表结构，而不会自动连接到数据库。\n使用表结构的方法在下一节将会讲到\n除此之外他们还有另一个区别main end main需定义在一个模块所有函数之前，而function main() end function的位置没有限制。\n"},{"id":2,"href":"/docs/BDL/2.medium/13.struct/1.record/","title":"1.结构体","section":"第十三章 结构体","content":"\r结构体\r#\r仍以人为例来介绍，要管理姓名、单位、E-mail地址、 联系电话等信息，现实生活中，很多人采用名片的形式，将这些信息印在一张卡片上。\n收集的一张张名片大大方便了数据的管理，将这种理念借鉴到BDL语言程序设计中，是否有类似于名片的那么一种变量呢?\n有，答案就是“结构体变量”，这是一种复合变量，在进一步说明结构体变量前，先来看“结构体”的概念，结构体和结构体变量的关系类似与类型与普通变量的关系，结构体中说明了结构体变量的信息格式，而结构体变量是结构体的实例。\n结构体的定义\r#\r只有先完成结构体的定义，才能声明并使用结构体变量，正如，只有确定了名片，上要印什么内容，才能开始印刷名片。结构体的定义即是为了说明结构体变量要存储什么信息的过程。\ndefine 变量 record 存储数据列表 end record 举例说明：\ndefine person record name,age varchar(20), email varchar(50) end record 上面我们定义了一个变量person，这个变量没有实际的累计，既不是字符串也不是数字。而其内有有另外类似变量的定义name、age和email。\n结构体定义规则：\n每个成员名称符合标识符规则 在同一个结构体中名称不得重复 每个成员定义后要加,号，最后一个成员不能加, 与下一个成员类型一致，可以省略类型 访问结构体成员\r#\r习惯上我们将诸如字符串name、age和email在结构体变量内部这些变量称作数据成员（简称成员），有的时候也称作元素、属性。\n在定义了一个结构体变量后，我们使用成员操作符号.来访问每个成员，例如person.name、person.age，分别表示person这个变量中储存的姓名年纪等信息。\n提示\n结构体成员，和我们之前使用的变量的方法都是使用.操作符号来访问/调用。他们的区别在于方法需要有()，而成员没有()。\n我们看一段示例代码：\ndefine zhangsan record name varchar(20), age integer, email varchar(50) end record let zhangsan.name = \u0026#34;zhang san\u0026#34; let zhangsan.age = 24 let zhangsan.email = \u0026#34;zhangsan@outlook.com\u0026#34; display sfmt(\u0026#34;\\nname:%1\u0026#34;,zhangsan.name) display sfmt(\u0026#34;age:%1\u0026#34;,zhangsan.age) display sfmt(\u0026#34;email:%1\u0026#34;,zhangsan.email) 输出结果:\nname:zhang san\rage:24\remail:zhangsan@outlook.com 初始化结构体变量\r#\r当你的结构体变量需要重复使用时，你不知道之前的结构体哪些成员有值，哪些成员没有值了。\n难道要访问每个成员复制为空值吗？\n我们有一个快速将结构体所有成员赋空值的关键字：\ninitialize 结构体变量.* to null 批量访问成员变量\r#\r初始化所有成员时，我们使用了一个结构体变量.*方式。 这里的.*表示访问所有成员。\n除了访问所有成员，我们还可以指定一个成员范围。\ninitialize 结构体变量.成员1 thru 结构体变量.成员2 to null 需要注意的时thru连接的两个成员必须是同一个结构体变量，且只能在initialize、validate和locate中使用。\n请运行以下代码，观察其输出值：\ndefine zhangsan record name varchar(20), age integer, email varchar(50) end record define lisi record name varchar(20), age integer, email varchar(50) end record let zhangsan.name = \u0026#34;zhang san\u0026#34; let zhangsan.age = 24 let zhangsan.email = \u0026#34;zhangsan@outlook.com\u0026#34; let lisi.* = zhangsan.* let lisi.name = \u0026#34;lisi\u0026#34; display sfmt(\u0026#34;\\nname:%1\u0026#34;,zhangsan.name) display sfmt(\u0026#34;age:%1\u0026#34;,zhangsan.age) display sfmt(\u0026#34;email:%1\u0026#34;,zhangsan.email) display sfmt(\u0026#34;\\nname:%1\u0026#34;,lisi.name) display sfmt(\u0026#34;age:%1\u0026#34;,lisi.age) display sfmt(\u0026#34;email:%1\u0026#34;,lisi.email) 输出结果：\nname:zhang san\rage:24\remail:zhangsan@outlook.com\rname:lisi\rage:24\remail:zhangsan@outlook.com 利用let lisi.* = zhangsan.*可以赋值两个成员和对应数据类型一样的结构体变量的值。\n"},{"id":3,"href":"/docs/BDL/2.medium/12.string/1.dynamic-string/","title":"1.动态长度字符串","section":"第十二章 字符串操作","content":"\r动态长度字符串\r#\r我们知道BDL中可以存放数据类型的类型有好几种，string、char、varchar。text和byte有特殊不再本章讨论范围。\n对于定长类型varchar、char也不再本章讨论范围内。之后所说字符串特指string类型的字符串。\n所以要处理除了string类型的字符串，需要先转换为string类型。\n如果最大长度允许，string 与char、varchar在大部分地方都可以自动转换。但在SQL语句中无法自动转换。\n注意\nBDL4.01版本之后string类型也可以用于SQL中。\n字符串的方法\r#\r字符串的处理，就是通过BDL预定义的方式实现的，因为方法是绑定数据类型，所以char和varchar都是不能调用字符串string的方法的。\n拼接字符串\r#\r语法\nappend(a string) returning s string 使用案例\ndefine s string\rlet s = \u0026#34;darcy\u0026#34;\rlet s = s.append(\u0026#34;.joven\u0026#34;) 除了调用方法，拼接字符串还有很多其它方式。\n逗号拼接 define s string let s = \u0026#34;darcy\u0026#34;,\u0026#34;.joven\u0026#34; 这是最常用的字符串拼接方法 2. ||拼接\ndefine s string let s = \u0026#34;darcyjoven\u0026#34;||\u0026#34;\u0026#39;s blog\u0026#34; 这种方式与逗号拼接区别在于，不能存在空值，有任意一个字符串为空值，最后的结果都为空值 3. sfmt()拼接\ndefine s string let s = sfmt(\u0026#34;darcy%1\u0026#34;,\u0026#34;joven\u0026#34;) sfmt()拼接的好处在于：非字符串类型为显示转换。\n字符串比较\r#\requals(s string) return b boolean 使用示例：\ndefine x,y string let x = \u0026#34;darcyjoven\u0026#34; let y = \u0026#34;darcy\u0026#34; if x.equals(y) then display \u0026#34;OK\u0026#34; end if 相比equals，我们更经常用的比较字符串的方式是用==或者=直接判断。 例如：\ndefine x,y string let x = \u0026#34;darcyjoven\u0026#34; let y = \u0026#34;darcy\u0026#34; if x == y then display \u0026#34;OK\u0026#34; end if 两只的区别是当两侧的值都为空值时，equals比较的结果是真，==比较的结果是假。\nstring类型还有一个忽略大小写比较的方法，equalsIgnoreCase用法和equals一致\n取子字符串/字符\r#\r用例：\ndefine s,a,b string let s = \u0026#34;darcyjoven@gmail.com\u0026#34; let a = s.getCharAt(11) let b = s.subString(1,10) 需要注意的是，字符串第一个字符的位置是1。\n获取字符串长度\r#\rdefine s string define a,b integer let s = \u0026#34;darcyjoven \u0026#34; let a = s.getLength() let b = length(s) display sfmt(\u0026#34;s.getLength() = %1 length(s) = %2\u0026#34;,a,b) 除了string的方法getLength()，BDL还有一个内置的函数lenght(s string) returning l integer可以获取字符串的长度。\n请编译以上代码，比较两只的区别。\n大小写转换\r#\rdefine s string let s = \u0026#34;DarcyJoven\u0026#34; let s = s.toLowerCase() display sfmt(\u0026#34;\\nmy name is %1\u0026#34;,s) let s = s.toUpperCase() display sfmt(\u0026#34;my name is %1\u0026#34;,s) 去除空格\r#\rdefine a,b string let a = \u0026#34; darcy joven\u0026#39;s email is darcyjoven@gmail.com \u0026#34; let b = a.trim() display b let b = a.trimLeft() display b let b = a.trimRight() display b 其它常见字符串操作\r#\r一些常用的字符串操作，一些字符串操作要借助其它数据类型，或者其它函数。\n这里介绍几种非常常用的用法。\n替代字符串\r#\r替代字符串是将原字符串中含有的部分字符串替换为新字符串，如果没有的话，仍输出原有字符串。\n此方法在string类型中没有，需要借助base.StringBuffer字符串流类型处理。\n使用办法：\ndefine buf base.StringBuffer let buf = base.StringBuffer.create() call buf.append(\u0026#34;darcyjoven@gamil.cn\u0026#34;) call buf.replace(\u0026#34;cn\u0026#34;,\u0026#34;com\u0026#34;,0) -- 0 代表，要全部替换 ，其它正整数n，代表替换前n个 display buf.toString() 因为这个使用场景实在太多，tiptop产品依据替我们封装在了lib函数中。\ntiptop gp\rcall cl_replace_init() -- 调用此函数表示全部替换，默认调用 call cl_replace_once() -- 调用此函数表示只替换一个 call cl_replace(\u0026#34;darcyjoven@gmail.cn\u0026#34;,\u0026#34;cn\u0026#34;,\u0026#34;com\u0026#34;) T100\r字符串分割\r#\r字符串分割是将一个字符串依据一个字符/字符串（分割符号）分割为多个子字符串。\n此操作需要借助base.StringTokenizer类型。\n子字符串中不包含分隔符\n示例：\ndefine s string define tok base.StringTokenizer let s = \u0026#34;darcyjoven@gmail.com;darcy_joven@live.com;darcy_joven@163.com;\u0026#34; let tok = base.StringTokenizer.create(s,\u0026#34;;\u0026#34;) while tok.hasMoreToken() display tok.nextToken() end while tok.hasMoreToken()判断是否还有值，如果有值，可以利用tok.nextToken()将下一个值取出来。\n需要注意的是tok.nextToken()取值的时候，会自动切换到下一个值，所以base.StringTokenizer只能顺序操作，不能返回上一个值操作。\n"},{"id":4,"href":"/docs/BDL/2.medium/11.array/1.what-is-array/","title":"1.什么是数组","section":"第十一章 数组-同一类型的多个元素的集合","content":"\r什么是数组\r#\r程序经常使用同类型的数据，比如要处理某个班级的学生成绩信息，如果只有几个学生，我们可以使用几个同类型的变量，比如：define mark0, mark1, mark2, mark3, mark4 integer;` 这样，便可以存放5个学生的成绩，但如果是几百人呢?要一直这么写下去吗?如果读者觉得继续写下去没什么不妥的话，那几千甚至几万人呢!所以，如何合理组织大量同类数据是个问题。\n在这种应用背景下，数组应运而生，成功解决了上述问题。\n数组是一大片连续的存储空间\r#\r声明一个数组时，编译器为数组分配内存存储空间，以存放多个同型数据。每个数据称为数组的一个元素，要存储的元素个数称为数组的大小，元素的类型称为数组的类型。数据占据的内存空间大小取决于数组的大小和类型，而且，编译器为数组分配一片连续的内存空间。很容易计算数组占据的内存大小和每个元素对应的内存首地址。\n下图，形象地示意了数组占据内存空间的情况，其中每个小方框代表一个内存字节，smallint占据2个内存字节，因此，数组中每个元素占据2个内存字节。\n数组元素的访问\r#\r下面来看要解决的第2个问题“每个数据应当有唯一的标识符进行读写和查找”，这是通过下标来实现的。以一-维数组为例，元素的访问形式为:\n数组名[下标] 举例来说，有一个数组，名为mark,里面记录着全班60个人的成绩，mark中的第1个元素可写为mark[1]，第2个元素为mark[2]，第3个元素为mark[3]，以此类推，第60个元素为mark[60]，好了，结束。有效的下标为1到N,不在此范围的下标访问都会引发越界错误。 线界错误是初学者经常犯错的地方。\n了解了数组的基本组织形式，下面具体看一下如何使用数组解决实际问题。\n"},{"id":5,"href":"/docs/BDL/2.medium/10.function/1.what-is-function/","title":"1.什么是函数","section":"第十章 函数入门-写程序就是写函数","content":"\r什么是函数\u0026ndash;根据输入进行处理返回输出\r#\r代码编多了会发现一个问题:一些通用的操作，比如交换两个变量的值、对一组变量进行排序等，可能在多个程序中都会用到，不仅如此，在单独一个程序中也可能会对某个代码段执行多次。\n问题\n有必要在每次执行时都把该代码段书写一次吗?这不仅会让程序变得很长，而且难以理解，使可读性下降。\n分割\r#\r为了解决以上问题，C语言将程序按功能分割成-.系列的小模块，所谓“小模块”，可理解为完成-定功能的可执行代码块，称之为“函数”。\n函数是BDL语言源程序的基本功能单位，打个比方，可以将函数视为一个黑盒子，或“加工设备”，从一头输人数据(原材料),从另一头就可以得到结果(产品)。至于函数内部是如何工作的，外部并不关心。 C语言源程序均是由函数组成的，在前面章节中给出的示例代码，只有一个main函数，这仅适用于比较简单的问题，实际的程序往往由多个函数组成。函数的调用是由另\u0026ndash;个函数发起的，举例来说，在A函数中调用B函数，从B函数的角度上说，A函数可视为外部函数,外部函数A对“函数B是如何定义的，功能是如何实现的”毫不关心，A对B所知道的仅限于输入给B什么，以及B输出什么。\n标准函数、lib/sub函数和自定义函数\r#\r为了方便解决一些基本问题，BDL语言提供了一些标准函数。 除此之外，tiptop gp和T100都集成了一些经常使用的函数。\n注意这是产品提供的，不是BDL语言提供的，可以被修改，增加。\n除了上述函数外，BDL也允许用户自定义函数以便灵活解决各种问题，用户可以将自己的算法编写为一个个相对独立的函数模块，用调用的方法来使用函数。\n从某种程度上说，BDL全部功能都是由这样或那样的函数实现的。\n"},{"id":6,"href":"/docs/Practice/basic/","title":"基础练习题","section":"BDL练习题","content":"\r基础练习题\r#\r基础练习题目，并不是指难度基础，而是不涉及到除了语言特性其它的范围。\n不涉及到画面规格（GUI）、和数据库等，专注于 BDL 基础语法。\n反而某些题目难度可能很大，不必强求所有题目都能解出，果断时间再来看，可能就可以解出了。\n第 1 题\r#\r题目： 有 1、2、3、4 四个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？\n程序分析： 可填在百位、十位、个位的数字都是 1、2、3、4，组成所有的排列后再去掉不满足条件的排列。\r第 2 题\r#\r题目： 企业发放的奖金根据利润提成。\n利润(I)低于或等于 10 万元时，奖金可提 10%； 利润高于 10 万元，低于 20 万元时，低于 10 万元的部分按 10%提成，高于 10 万元的部分，可提+ 成 7.5%； 20 万到 40 万之间时，高于 20 万元的部分，可提成 5%； 40 万到 60 万之间时高于 40 万元的部分，可提成 3%； 60 万到 100 万之间时，高于 60 万元的部分，可提成 1.5%； 高于 100 万元时，超过 100 万元的部分按 1%提成。 从键盘输入当月利润 I，求应发放奖金总数？ 程序分析： 请利用数轴来分界，定位。注意定义时需把奖金定义成双精度浮点(double)型。\r第 3 题\r#\r题目： 一个整数，它加上 100 后是一个完全平方数，再加上 168 又是一个完全平方数，请问该数是多少？\n程序分析： 假设该数为 x。\n则：x + 100 = n2, x + 100 + 168 = m2 计算等式：m2 - n2 = (m + n)(m - n) = 168 设置： m + n = i，m - n = j，i * j =168，i 和 j 至少一个是偶数 可得： m = (i + j) / 2， n = (i - j) / 2，i 和 j 要么都是偶数，要么都是奇数。 从 3 和 4 推导可知道，i 与 j 均是大于等于 2 的偶数。 由于 i * j = 168， j\u0026gt;=2，则 1 \u0026lt; i \u0026lt; 168 / 2 + 1。 接下来将 i 的所有数字循环计算即可。 第 4 题\r#\r题目： 输入某年某月某日，判断这一天是这一年的第几天？\n程序分析： 以 3 月 5 日为例，应该先把前两个月的加起来，然后再加上 5 天即本年的第几天，特殊情况，闰年且输入月份大于 3 时需考虑多加一天。\r第 5 题\r#\r题目： 输入三个整数 x,y,z，请把这三个数由小到大输出。\n程序分析： 我们想办法把最小的数放到 x 上，先将 x 与 y 进行比较，如果 x\u0026gt;y 则将 x 与 y 的值进行交换，然后再用 x 与 z 进行比较，如果 x\u0026gt;z 则将 x 与 z 的值进行交换，这样能使 x 最小。\r第 6 题\r#\r题目： 用*号输出字母 C 的图案。\n程序分析： 可先用\u0026rsquo;*\u0026lsquo;号在纸上写出字母 C，再分行输出。\r第 7 题\r#\r题目： 打印楼梯，同时在楼梯上方打印两个笑脸。\n程序分析：\n用 i 控制行，j 来控制列，j 根据 i 的变化来控制输出黑方格的个数。\n:):)\r##\r####\r######\r########\r##########\r############ 第 8 题\r#\r题目： 输出 9*9 口诀。\n程序分析： 分行与列考虑，共 9 行 9 列，i 控制行，j 控制列。\r第 9 题\r#\r题目： 古典问题（兔子生崽）：有一对兔子，从出生后第 3 个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？（输出前 40 个月即可）\n程序分析： 兔子的规律为数列 1,1,2,3,5,8,13,21\u0026hellip;.，即下个月是上两个月之和（从第三个月开始）.\r第 10 题\r#\r题目： 判断 101 到 200 之间的素数。\n程序分析： 判断素数的方法：用一个数分别去除 2 到 sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。\r第 11 题\r#\r题目： 打印出所有的\u0026quot;水仙花数\u0026quot;，所谓\u0026quot;水仙花数\u0026quot;是指一个三位数，其各位数字立方和等于该数 本身。例如：153 是一个\u0026quot;水仙花数\u0026quot;，因为 153=1 的三次方＋ 5 的三次方＋ 3 的三次方。\n程序分析： 利用 for 循环控制 100-999 个数，每个数分解出个位，十位，百位。\r第 12 题\r#\r题目： 将一个正整数分解质因数。例如：输入 90,打印出 90=2*3*3*5。\n程序分析： 对 n 进行分解质因数，应先找到一个最小的质数 k，然后按下述步骤完成：\n如果这个质数恰等于（小于的时候，继续执行循环）n，则说明分解质因数的过程已经结束，另外 打印出即可。 但 n 能被 k 整除，则应打印出 k 的值，并用 n 除以 k 的商,作为新的正整数 n.重复执行第二步。 如果 n 不能被 k 整除，则用 k+1 作为 k 的值,重复执行第一步。 第 13 题\r#\r题目： 利用条件运算符的嵌套来完成此题：学习成绩\u0026gt;=90 分的同学用 A 表示，60-89 分之间的用 B 表示，60 分以下的用 C 表示。\n程序分析： iif(a\u0026gt;b,a,b) 这是条件运算符的基本例子。\r第 14 题\r#\r题目： 输入两个正整数 m 和 n，求其最大公约数和最小公倍数。\n程序分析：\n最小公倍数=输入的两个数之积除于它们的最大公约数，关键是求出最大公约数；\n求最大公约数用辗转相除法（又名欧几里德算法）\n证明：设 c 是 a 和 b 的最大公约数，记为 c=gcd(a,b),a\u0026gt;=b, 令 r=a mod b 设 a=kc，b=jc，则 k，j 互素，否则 c 不是最大公约数 据上，r=a-mb=kc-mjc=(k-mj)c 可知 r 也是 c 的倍数，且 k-mj 与 j 互素，否则与前述 k，j 互素矛盾, 由此可知，b 与 r 的最大公约数也是 c，即 gcd(a,b)=gcd(b,a mod b)，得证。\n算法描述：\n第一步：a ÷ b，令 r 为所得余数（0≤r 第二步：互换：置 a←b，b←r，并返回第一步。\n第 16 题\r#\r题目： 输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。\n程序分析： 取字符串第几位。\r第 18 题\r#\r题目： 求 s=a+aa+aaa+aaaa+aa\u0026hellip;a 的值，其中 a 是一个数字由键盘输入。 例如 2+22+222+2222+22222(此时共有 5 个数相加)，几个数相加由键盘输入。\n程序分析： 关键是计算出每一项的值。\r第 19 题\r#\r题目： 一个数如果恰好等于它的因子之和，这个数就称为\u0026quot;完数\u0026quot;。例如 6=1 ＋ 2 ＋ 3.编程找出 1000 以内的所有完数。\n程序分析： 参考正整数分解质因数\r第 20 题\r#\r题目： 一球从 100 米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第 10 次落地时，共经过多少米？第 10 次反弹多高？\n第 21 题\r#\r题目： 猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个 第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下 的一半零一个。到第 10 天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。\n程序分析： 采取逆向思维的方法，从后往前推断。\n设 x1 为前一天桃子数，设 x2 为第二天桃子数， 则： x2=x1/2-1, x1=(x2+1)*2\nx3=x2/2-1, x2=(x3+1)*2\n以此类推： x 前=(x 后+1)*2\n从第 10 天可以类推到第 1 天，是一个循环过程。 第 22 题\r#\r问题： 两个乒乓球队进行比赛，各出三人。甲队为 a,b,c 三人，乙队为 x,y,z 三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a 说他不和 x 比，c 说他不和 x,z 比，请编程序找出三队赛手的名单。\n第 23 题\r#\r题目： 打印出如下图案（菱形）。\n*\r***\r*****\r*******\r*****\r***\r*\r程序分析： 先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重 for 循环，第一层控制行，第二层控制列。\r第 24 题\r#\r题目： 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13\u0026hellip;求出这个数列的前 20 项之和。 程序分析： 请抓住分子与分母的变化规律。\r第 25 题\r#\r题目： 求 1+2!+3!+\u0026hellip;+20!的和。 程序分析： 此程序只是把累加变成了累乘。\r第 26 题\r#\r题目： 利用递归方法求 5!。 程序分析： 递归公式：fn=fn_1*4!\r第 27 题\r#\r题目： 利用递归函数调用方式，将所输入的 5 个字符，以相反顺序打印出来。\n第 28 题\r#\r题目： 有 5 个人坐在一起，问第五个人多少岁？他说比第 4 个人大 2 岁。问第 4 个人岁数，他说比第 3 个人大 2 岁。问第三个人，又说比第 2 人大两岁。问第 2 个人，说比第一个人大两岁。最后问第一个人，他说是 10 岁。请问第五个人多大？ 程序分析： 利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10 岁），再往回推。\r第 29 题\r#\r题目： 给一个不多于 5 位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。 程序分析： 学会分解出每一位数。\r第 30 题\r#\r题目： 一个 5 位数，判断它是不是回文数。即 12321 是回文数，个位与万位相同，十位与千位相同。 程序分析： 学会分解出每一位数。\r第 31 题\r#\r题目： 请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。 程序分析： 用情况语句比较好，如果第一个字母一样，则判断用情况语句或 if 语句判断第二个字母\r第 32 题\r#\r题目： 删除一个字符串中的指定字母，如：字符串 \u0026ldquo;aca\u0026rdquo;，删除其中的 a 字母。\n第 33 题\r#\r题目： 判断一个数字是否为质数。 程序分析： 质数（prime number）又称素数，有无限个。一个大于 1 的自然数，除了 1 和它本身外，不能被其他自然数整除。\r第 34 题\r#\r题目： 字符串反转，如将字符串 \u0026ldquo;\rwww.runoob.com\u0026rdquo; 反转为 \u0026ldquo;moc.boonur.www\u0026rdquo;。\n第 35 题\r#\r题目： 求 100 之内的素数。 程序分析：\n质数（prime number）又称素数，有无限个。一个大于 1 的自然数，除了 1 和它本身外，不能被其他自然数整除。\n第 36 题\r#\r**题目：**对 10 个数进行排序。 程序分析：\n可以利用选择法，即从后 9 个比较过程中，选择一个最小的与第一个元素交换， 下次类推，即用第二个元素与后 8 个进行比较，并进行交换。\n第 37 题\r#\r**题目：**求一个 3*3 矩阵对角线元素之和 程序分析：\n利用双重 for 循环控制输入二维数组，再将 a[i,i]累加后输出。\n第 38 题\r#\r**题目：**有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。 程序分析：\n首先判断此数是否大于最后一个数,然后再考虑插入中间的数的情况,插入后此元素之后的数,依次后移一个位置。\n第 39 题\r#\r**题目：**将一个数组逆序输出。 程序分析：\n用第一个与最后一个交换。\n第 40 题\r#\r**题目：**打印出杨辉三角形（要求打印出 10 行）。 程序分析：\n结构如下：\n1\r1 1\r1 2 1\r1 3 3 1\r1 4 6 4 1 第 41 题\r#\r**题目：**输入 3 个数 a,b,c，按大小顺序输出。\n第 42 题\r#\r题目： 输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。\n第 43 题\r#\r**题目：**有 n 个整数，使其前面各数顺序向后移 m 个位置，最后 m 个数变成最前面的 m 个数。 程序分析：\n可以使用一个辅助数组来保存需要移动的元素，然后再将元素按照要求移动到正确的位置。\n第 44 题\r#\r题目： 有 n 个人围成一圈，顺序排号。从第一个人开始报数（从 1 到 3 报数），凡报到 3 的人退出圈子，问最后留下的是原来第几号的那位。\n第 45 题\r#\r题目：\n写一个函数，求一个字符串的长度，在 main 函数中输入字符串，并输出其长度。 程序分析：\r第 46 题\r#\r题目： 编写 input()和 output()函数输入，输出 5 个学生的数据记录。\n程序分析：\n学生信息包括姓名、性别、年纪。请用 record 实现。\n第 47 题\r#\r**题目：**输入一个整数，并将其反转后输出。 程序分析：\n拆分每一位\n第 48 题\r#\r题目： 编写一个函数，输入 n 为偶数时，调用函数求 1/2+1/4+\u0026hellip;+1/n,当输入 n 为奇数时，调用函数 1/1+1/3+\u0026hellip;+1/n(利用指针函数)。\n第 49 题\r#\r题目： 海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只 猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了 一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的， 问海滩上原来最少有多少个桃子？\n第 50 题\r#\r题目： 809*??=800*??+9*?? 其中??代表的两位数, 809*??为四位数，8*??的结果为两位数，9*??的结果为 3 位数。求??代表的两位数，及 809*??后的结果。\n第 51 题\r#\r**题目：**八进制转换为十进制\n第 52 题\r#\r题目： 求 0—7 所能组成的奇数个数。 程序分析：\n这个问题其实是一个排列组合的问题，设这个数为 sun=a1a2a3a4a5a6a7a8,a1-a8 表示这个数的某位的数值，当一个数的最后一位为奇数时，那么这个数一定为奇数，不管前面几位是什么数字。如果最后一位数为偶数，则这个数一定为偶数。\na1-a8 可以取 0-7 这个八个数字，首位数字不为 0。 从该数为一位数到该数为 8 位数开始统计奇数的个数：\n当只有一位数时也就是该数的最后一位，奇数个数为 4\n当该数为两位数时，奇数个数为 4*7=28\n当该数为三位数时，奇数个数为：487=224\n\u0026hellip;\n当该数为八位数时，奇数个数为：4888888*7(依次为最后一位到第一位)\n第 53 题\r#\r题目： 一个偶数总能表示为两个素数之和。 程序分析：\n我去，这是什么题目，要我证明这个问题吗？真不知道怎么证明。那就把一个偶数分解成两个素数吧。\n第 54 题\r#\r题目：\n判断一个素数能被几个 9 整除。\n程序分析：\n丫的！这题目的意思是判断一个素数能整除几个 9 组成的数吧？我就这么理解吧。素数是不 能被除 1 和自身之外的数整除的\n第 55 题\r#\r题目： 程序分析：\r第 56 题\r#\r题目： 读取 7 个数（1—50）的整数值，每读取一个值，程序打印出该值个数的 ＊。\n第 57 题\r#\r题目： 某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下： 每位数字都加上 5,然后用和除以 10 的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。\n第 58 题\r#\r题目： 猜数字游戏，用户可以输入数字，提示用户输入的数字是大了，还是小了。 猜中后提示一共猜了多少次，并可以选择是否继续猜数字。\n第 59 题\r#\r题目： 从键盘输入一个字符串，将小写字母全部转换成大写字母，然后输出到一个磁盘文件\u0026quot;test\u0026quot;中保存。 输入的字符串以！结束。\n第 60 题\r#\r题目： 有两个磁盘文件 A 和 B,各存放一行字母，要求把这两个文件中的信息合并（按字母顺序排列），输出到一个新文件 C 中。\n程序分析：\n你需要先创建 A.txt 与 B.txt。 A.txt 文件内容：\n123\rB.txt 文件内容：\n456\r第 61 题\r#\r题目： 程序分析：\r第 62 题\r#\r题目： 有五个学生，每个学生有 3 门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，况原有的数据和计算出的平均分数存放在磁盘文件\u0026quot;stud\u0026quot;中。\n"},{"id":7,"href":"/docs/BDL/1.basic/9.over_and_over_again/1.create-cycle/","title":"1.构造循环","section":"第九章 循环结构--一遍又一遍","content":"\r构造循环\r#\r循环结构有两大要素:循环条件和循环体，当满足某个条件时，重复执行某些动作，直到该条件不再满足，这个表述很好地体现了循环条件和循环体的关系。\n构造循环时，首先应明白要做什么，即“循环体是什么”，这是和程序的目的相关的。知道要干什么了还不够，还要明白什么时候开始做，什么时候停，如果没有设定合理的循环条件，很容易造成程序死循环，至使资源耗尽而导致电脑死机。\n举个最简单的例子，要求计算从1加到100，因为本章讨论的是循环，所以我们撇开高斯的简便方法((1+100)*50=5050)。\n程序的编写采用如下形式显然是不现实的:sum=1+2+3+.....+100写完这个式子就够费劲的，还好只有100个，要是有成千上万个，活活要累个半死。\n在这种应用背景下，需要使用循环结构，只要一小段代码，如下。\ndefine i,sum integer while i\u0026lt;=100 let sum = sum + i let i = i + 1 end while display sfmt(\u0026#34;\\n结果是：%1\u0026#34;,sum) 输出结果是结果是：5050。\n代码解析\n代码中采用的是while结构，i作为加数，sum作为被加数，用以保存结果，程序的关键部分是第3~4行。\ni的初始值为1，当i小于等于100时( 循环条件)，会重复执行循环体，在循环体内做了两件事情，- -是将i和sum相加，结果重新保存到sum中，二是将i增加1，一步步逼近循环结束的条件。\n由此可知，循环条件和循环体相互配合完成特定的功能。一次次的循环，距离循环结束 应越来越近，避免出现死循环，试想，如果循环体中只是完成let sum=sum+i 这一操，而不对i进行修改，那么循环条件i\u0026lt;=100 的条件将一 直满足，循环永不会终止。\n注意 在代码中，即使要计算1加到10000，只要将100修改为10000即可，十分方便快捷。\r语法规则\r#\rwhile 表达式 循环结构体 end while 在while结构中，表达式既可以是逻辑表达式或关系表达式，也可以是普通表达式，甚至常量或变量，判断的关键这个值是否为真（非0），下面看一下表达式仅是个变量的示例：\ndefine sum,i integer let i =100 while i let sum = sum + i let i = i -1 end while display sfmt(\u0026#34;\\n结果是：%1\u0026#34;,sum) 编译运行后结果为：\n结果是：5050 代码解析\n两种代码实现了同样的结果，第二种i初始值为100，在循环体结构中逐次-1，知道i变为0，循环条件不满足，程序退出，完成了1+2+3+...+100的计算。\n"},{"id":8,"href":"/docs/BDL/1.basic/8.condition/1.judgment-statement-if/","title":"1.if语句--简单条件判断","section":"第八章 条件判断-分支结构","content":"\rif语句\u0026ndash;简单条件判断\r#\r生活中充满了选择，在BDL语言编程中同样如此。 最简单的条件判断语句是if语句，其基本格式为：\nif 判断表达式 then\r语句1\r语句2\r...\rend if 判断表达式\r#\r判断表达式可以是简单的逻辑语句(逻辑表达式或关系表达式)，可以是多个逻辑语句的“与”、“或”、“非”组合，也可以是一般表达式，甚至还可以是一个变量或常量。\n执行到if结构时，该表达式的值被首先计算，当判断表达式的值不为0 (真) 时，if then后花括号中的结构体代码被执行，否则，跳过if end if中的代码。\n做个形象的比方，在街上购物的时候，看到某件商品，常常会这样想:如果不高于50块，就买下了，否则，就继续逛街。用if结构可表述为:\nif 商品价格\u0026lt;50 then\r买下它\rend if 看一下下列代码:\ndefine price integer prompt \u0026#34;请输入商品价格（正整数）：\u0026#34; for price if price \u0026lt; 50 then display \u0026#34;\\n好，买好了\u0026#34; end if 当输入的金额小于50时，控制台输出的结果为\n好，买好了 否则为空。\n"},{"id":9,"href":"/docs/BDL/1.basic/7.atoml_statement/1.statement-type/","title":"1.语句类型","section":"第七章 语句-程序最小构成单元","content":"\r语句类型\r#\r前文已经介绍过，BDL中有4中类型的语句，分别是表达式语句、流程控制语句、函数调用语句和符和语句。\nflowchart LR\ra[\"BDL语言\"]\rb1[\"表达式语句\"]\rb2[\"函数调用语句\"]\rb3[\"复合语句\"]\rb4[\"流程控制语句\"]\rc1[\"运算符表达式语句\"]\rc2[\"赋值语句\"]\rc3[\"结构化语句\"]\rc4[\"非结构化语句\"]\rd1[\"条件语句\"]\rd2[\"循环语句\"]\rd3[\"限定转向语句\"]\rd4[\"非限定转向语句\"]\re1[\"if语句\"]\re2[\"case语句\"]\re3[\"while语句\"]\re4[\"for语句\"]\re5[\"break语句\"]\re6[\"continue语句\"]\re7[\"return语句\"]\re8[\"goto语句\"]\ra--\u003eb1\ra--\u003eb2\ra--\u003eb3\ra--\u003eb4\rb1--\u003ec1\rb1--\u003ec2\rb4--\u003ec3\rb4--\u003ec4\rc3--\u003ed1\rc3--\u003ed2\rc4--\u003ed3\rc4--\u003ed4\rd1--\u003ee1\rd1--\u003ee2\rd2--\u003ee3\rd2--\u003ee4\rd3--\u003ee5\rd3--\u003ee6\rd3--\u003ee7\rd4--\u003ee8\r表达式语句\r#\r在上一章，我们已经介绍了表达式的概念，通俗说，“有表达式组成的语句叫做表达式语句”。\n表达式语句只有一种赋值表达式，在BDL中不允许计算一个值而不使用。\n下属语句都是赋值语句：\nlet x = 3 let x = x + 1 let y = 1 \u0026gt; 2 函数调用语句\r#\r以下语句都是函数调用语句。\ncall add() call minux() returning x 复合语句\r#\r以下语句是调用函数后，将函数的值赋值给变量。 即使函数调用右是赋值语句。\nlet x = add (a,b)\rlet y = sfmt(\u0026#34;today is %1\u0026#34;,today) 流程控制语句\r#\r从前面流程图，可以看到流程控制语句最为茂盛，这是本章的关键点。 到目前位置，所接触的代码都是顺序执行的，按语句的书写顺序从上向下一条条执行，如：\n语句1 语句2 语句3 在实际应用中，程序并不一定按书写的顺序来执行，可能希望在某处设置多条路径，由程 序选择一条来执行。 以人爬山来类比，上山可能有多条路，在分岔口处需要登山者做出选择，如果体力状态不错，可以选坡陡难爬的一条路，如果很疲劳了，可以选平缓容易的路，或者干脆下山。 这种选择机制提供了解决问题的灵活性。\n说明 有时程序希望对某块代码重复多次执行，按顺序方式将这块代码复制、粘贴多次是很笨的方法，且无法控制循环的次数。\r能否引入一些控制结构，以解决选择和重复执行的问题，“流程控制”应运而生。 流程控制语句分为结构化语句和非结构化语句两部分，结构化语句包含条件语句(处理分支情况)和循环语句(处理重复情况)，而非结构化语句用于一些特殊的跳转，有一种“便捷通道”的味道。继续讨论流程控制前，先来看一下BDL语言的结构化和算法。\n"},{"id":10,"href":"/docs/BDL/1.basic/6.operators_and_expressions/1.operators/","title":"1.运算符和表达式","section":"第六章 运算符和表达式-程序基本构成","content":"\r认识BDL语言中的运算符和表达式\r#\r在前面的章节中，已经接触过运算符和表达式了。 可以说，运算符和表达式是BDL语言的最基本构成，没有运算符和表达式，则不能编写任何程序。 程序的任务是对数据进行处理，数据是程序处理的对象，而运算符是施加给这些数据的操作。数据和运算符是表达式的基本元素。\n认识运算符和表达式\r#\r最近本的运算符，莫过于加、减、乘、除四则运算了\n1+1\r2*4\r10-20\r100/3 由于键盘无法输出算数中的乘号(✖)，和出号(➗)，改用*和、代替。删改你的例子都是常量参与运算，在BDL中，变量也可以参与运算，如：\ndefine a,b,c integer let a = 0 let b = 10 b - a a +b +10 a+b+10/b 上面的每一个式子都可以称为一个表达式。 BDL中的算术表达式和普通算术中的表达式写法基本一样，运算符两边是参与运算的对象，非常容易理解； 而有些语言，其表达式的写法非常古怪，让人望而生畏。 同样地，算术运算中，除数是不能为0的，在计算机中，如果除数为0，将产生一个“除数为0的异常”。 所以上面的示例中，有一个表达式因为除数为0，将使得程序运行崩溃。\n另外在给变量赋值的时候，使用赋值运算符=，如：\nlet a = a+b+10/b let b = a+b+10 在介绍这个运算符的时候，特别强调了它和算术运算中的等号“=”的区别。 BDL中的“=”，是将右边的值赋给左边的变量，而并不表示等号两边相等。 在BDL中，要表示两边是否相等，可用“==”表示（你也可能见到过使用一个“=”比较大小的，这样语法也没问题，但建议使用两个），即两个等号连接在一起，用来检查等号两边是否相等。 类似这种进行两个对象的大小关系比较的运算，是一种关系运算。\n操作数、运算符和表达式\r#\r参与运算的对象称做操作数（operator）。 如3+5中的3和5，a+b+10中的a，b和10，他们是参与具体预算的对象。同样地：\n(3+5)*a 这个表达式中，对于运算符“*”，两边的操作数就分别是(3+5)和a。 可见，操作数也可以是比较复杂的对象。 3+5也可以看做是一个加法表达式。\n运算符是指定要执行某项操作的一个标志符号，它指明了对操作数所进行的运算。 如“+”号，表示了一个相加运算;“==” 号表示了一个关系判断是否“ 相等”的运算。 表达式表示一个求值的规则。 表达式是由变量、常量、运算符、函数和圆括号按一定的规则组合而成的。 BDL语言的表达式可根据运算的不同而分为不同的表达式类型，如算术表达式、关系表达式、函数表达式等。一般来说，表达式有如下的书写规则。\n运算符不能相邻。如a+-b是错误的。 乘号不能省略。如x乘以y应写成: x*y， 不能写成xy。 可用多层括号表示运算次序，括号必须成对出现，均使用小括号。 注意\n一个常量，例如390，也可以说是一个表达式；同样，一个变量x，也可以说是一个表达式。\rBDL运算符简介\r#\rBDL语言的内部运算符很丰富，范围也很宽。 运算符告诉编译器去执行特定的算术或逻辑操作。 BDL语言有两大类运算符:算术、关系与逻辑。 另外，BDL还有一些特殊的运算符，用于完成一些特殊的任务。 如下：\n关系运算符\n运算符 描述 is null 判断控制 like 如果字符串和给定的格式匹配成功返回true matches 如果字符串和给定的格式匹配成功返回true 相同(==or=) 判断两个值是否相同 不相同(!=or\u0026lt;\u0026gt;) 判断两个值是否不相同 小于\u0026lt; 判断左边的值小于右边 小于等于\u0026lt;= 判断左边的值小于等于右边 大于\u0026gt; 判断左边的值大于右边 大于等于\u0026gt;= 判断左边的值大于等于右边 nvl() 如果第一参数为空，返回第二个参数 iif() 如果第一个参数为true,返回第二个参数，否则返回第三个参数 in() 判断值是否在一个范围内 逻辑运算符\n运算符 描述 not 如果右边表示大为true返回false，如果为flase，返回true and 如果左边和右边表达式都为true,返回true,否则false or 如果左边和右边表达式都为false,返回false,否则true 算数运算符\n运算符 描述 + 左加右 - 左减右 * 两数相乘 / 左除以右 ** 计算幂 mod 左边对右边求余数 字符串运算符\n运算符 描述 ascii() 依据ascii码变为字符 column 生成空行 ` using 格式化 clipped 去掉尾部空格 ord() 依据字符变为ascii码 spaces 空格 lstr() 本地化字符串 sfmt() 根据占位符替换值 关联语句运算符\n运算符 描述 () 设置运算符优先顺序 . 对象成员分割符 [] 数组索引下标 交互运算符\n运算符 描述 get_fldbuf() 返回指定字段当前值 infield() 判断是否在指定栏位 field_touched() 判断执行栏位是否修改过 "},{"id":11,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/1.input-proces-output/","title":"1.输出-处理-输出","section":"第五章 利用键盘、鼠标与程序交互","content":"\r输出-处理-输出\u0026ndash;这就是程序\r#\r工厂的生产车间生产出来的产品是最终的输出。\n比如某药厂生产的保健药，号称是经历了80多道工序。 这些工序，当然是从输入原材料开始，每道工序处理-件事情，最终生产出包装精美的保健药品。\n第一道工序，清洗，输人的是刚刚采摘下来的药材，其中，有不少的烂叶子、烂根。 清洗工序处理完毕后，输出来的是干净的有用的药材。\n第二道工序，榨汁，输人的是干净有用的药材，榨汁工序处理时，添加纯净水，榨出药汁。 接着是萃取工序，将药汁中的有用的部分苹取.来\u0026hellip;.80多道工序就这样一一处理完毕， 保健 药就制作完毕。\n从进场时的原材料，到最终出产的保健药，就是一个“输入一处理一输出” 的过程。 深入到药厂中的处理部分，80多道工序，每个工序也是一个“输入- -处理一输出”的过程。 没有输入，就没有处理的素材，也就没有输出。\n程序就是这样，根据输人进行不同的处理，输入不同，处理结果不同，这就是程序。 没有输出的程序是没有用的;没有输入的程序，缺乏灵活性，因为运行一次后，由于处理的数据相同，下一次运行结果也\u0026ndash;样，而程序在多次运行时，用到的数据可能是不同的。\n在程序运行时，由用户临时根据情况输人所需的数据，可以提高程序的通用性，增加程序的利用价值。\nBDL语言中有多种多样的输出方式，大部分是封装好的函数，只要调用就可以将结果输出出来。之前我们使用的display后面直接方变量或者直接写的字符串数字，就可以将结果直接打印输出到控制到命令行。本章我们还会介绍输入和其它输出方式。\n"},{"id":12,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/1.binary-octal-hexadecimal/","title":"1.二进制、八进制、十六进制","section":"第四章 存储和获取数据","content":"\r二进制、八进制、十六进制\r#\r二进制、八进制和十六进制是计算机中常用的进制形式。N进制的算法就是逢N进1。\n二进制 二进制数使用0和1两个数码来表示的书，如111110112表示二进制。它的基数是2，进位规则是“逢二进一”。\n八进制 八进制是用0~7 8个数码来表示的数，如1678,进为规则是“逢八进一”。\n十六进制 十六进制是用0~9和A~F 16个字符表示，如1AE16,它的基数是16,进为规则为“逢16进1”。\n"},{"id":13,"href":"/docs/BDL/1.basic/3.composition_of_bdl/1.BDL-look/","title":"1.BDL程序全貌","section":"第三章 最简单bdl程序的组成","content":"\rBDL程序全貌\r#\rdatabase ds main display sfmt(\u0026#34;hello world\u0026#34;) end main 代码很短，只有几行就建立一个可运行的程序。 代码虽小，但五脏俱全，纵观整个代码，可以总结如下特点：\n代码有单词、符号、空白组成。 单次以英语单次为主有的单词是纯正的英语单词，如main、display、end、database；有的不是如sfmt。代码中的标点符号并不是随意输入的。 每个符号在编程中都有特定函数。 单词于单词之间用空白分割，空白可以是空格，也可以是tab制表符。个数没有限制\nBDL源码是从上往下阅读，也就是源码的先后顺序是由讲究的。 行与行之前可以有空白行，数量也没有显示。 有的行顶格书写，有的却向后退了几个空格，这种后退，成为“缩进”。如何缩进也是有讲究的。\n并没有专门的标识标识文件从哪里开始，也没标识文件从哪里结束。从第一个字符开始，文件就开始了，到最后一个字符结束，文件就结束了。\n"},{"id":14,"href":"/docs/BDL/1.basic/2.first_code/1.wirte-program-by-youself/","title":"1.自己动手创建程序","section":"第二章 第一行代码","content":"\r自己动手创建程序\r#\r就像小学生解决应用题一样，在答题之前，必须了解题目给的条件，然后明确题目的问题，最后才是解题。 开发软件也需要这样一个过程，必须先清楚用户的需求，根据需求来进行设计和开发，不遗漏需求，也不能有超过需求的功能。\n本章的目标就是创建一个可以执行的程序，并输出一句话：“Hello World”。如果读者看了这个要求就开始写代码，就烦了大忌。 这个需求起始很不明确，并没有规定如何输出这句话。 在实际的软件发开工作中，类似不明确的需求比比皆是，所以动手写代码前，一定要非常明确软件的需求。\n很多曾经有过语言学习经理的读者看见上面的需求后，第一印象，认为就是在控制台打印出这句话来，然后就开始思索如何设计程序了。 但假设用户需求是用人声读出这句话呢？发声也是一种输出！ 或者用户需求是在一个窗口界面输出这句话，甚至要求这句话的大小、样式、颜色符和某种规定，那么只在控制台打印“Hello World！”的程序是不符合要求的。 所以在开发软件前，用大量的时间进行实际需求的调研时非常有必要的。 否则，花费大量时间出来的程序可能没有任何价值。\n更明确的修去时：在控制台程序中，输出依据简单的文字：“Hello World！”。具体要求明确后就可以开始程序设计了。\n本章只是引导大家了解BDL语言，故没有输入，只有输出。\n"},{"id":15,"href":"/docs/BDL/1.basic/1.before_all/1.why-dbl/","title":"1.为什么学习（使用）BDL语言","section":"第一章 踏上征程前的思想动员","content":"\r为什么学习（使用）BDL语言\r#\r开发迅速\r#\rBDL配套的开发工具和GUI都是打包好，所以开发周期非常的端，也不需要考虑过多的事情。\n程序易读性高\r#\r如果你使用过SQL查询语言，或者对数据库有一定了解，甚至对excel使用比较熟练，你会发现BDL的处理方式与它们非常相似。\n不得不使用\r#\r你的公司使用了BDL语言的产品，现在要修改或者增加功能，不得不去读，写BDL程序。\n"},{"id":16,"href":"/docs/BDL/","title":"BDL有钱途的编程语言(tiptop)","section":"Docs","content":"\rBDL 语言发开\r#\rBusiness Development Language(BDL) 是 4js 公司 4js 开发一款商业发开软件，因为其语言后缀名为4gl，也被成为4gl语言或者fgl语言。\n鼎捷旗下tiptop gp T100系列 ERP 软件就是使用此商业语言开发。\n"},{"id":17,"href":"/docs/BDL/2.medium/14.database/2.schema/","title":"2.数据表结构在BDL中的使用","section":"第十四章 数据库使用","content":"\r数据表结构在 BDL 中的使用\r#\r在数据库中，每个表的建立都会产生表结构文件，叫做schema文件。\n在我们使用数据库时，如果你需要大量的数据中的资料，不需要频繁的查询数据中的表结构，通过表结构中字段的数据类型去对应BDL中的数据类型。在BDL中已经为我们做好了这一步，ORACLE中大部分数据类型在BDL中都映射到指定的类型。\n我们只要使用数据库的schema文件，就能通过数据的字段去定义BDL中的数据类型。\n上一章我们学到了function main() end function这种main函数写法，只会使用表结构，而不连接到数据库，指得就是使用schema文件，而不连接到数据库。\n在 BDL 中使用 schema 定义变量\r#\r只要将之前定义变量中的数据类型修改为like ds:table.cloumn 即可定义这个变量类型为 ds 库中 table 这个表的 column 这个字段在数据库中的类型。\n其中ds:库名可以省略，如果省略，表示使用当前已经连接到的库。\n例如:\ndatabase ds main define l_ima01 like ima_file.ima01 define l_ima02 like ima_file.ima02 end main 除了在使用ima_file字段时，可以依据ima_file字段的名称定义，在 TIPTOP 中，常用的字段类型都定义在了type_file中，可以根据 type_file 类型定义我们经常使用的变量，如金额、库存数量、单价这些常用变量。\ntype_file字段清单如下\n字段名称 数据类型 字段名称 数据类型 chr1000 varchar2(1000) chr6 varchar2(6) chr1 varchar2(1) chr50 varchar2(50) num5 number(5) chr37 varchar2(37) num20_6 number(20,6) chr9 varchar2(9) dat date chr12 varchar2(12) chr18 varchar2(18) chr30 varchar2(30) num10 number(10) chr14 varchar2(14) chr8 varchar2(8) chr7 varchar2(7) chr20 varchar2(20) chr10 varchar2(10) chr21 varchar2(21) chr100 varchar2(100) num20 number(20) chr200 varchar2(200) chr3 varchar2(3) chr300 varchar2(300) num26_10 number(26,10) chr500 varchar2(500) chr2 varchar2(2) blob blob chr4 varchar2(4) num15_3 number(15,3) chr5 varchar2(5) row_id varchar2(18) 进阶使用\u0026ndash;record\r#\r在实际业务中，我们经常使用的场景是，查询一个表每个字段的数据，更新/新增一个表所有字段。\n有时候一个表的字段可能是几十个，这个时候我们再每个字段去单独定义，容易出错。并且之后表有所异动时，容易遗漏修改。\nBDL为我们设计了一个可以简化整张表定义的语法。\ndefine l_ima record like ima_file.* 注意这种方式定义时，没有end record\nima_file.* 就表示这个表所有字段。必须和record配置使用。 l_ima的结构体自动就包含了ima_file中的所有字段，使用l_ima.ima01 l_ima.ima02 l_ima.ima021即可调用这些字段。\n注意事项\r#\rBDL 使用schema文件，在编译时，会自动的将schema文件中的数据类型映射到BDL中的数据类型。所以如果数据库数据类型变化，或者字段变动，那么 BDL 对应的文件也需要重新编译。\n如果重新产生 schema 文件 TIPTOP GP\rr.s2 ds #ERP服务器中运行 T100\r"},{"id":18,"href":"/docs/BDL/2.medium/13.struct/2.type/","title":"2.声明结构体类型","section":"第十三章 结构体","content":"\r声明结构体类型\r#\r在上一章节，我们定义了两个相同的结构体变量。\ndefine zhangsan record name varchar(20), age integer, email varchar(50) end record define lisi record name varchar(20), age integer, email varchar(50) end record 这两个变量成员以及每个成员的数据类型完全一样，除了成员的值其它内容都一样。\n现在成员数量少赋值一遍，还不算难，如果成员数量达到几十个的时候呢？\n如果后面我要增加一个成员，难道要先找到所有的结构体变量，一次增加吗？\n所以我们引用了一个新的功能\u0026mdash;结构体声明，关键字type，本章主要介绍它的使用方法。\n结构体如何声明\r#\r结构体声明的示例：\ntype person record name varchar(20), age integer, email varchar(50) end record 看起来和结构体变量定义完全一样，只是将define换成了type。\n我们来看看如何使用：\ntype person record name varchar(20), age integer, email varchar(50) end record define zhangsan,lisi person let zhangsan.name = \u0026#34;zhang san\u0026#34; let lisi.name = \u0026#34;li si\u0026#34; display zhangsan.name display lisi.name 我们在定义zhangsan、lisi两个结构体变量是时，直接将person当作变量类型使用，类似于integer。\n这个时候我们要增加一条成员，只要在person中增加一条即可。使用person创建的变量，自动可以访问新增加的成员。\ntype 进阶使用\r#\rtype person record name varchar(20), age integer, email varchar(50) end record 之前我们的结构体声明了person类型，也许你会好奇，为什么还要加上record和end record呢？\n因为type还可以在其它类型中使用,array、dynamic array。甚至是基础数据类型integer、string。\ntype相当于给一个数据类型，起了一个别名。\n如果一个类型我们需要重复使用，或希望之后修改方便，我们都可以先用type取别名，然后使用别民去定义变量。\n编译运行以下代码，查看运行结果。\ntype ssss string define s ssss type names dynamic array of string define class1 names define i integer let s = \u0026#34;abc d \u0026#34; let s = s.trimRight() display \u0026#34;\\n\u0026#34;||s let class1[1] = \u0026#34;zhangsan\u0026#34; let class1[2] = \u0026#34;lisi\u0026#34; let class1[3] = \u0026#34;wangwu\u0026#34; for i = 1 to 3 display sfmt(\u0026#34;name is %1\u0026#34;,class1[i]) end for "},{"id":19,"href":"/docs/BDL/2.medium/12.string/2.practice/","title":"2.练习","section":"第十二章 字符串操作","content":"\r练习\r#\r将以下数组连接起来组织为依据通顺的英语句子\r#\rdefine a array[3] of string let a[1] = \u0026#34;You\u0026#34; let a[2] = \u0026#34;Welcome\u0026#34; let a[3] = \u0026#34;Are\u0026#34; 编程实现，成绩输入系统\r#\r要求：\n依次输入学生的姓名，语文成绩、数学成绩、英语成绩 按以下格式输出该学生的信息 姓名：小明 语文：80 数学：90 英语：85\r平均分：85.00 总分：255 进阶\n如果要输入3名学生的成绩，并按上面要求输出，你会做吗？\n"},{"id":20,"href":"/docs/BDL/2.medium/11.array/2.one-dimensional-array/","title":"2.一维数组","section":"第十一章 数组-同一类型的多个元素的集合","content":"\r一维数组\r#\r一维数组也称向量，用以组织具有一维顺序关系的一组同类型数据，在使用数组前，必须先声明数组，编译器根据声明语句为其分配内存，这样数组才有意义。\n一维数组如何定义\r#\r与简单数据类型一样，数组也由关键字define定义\ndefine 数组名 array [size] of 类型 --定长数组 define 数组名 dynamic array of 类型 --动态长度数组 数组由两种形式：\n指定长度的定长数组 不指定长度动态长度数组 一位数组的访问\r#\r之前我们提过，数组越界的错误，对于定长的数组，超过原来长度的访问，或程序奔溃。对于动态长度的数组，访问未经过初始化的长度的时候，会对之前没有初始化的索引赋空值。\n我们通过一个例子看一下一位数组的访问方式：\ndefine score array [6] of integer define sum,i integer define average decimal(10,2) prompt \u0026#34;请输入第1名学生的成绩\u0026#34; for score[1] prompt \u0026#34;请输入第2名学生的成绩\u0026#34; for score[2] prompt \u0026#34;请输入第3名学生的成绩\u0026#34; for score[3] prompt \u0026#34;请输入第4名学生的成绩\u0026#34; for score[4] prompt \u0026#34;请输入第5名学生的成绩\u0026#34; for score[5] prompt \u0026#34;请输入第6名学生的成绩\u0026#34; for score[6] for i = 1 to 6 let sum = sum + score[i] end for let average = sum/6 display sfmt(\u0026#34;\\n平均成绩：%1\u0026#34;,average) 数值的初始化\r#\r上面我们说过动态数组访问超界时会将之前数组都赋值为null，如果每次都是这样，那么不小心写了一次array[1000]，那么这个数组长度之后都从1000后开始用吗？\n这个时候我们就可以用到初始化数组，将数组重新初始化为0长度（动态数组初始化为0长度，定长数组初始化为全部null值数组）。\n具体语法如下：\ncall 数组名.clear() 你一定发现了，有一个()，难道clear是一个函数吗？\n没错，clear()这类可以通过变量后面跟.调用得函数，是一种特殊函数，它只能通过指定数据类型的变量调用。\n这种特殊的函数我们称为方法，clear()是数组类型的一个方法，方法除了调用时必须跟在变量后面，其它特性与函数是一样的，可以传参，也可以返回值。\n方法这类函数都是BDL语言是定义好的，你也可以通过引入java包等方式使用，但这属于进阶内容。 当前你可认为方法都为BDL定义好，只能调用不能修改即可。\n不合法的数组操作\r#\r用一个数组对另一个数组赋值，即使两者类型一样 define a,b array[2] of integer let a[1] = 1 let a[2] = 2 let b = a 编译报错\n../42m/czz_czzi001.4gl:6:13:6:13:error:(-4340) The variable \u0026#39;a\u0026#39; is too complex a type to be used in an expression. ../42m/czz_czzi001.4gl:6:9:6:9:error:(-4323) The variable \u0026#39;b\u0026#39; is too complex a type to be used in an assignment stateme. 对输出进行整体输出 define a array[2] of integer let a[1] = 1 let a[2] = 2 display a 编译报错\n../42m/czz_czzi001.4gl:6:13:6:13:error:(-4340) The variable \u0026#39;a\u0026#39; is too complex a type to be used in an expression. 数组整体运算 define a,b array[2] of integer define sum integer let a[1] = 1 let a[2] = 2 let b[1] = 2 let b[2] = 3 let sum = a + b if a\u0026gt;b then display \u0026#34;\\na\u0026gt;b\u0026#34; end if 编译报错\n../42m/czz_czzi001.4gl:9:15:9:15:error:(-4340) The variable \u0026#39;a\u0026#39; is too complex a type to be used in an expression. ../42m/czz_czzi001.4gl:9:19:9:19:error:(-4340) The variable \u0026#39;b\u0026#39; is too complex a type to be used in an expression. ../42m/czz_czzi001.4gl:10:8:10:8:error:(-4340) The variable \u0026#39;a\u0026#39; is too complex a type to be used in an expression. ../42m/czz_czzi001.4gl:10:10:10:10:error:(-4340) The variable \u0026#39;b\u0026#39; is too complex a type to be used in an expression. "},{"id":21,"href":"/docs/BDL/2.medium/10.function/2.diy-function/","title":"2.自定义函数","section":"第十章 函数入门-写程序就是写函数","content":"\r自定义函数\r#\r函数的调用可能是由另一个函数触发，但函数的定义都是平行的，包括main函数在内。所谓“平行”，有两层含义，一是“不允许把一个函数定义在另一个函数内”，这说明，函数定义都要在main函数外部，二是“不同函数定义放置位置没有关系”，可以定义在main函数之前，也可以定义在main函数之后。\n函数定义的语法\r#\r和变量一样，要想使用一个函数，定义是不可缺少的。\n函数定义有4个要素:参数列表、返回值、函数名和函数体， 参数列表和返回值对应着输入输出， 函数名用于和程序中其他程序实体区分， 而函数体是一段可执行的代码块，实现特定的算法或功能。\n函数的基本定义语法如下：\nfunction 函数名(参数列表) define 参数... --参数类型定义 函数体 end function 输入：参数列表 参数列表的基本形式为：\n变量名1,变量名2,变量名3... 每个变量名在函数内必须定义数据类型，有些情况下，不需要像函数传递参数，此时，参数列表为空，但圆括号不能省略。 例如：\nfunction printa()\rdisplay \u0026#34;a\u0026#34;\rend function 输出：返回值 返回值用户返回函数的输出值。 格式如下:\nreturn 输出值1,输出值2,... 如果没有输出值，可以只写一个return这个时候函数结束，但不返回任何值。\n函数名 函数名用于标示该函数，和其它函数区分开来，因此和变量取名一样，函数名必须是合乎编译器命名规则的标识符。\n函数体 函数体是一段用于实现特定功能的代码块，比如局部变量声明和其它执行语句等。注意，在函数体内声明的变量不能和参数列表中的变量同名。\n函数体可以没有任何语句，此时称为空看书，表示占一个位置，以后可以将空能实现添加上。\n在做软件开发规划时，这是一个经常使用的方法，在开发初期，为了在功能木块切割的同时维护程序的总体性。常常时先使用一个个的空函数将程序的框架搭起来，再逐步添加功能使程序一步步完善起来。\n"},{"id":22,"href":"/docs/BDL/1.basic/9.over_and_over_again/2.for/","title":"2.for结构","section":"第九章 循环结构--一遍又一遍","content":"\rfor结构\u0026ndash;更常用的循环结构\r#\r阅读代码时可以发现，for结 构是应用最多的一种 循环控制结构，这大抵是因为for结构提供的控制功能更为完善，而且，相比while结构，for结构写出的代码也更为简洁，可读性也稍好。\n基本形式\r#\rfor 变量 = 初始值 to 目的值 step 每次增加的量 循环结构 end for 注意 这里的step关键不写的时候，默认每次+1，step还可以跟负数，如果是负数，每次判断的就是小于目的值时跳出循环。\r用while表示同样的表达式:\nlet 变量 = 初始值 while 变量\u0026lt;=目的值 循环结构 let 变量 = 变量 + 每次增加的量 end while 由此可见，要写出同样功能代码，for结构比while结构简洁易读。\nfor结构执行流程图：\nflowchart TD\ra[\"变量 = 初始值\"]--\u003ed{\"变量是否超过目的值\"}\rc[\"循环结构\"]\rc--\u003eb[\"变量增加\"]\rb--\u003ed\rd--\"yes\"--\u003ee[\"跳出循环\"]\rd--\"no\"--\u003ec\r其执行过程如下：\n变量赋初始值 判断变量是否超过目的值，超过退出循环，进行第5步；不超过执行循环结构，执行第3步 自动变量增加指定的值 再判断第2步 循环结果，跳出for结构，继续向下执行 利用for结构改写我们之前计算1到100和的代码：\ndefine i,sum integer for i =1 to 100 let sum = sum + 1 end for display sfmt(\u0026#34;\\n结果是：%1\u0026#34;,sum) "},{"id":23,"href":"/docs/BDL/1.basic/8.condition/2.if-else/","title":"2.if else--两条岔路的选择","section":"第八章 条件判断-分支结构","content":"\rif else\u0026ndash;两条岔路的选择\r#\r还是拿买东西做比方，口袋里只有50块钱，想买一件衣服，衣服的价格标签不见了。这时，你也许会在心里盘算，问一下衣服的价格，如果价格低于50，就说“好，买了”，否则，就说“太贵了，算了”。这种“两条岔路中选一个”的流程，在BDL语言中对应着if else结构。\n关键在else\r#\r改写上一章的代码，使用if else 结构，如下：\ndefine price integer prompt \u0026#34;请输入商品价格（正整数）：\u0026#34; for price if price \u0026lt; 50 then display \u0026#34;\\n好，买好了\u0026#34; else displau \u0026#34;\\n太贵了，算了\u0026#34; end if 无论输入多少价格，输出的结果要么是好，买好了，要么是太贵了，算了。\n代码解析\n第一个代码中采用的是if结构，在price超过50的时候不做出任何反应，一声不吭地走开，如此看来，第二个代码中的顾客似乎更礼貌一点， 在price小于50这个 条件不成立时，会输出拒绝信息“太贵了，算了”。\n如果转为流程图如下：\nflowchart TD\ra([\"开始\"])--\u003eb[/\"申明变量price，并输出提示信息，请求用户输入\"/]\rb--\u003ec[/\"接受用户输入\"/]\rc--\u003ed{\"price\u003c50?\"}\rd--\"yes\"--\u003ee[\"输出：'好，买好了'\"]\rd--\"no\"--\u003ef[\"输出：'太贵了，算了'\"]\re--\u003eg([\"结束\"])\rf--\u003eg\r当程序流程来到if else结构时，首先计算关键字if后“表达式”的值，如果表达式的值为“真”(不为0)，代码段1被执行，否则，else关 键字后的代码段2被执行。\n"},{"id":24,"href":"/docs/BDL/1.basic/7.atoml_statement/2.structured-design-program/","title":"2.结构化设计程序","section":"第七章 语句-程序最小构成单元","content":"\r结构化设计程序\r#\r结构化程序设计的思想是:把一个需要解决的复杂问题分解成若干模块来处理，每个模块解决一个小问题，这种分而治之的方法大大降低了程序设计的难度。结构化程序设计的核心问题是算法和控制结构。\n什么是算法\r#\r所谓算法，指的是解决问题时的一系列方法和步骤。\n算法的思维体现在生活的各个方面,比如我们要去北京旅游，会问一些问题:“用什么交通工具?”“在哪里中转?”“是否要去奥运现场?”等，这都包含着算法。\n可见，算法的步骤间有一定的逻辑顺序，按这些顺序执行步骤便可以解决问题，达到目的。这种逻辑顺序，在BDL语言中体现为控制结构。\n算法的表示\r#\r抛开厚厚的教科书，不去谈哪些深奥无比的属性。 本章节讨论与算法使用最为相关的问题:算法如何表示。\n原则上，自然语言也可用于算法表示，但由于自然语言的多义性，不同的人对同-一个版本的描述可能有不同的理解，因此，一般不采用自然语言来描述算法，要求采用一种精确的、无歧义的机制。\n有两种广泛使用的算法表示方法，一是伪代码法，二是流程图法。\n算法的伪代码表示\r#\r伪代码是对自然语言表示的改进，给自然语言加上了形式化的框架，以一种简单、容易理解的方式描述算法的逻辑过程。用伪代码表示的算法无二义性，易于理解。\n使用伪代码表示算法无须遵守严格的语法规则，只要完整表达了意思，书写清晰，容易阅读和读懂即可。举例如下:\n用户输入：\r如果（用户输入的字符是Y）\r执行B操作\r否则\r执行C操作\r上述代码便采用了伪代码表示方式，完成一种简单的分支选择结构\n算法的流程图表示\r#\r流程图法是种有效、直观的算法表示方法，利用不同的框代表不同的操作，利用有向线段表示算法的执行方向。\n现在通用的流程图符号画法采纳的是ANSI (美国国家标准化协会)的标准，如图所示。\nflowchart LR\rid1([\"起止框，表示程序起始和结束\"])\rid2{\"判断框\"}\rid3[/\"输入输出框，表示输入输出数据\"/]\rid4[\"处理框，完成某些操作\"]\rsubgraph a[\"这是连接点，如果流程太长将用词截断\"]\rid5((...))\rend\rid6--\"程序执行方向\"--\u003eid7\r将前面的伪代码表示转换为流程图表示，如图所示。 和伪代码方式相比，流程图方式采用了图形化的方式，更为直观，可以很清晰地反映控制结构的运作过程。\n在描述基本结构时，本书尽量采用流程图方式。\n以上伪代码，用流程表示如下:\nflowchart TD\ra([\"开始\"])--\u003eb[/\"用户输入\"/]\rb--\u003ec{\"判断是否是字符Y\"}\rc--\"YES\"--\u003ed[\"C操作\"]\rc--\"NO\"--\u003ee[\"B操作\"]\rd--\u003ef([\"结束\"])\re--\u003ef\r三种控制结构\r#\r结构化程序设计提供了3种控制结构，分别是顺序结构、分支结构和循环结构，早在1966年，Bohm和Jacopini的研究证明，用此3种基本结构可以构成任意复杂的算法。 3种基本控制结构如图所示。\nflowchart TD\ra[\"语句1\"] --\u003e b[\"语句2\"]\rb--\u003e c[\"语句3\"]\rflowchart TD\ra{\"条件1\"}--\u003eb[\"语句1\"]\ra--\u003ec[\"语句2\"]\rflowchart TD\ra{\"条件1\"}--\u003eb[\"语句1\"]\rb--\u003ec[\"语句2\"]\rb--\u003ea\r顺序结构是最简单、最基本的结构，程序按书写的顺序 从上到下来执行，不进行任何跳转。假设代码行为:\n语句1\r语句2\r语句3 执行顺序为语句1→语句2-→语句3- \u0026hellip;\u0026hellip;分支结构又称选择结构，需要在某处做出判断，根据判断结构决定走哪条路，即按判断条件决定某些语句是否执行。选择结构先判断某个条件是否成立，若成立则执行，反之，不执行。其语句形式有3种:单分支、双分支和多分支，第八章将详细介绍分支结构。\n循环结构则用于一遍一遍重复执行程序的某个部分，即由某个循环控制条件来控制某些语句及代码段是否反复执行、执行多少次。 循环结构的语句形式有两种:当型循环和直到型循。第九章将详细介绍循环结构。\n算法示例\r#\r假设编程解决这么一个问题：在用户输入3各不同整数中选出一个最小的。\n以下流程可完成该任务\nflowchart TD\ra([\"开始\"])--\u003eb[/\"用户输入3个不同整数，存入变量x，y，z\"/]\rb--\u003ec{\"判断x\u003ey是否成立\"}\rc--\"yes\"--\u003ed{\"判断y\u003ez是否成立\"}\rc--\"no\"--\u003ee{\"判断x\u003ez是否成立\"}\rd--\"no\"--\u003ef[\"最小数是y\"]\rd--\"yes\"--\u003eg[\"最小数是z\"]\re--\"yes\"--\u003eg\re--\"no\"--\u003eh[\"最小数是x\"]\rf--\u003ei[/\"输出\"/]\rg--\u003ei\rh--\u003ei\ri--\u003ej([\"结束\"])\r"},{"id":25,"href":"/docs/BDL/1.basic/6.operators_and_expressions/2.relational-operator/","title":"2.关系运算符","section":"第六章 运算符和表达式-程序基本构成","content":"\r关系运算符和关系表达式\r#\r关系运算就是作比较，日常生活中经常遇到一些真假判断，比如说，“张三比李四高”，“济南到北京比到上海近”，“5大于2”，这些问题的答案是真或假。\n程序设计是对实际问题解决过程的模拟，长城需要左判断，像“如果这样，我就执行动作A，如果那样，我就执行动作B”。\n那么怎么判断这样那样呢？ 这就需要用到关系运算和关系表达式。\n关系运算符号种类\r#\r关系运算就是比较变量或常量是否符和预期，比较结果为一个逻辑值“真”或“假”。 举个简单的例子，说“x\u0026lt;10”，如果x值为9，“9\u0026lt;10”成立，故上述式子的值为“真”，若x的值为15，则“15\u0026lt;10”不成立，上述式子的值为“假”。\nBDL中，“真”和“假”也是用数值来体现的，0就是“假”，其它值为“真”。\n关系运算符\n运算符 描述 is null 判断控制 like 如果字符串和给定的格式匹配成功返回true matches 如果字符串和给定的格式匹配成功返回true 相同(==or=) 判断两个值是否相同 不相同(!=or\u0026lt;\u0026gt;) 判断两个值是否不相同 小于\u0026lt; 判断左边的值小于右边 小于等于\u0026lt;= 判断左边的值小于等于右边 大于\u0026gt; 判断左边的值大于右边 大于等于\u0026gt;= 判断左边的值大于等于右边 nvl() 如果第一参数为空，返回第二个参数 iif() 如果第一个参数为true,返回第二个参数，否则返回第三个参数 in() 判断值是否在一个范围内 运算顺序\r#\r关系运算符比算数运算符优先级低，这说明：\nx+5\u0026gt;y-7和(x+5)\u0026gt;(y-7)是等价的。\n以下是关系表达式的常见用法\ndefine a ,b ,f integer define c ,d, e decimal(6,3) define s string let a = 1 let b = 2 let c = 1.51 let d = 2.5 let s = \u0026#34;darcyjoven\u0026#34; display sfmt(\u0026#34;\\na\u0026lt;b=%1\u0026#34;,a\u0026lt;b) display sfmt(\u0026#34;c\u0026lt;a=%1\u0026#34;,c\u0026lt;a) display sfmt(\u0026#34;f is null\u0026#34;,f is null) display sfmt(\u0026#34;s matches \\\u0026#34;darcy*\\\u0026#34; =%1\u0026#34;,s matches \u0026#34;darcy*\u0026#34;) 请键入以上代码观察输出结果。\n"},{"id":26,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/2.sfmt/","title":"2.display与sfmt函数","section":"第五章 利用键盘、鼠标与程序交互","content":"\rdisplay与sfmt函数\r#\rdisplay函数已经接触过，是将后面的变量或者值显示到控制台的命令行中。\n请尝试下以下代码，看看运行的值有何区别\ndefine a integer define b decimal(20,6) define c varchar(20) define d decimal(10,6) let a = 1 let b = 1 let c = 1 let d = 1 display \u0026#34;\u0026#34; display a display b display d display c let c = \u0026#34;1\u0026#34; display c let c = b display c 运行后，会发现显示如下\n1\r1.000000\r1.000000\r1\r1\r1.000000 是否很你想像中的不一样，我们没有输入空格，却打印了很多空格。\n隐式转换字符串 display会将任何变量转换为字符串，如果后面不是字符串会自动转化为字符串格式。\n这个转换时隐式的，隐式转化字符串会将数字剩余长度用空格补上。所以\ndisplay a\rdisplay b\rdisplay c 这两句将补上对于数量的空格: integer 最大表示2147483647，10位，1只有一位所以补上9个空格，因为integer正负数都有可能，还要补上一个符号位值，一共10个空格。\ndecimal(20,6),decimal(10,6)整数部分分别有14，和4位，再加上1位符号位，分别是15，5。整数部分只有1位，所以补上14，4个空格。小数部分没有值部分补上0（小数补0在显示转换也会补上）。\n隐式转换字符串 在BDL语言中，显示转换字符串，例如let c = 1，这种形式。 是不会补上前面少的位数和符号位\nlet c = b\rdisplay c 例如上面代码只显示1.000000。\n但是每次数字转字符串我们都显示的转化字符串let c = b，会导致代码多很多没有必要的行。 所以BDL语言为我们封装了一个函数sfmt(),之前我们已经见过这个函数。\n其中s是string字符串的意思,fmt是foramt的缩写，全称位StringFormat字符串格式化。\nsfmt(参数1,参数2,参数3...)sfmt接受至少2个参数，且所有参数传入时，都会显示的转为字符串处理。\n在之前的用例中，我们写过这样的代码:\ndisplay sfmt(\u0026#34;1+2+3+4+5=%1\u0026#34;,x) 这里一个参数\u0026quot;1+2+3+4+5=%1\u0026quot;,第二个参数x是正整数值为15。\n函数首先将所有参数显示转为字符串，15转为字符串\u0026quot;15\u0026quot;。\n注意第一个参数是中的%1，我们尝试以下代码\ndisplay sfmt(\u0026#34;1+2+3+4+5=%2\u0026#34;,15,0) 这是我们发现输出的结果如下：\n1+2+3+4+5=0 发现其中规律了吗？%n代表着从第n+1个参数的值。\n我们再将%2改为%3\ndisplay sfmt(\u0026#34;1+2+3+4+5=%3\u0026#34;,15,0) SFMT: Invalid index used. 报错了，因为没有第4个参数。你无法使用没有传入的参数，但是可以传入参数而不使用。\r好了，现在我们知道smft的用法了，后面我们将经常使用这个函数，因为它可以为我们减少很多不必要的代码。\n"},{"id":27,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/2.bite-bit/","title":"2.字节和位","section":"第四章 存储和获取数据","content":"\r字节和为\u0026ndash;计算机表示数据的方法\r#\r程序员编写的程序以及所使用的数据在计算机中是以二进制位序列的方式保存的。 典型的计算机内存段二进制位如下：\n...010010101010101010010001100111001100... 上面的二进制位序列中，每个数字，要么是0，要么是1。在计算机中，位（bit）是包含-或者1的一个单元。在物理上，它的值是一负或者一个正电荷。 也就是计算机中通过电压高低来表示以为所含有的值。 如果是0，则用低电压表示；如果是1，则用高电压表示。\n在上述的二进制位序这个层次上，位的集合没有结构，很难解释这些系列的意义。 为了能够从整体上考虑这些位，于是给这些位序列枪架上结构的概念，这样的结构被称为字节（byte）和字（word）。 通常，一个字节由8位构成，而一个字由32位构成，或者说4个字节构成。\n经常可能被问到的一个问题是：“存款有几位数了？”如果回答是4位数，那了不起也就是万元少点。如果回答是6位数，那就是几十万了。 日常生活中，通过十进制的位数，就可以发现要表达的数越大，需要十进制的位数也就越多。\n一个字节只有8位，一个字节能表达的最大数据也就是111111112，即8位数的二进制就是255。也就是说，一个字节最大能存储的证书是255。两个字节呢？11111111111111112的十进制是65535。四个字节呢？是4294967295。32位计算机中，一个整型需要4个字节博爱是，所以最大整数是4294967295，超过4294967295之后，比如4294967296在计算机中用一个整型就表示不了了。 在计算机中，需要表示的数越大，需要的二进制位也就越多，也需要更多字节来保存。\n26个英文字母可以用26个数字分别对应，如果算上大小写，也就52个数字。再加上英文标点符号和10个数字，总共加起来也不足127个字符。 于是美国有关的标准化组织就出台了所谓的美国标准信息交换码（ASCII编码），同意规定了上述常用符号用那些二进制数来表示。\n如果汉字要在计算机中表示，就没那么简单了。 汉字由上万个，用一个字节表示一个汉字的话，最多只能表示256个汉字，必须使用两个字节才能把所有汉字表示完全。 所以在计算机中，一个汉字用两个字节表示。 假设一篇文章由100个汉字组成，那么至少需要2*100=200个字节表示。\n计算机中物理内存的空间大小是有限的，现在内存条一般是8G大小。 硬盘的空间也有限，现在的硬盘一般都超过了512G大小。 在这里8G 和512G是什么意思呢？ 这里其实是一个简单的单位换算。\n1字节=8位\r1K字节=1024字节=2\u0026lt;sup\u0026gt;10\u0026lt;/sup\u0026gt;字节，也就是1K=1024\r1M字节=1024K字节=1024*1024字节=2\u0026lt;sup\u0026gt;20\u0026lt;/sup\u0026gt;字节，也就是1M=1024K\r1G字节=1024M=1024*1024*1024字节=2\u0026lt;sup\u0026gt;30\u0026lt;/sup\u0026gt;字节，也就是1G =1024M\r所以如果一个512G大小的硬盘用来全部储存汉字，可以储存多少个字呢？ 512G =512*1024*1024*1024/2个汉字=274,877,906,944个汉字。\n"},{"id":28,"href":"/docs/BDL/1.basic/3.composition_of_bdl/2.annotation/","title":"2.为何要注释","section":"第三章 最简单bdl程序的组成","content":"\r注释\u0026ndash;为何有必要在代码里留下程序员的解释\r#\rdatabase ds --连接数据库 main # 入口函数 display sfmt(\u0026#34;hello world\u0026#34;) {打印} end main 以上代码中出现最多的是“\u0026ndash;”，“#”和“{}”后面或中间包含中文，这些就是注释。 注释是用来帮助程序员阅读源代码和理解源代码的。 编译器在编译时候，会把注释提出掉然后再进行编译，当前编译器是不会修改源文件，这些都是再内容中完成。 由于对于注释部分忽略不粗理，就如同没有这些字符一样，所以注释不会增加编译后的文件长度，对程序运行不起任何作用。对于注释，有以下几点说明。\nBDL的注释 有“\u0026ndash;”，“#”行注释，和“{}”包裹起来的块注释对。 编译器将行注释后的任何文件，和块注释包裹起来的任何文件都不予处理。 例如 {\r这\r些\r都\r是\r注\r释\r}\r--这些都是注释\r#这个有 空格 注释可以放在任何地方。通常，把注释放在要描述的代码上方，比较合适。对比比较短的代码，也可以放在后面。 注释和代码一定要同步更新。 代码修改而注释不做改变，这样的事情再实际开发中经常看见，而这一的情况可能带来严重后果。 注释内部不能再出现注释 {\r{\r这是不允许的\r}\r} 适量和恰当的注释是良好的编程风格的重要体现。 注释可以用来概括程序的算法、标识遍历和函数的意义，或者解释一段代码的意图。 但是再代码中混杂过多的注释会使得程序更难以理解，反而影响代码阅读。 "},{"id":29,"href":"/docs/BDL/1.basic/2.first_code/2.environment_of_BDL/","title":"2.BDL开发环境","section":"第二章 第一行代码","content":"\rBDL开发环境\r#\r本书所有代码运行的环境都在fjs-fgl-2.4版本，开发环境为linux系统。 本书不涉及环境如何部署。\n项目目录结构\r#\rtiptop gp 和 t100 都有固定的项目结构，\r点此查看。 建议你在不影响正式使用的程序前提下，建立或修改程序代码。\ntiptop gp\r编译\r#\rtiptop gp环境中需在代码对应的4gl目录下，运行命令r.c2 czzi001，czzi001是你建立的程序编号。即4gl文件去掉后缀名后的内容。\n连接\r#\rtiptop gp连接命令为 r.l2 czzi001，注意：这里的czzi001不是4gl文件程序编号，而是在p_zz中注册的程序。所以在运行r.l2连接之前，你还需要做以下这些步骤。\n新增p_zz资料 如果你现在还不知道p_zz作业的功能，没关系，现在你可以参考czzi001的内容，将czzi001替换为你的程序编号，czz替换为你的程序编号前三位。 需要注意的时czzi001.4gl 一般放在czz/4gl目录下，同样azzi001.4gl 也放在azz/4gl目录下，在你更进一步理解BDL的目录结构前，就一直按照这种方式建立新程序。\n点击维护链接资料建立连接资料 (链接和连接是同一种说法的不同翻译) 新建程序时，会提示你无资料，是否建立，这里选择是。 看到下方有一笔路径为$CUST/czz/42m/czz_czzi001.42m的资料。 当后续我们程序更复杂时，会主动添加更多需要的连接资料。\n最后保存时此弹窗的意思，是让你自动连接一次，可以选择是，连接失败也不要仅，只要资料有产生就可以。\nt100\r编译\r#\r开始编辑代码\r#\r以上设置好之后，你就可以编辑代码了。\n我用的vs code编辑器，配合Informix 4GL这款插件，所以代码可以高亮，不同的单次有不同的颜色，起到了提醒的作用。\n除了vscode，t100自带的开发平台T100 design、submlime text、4js官方提供的genero studio等工具也能有高亮样式。\ndatabase ds -- 指定数据库，因为t100和tiptop gp有部分功能必须使用数据，所以这里必须先连接数据库 MAIN --主函数 入口点 DISPLAY \u0026#34;Hello World\u0026#34; -- 打印字符串 END MAIN 也许你注意到了，database是小写，MAIN是大写，在BDL语言中，大小写是不区分了，类似于SQL。你甚至了混合使用。\n"},{"id":30,"href":"/docs/BDL/1.basic/1.before_all/2.how-learn-dbl/","title":"2.如何学好BDL语言","section":"第一章 踏上征程前的思想动员","content":"\r如何学好BDL语言\r#\r无论出于什么目的，一旦下定绝心学习BDL语言，就要端正子项，因为听过BDL用的少，和其它语言差异太多，所以觉得学不好，或者随便学学，是不可取的。只要你掌握一些方法，克服畏惧心理，不轻言放弃，是完全可以学好的。\n多动手多求人\r#\r所有的问题都可以通过字节编写代码观察结果解决。凡是可以通过编写代码观察到结果的问题，都不应该成为一个问题。不会的，也不要太固执，多问问有经验的人。\n多学习优秀代码\r#\rBDL相当灵活，即使写的代码不优秀，也可以编译后达到你的运行目标，但是有的代码可以使用更少的代码实现相同功能，或者代码更加具有复用价值。我相信你很容就能找到不错的BDL代码。\n多以人类的思考方法来类比计算机\r#\r计算机需要什么数据、如何获取这些数据、得到后如何存放、如何处理、处理后如何表现等，对这些问题要多问写为什么，一旦理解了计算机处理这些问题的过程，编程就是一件异常轻松的事情了。\n多了解可以直接使用的功能\r#\r如果你在使用tiptop gp t100，会有相当多的功能都已经做好成为函数，等待你的调用。请多了解有哪些函数可以使用。\n"},{"id":31,"href":"/docs/Practice/","title":"BDL练习题","section":"Docs","content":"\rBDL 练习题\r#\r请配合 BDL 教程使用，不能解决的问题不要灰心，请回顾教程后过一段时间再继续尝试。\n"},{"id":32,"href":"/docs/BDL/2.medium/14.database/3.update-insert-delete/","title":"3.插入更新删除","section":"第十四章 数据库使用","content":"\r插入更新删除\u0026ndash;BDL操作数据\r#\r提前确认\r#\r在每次操作数据之前，请确认当前连接的数据库是否正确。\n不要更新错了库！\n本节内容需要你了解SQL基础语法，如果不了解可以参考此教程\r一篇文章学会SQL。\n插入INSERT\r#\r在BDL中操作数据库有两种方式，一种是直接使用SQL原生语句，另一种是使用BDL的SQL语句。\n原生语句\r#\r将要执行SQL语句放到字符串中 let l_sql = \u0026#34;INSERT INTO demo_file (demo001,demo002,demo003) values(\u0026#39;mar-001\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39;)\u0026#34; prepare SQL语句 prepare demo_ins from l_sql -- demo_ins为标识符 执行SQL语句 execute demo_ins 检查SQL是否执行成功 在BDL中有一个特殊的全局变量sqlca用来记录SQL执行情况。\ndefine sqlca record sqlcode integer, -- 报错代码 100 表示未找到 \u0026lt;0表示有错误 sqlerrm string, --错误消息数量 sqlerrp string, sqlerrd array[6] integer, -- 1. 未使用 -- 2. 最后一个Serial或错误代码 -- 3. 最后一条语句处理的行数 -- 4. CPU使用时间 -- 5. SQL文件错误偏移量 -- 6. 最后一行的ROWID sqlawarn string end record 更新时只要检查sqlca.sqlcode 为0 且 sqlca.sqlerrd[3]大于0，那么就是执行成功。否则有报错，或者没成功。\n原生语句中使用占位符号\r#\r在实际情况，我们可能要插入多条数据，且每条数据都不一样。这个时候如果每次都写一次sql，prepare一次，就不合理了。\n我们可以使用占位符，和sfmt(\u0026quot;%1 %2\u0026quot;,2,3)中的占位符号一样，SQL也可以有类似的语法，我们只要修改两个地方。\n修改SQL语句 在BDL中，SQL的占位符为?，我们将所有要插入的字段值替换为?符号。\nlet l_sql = \u0026#34;INSERT INTO demo_file (demo001,demo002,demo003) values(?,?,?)\u0026#34; 执行SQL prepare 语句不变，只要在执行时，我们加上我们要插入的数据即可。\nexecute demo_ins using \u0026#39;mar-001\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39; execute demo_ins using \u0026#39;mar-002\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39; execute demo_ins using \u0026#39;mar-003\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39; 我们可以每次插入不同的数据，记得每次检查SQL是否执行成功。\n注意\n这里USING 关键字虽然和格式化数字的USING一样，但是是不同的语法。这里要考虑USING 用在什么位置。即考虑上下文。\nexecute demo_ins using \u0026#39;mar-003\u0026#39;, 12 using \u0026#34;\u0026lt;\u0026lt;\u0026lt;\u0026lt;.\u0026amp;\u0026amp;\u0026#34; ,\u0026#39;xxx\u0026#39; 如上面语句，第一个using是 execute中将后面的值传入SQL语句代替占位符的意思。\n第二个using是格式化数字的意思。\nBDL的SQL语句\r#\r除了SQL原生语句，BDL也提供了更简单的插入数据语法。\n直接运行一下语句，也可以将资料更新到数据库中。\nINSERT INTO demo_file (demo001,demo002,demo003) values(\u0026#39;mar-001\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;xxx\u0026#39;) 检查SQL执行成功否和原生SQL检查方法一样。\n原生SQL和BDL SQL比较\r#\rBDL 语法和原生SQL同时插入三次执行过程如下：\ngraph LR\ra[\"原生SQL\"]--\u003eb[\"prepare\"]\rb--\u003ec[\"execute\"]\rc--3次--\u003ec\rA[\"BDL SQL\"]--\u003eB[\"翻译为数据库SQL\"]\rB--\u003eC[\"prepare\"]\rC--\u003eD[\"execute\"]\rD--3次--\u003eA\r注意\nBDL自带语法写着简单，但是效率没有原生SQL高。\n如果你要批量插入多笔数据，还是使用原生SQL，每次execute比较快。\n更新UPDATE\r#\r和插入一样，更新也可以写为两种方式。\n原生SQL let l_sql = \u0026#34;update demo_file set demo002 = ?,demo003=? where demo001= ? \u0026#34; prepare demo_upd from l_sql excute demo_upd using \u0026#34;yyy\u0026#34;,\u0026#39;yyy\u0026#39;,\u0026#39;mar-001\u0026#39; BDL SQL update demo_file set demo002 = \u0026#39;yyy\u0026#39;,demo003=\u0026#39;yyy\u0026#39; where demo001=\u0026#39;mar-001\u0026#39; 删除DELETE\r#\r和插入一样，删除也可以写为两种方式。\n原生SQL let l_sql = \u0026#34;delete from demo_file where demo001 like ?\u0026#34; prepare demo_del from l_sql excute demo_del using \u0026#39;%00%\u0026#39; BDL SQL delete from demo_file where demo001 like \u0026#39;%00%\u0026#39; "},{"id":33,"href":"/docs/BDL/2.medium/13.struct/3.nesting-record/","title":"3.结构体嵌套","section":"第十三章 结构体","content":"\r结构体嵌套\r#\r上一节中讨论的person结构相对简单，只包含了3个数据成员: name、age和email, 如果面对的是更为复杂的结构，将所有数据成员并排似乎不是个高效的方法。那能否使用结构体嵌套，一层层管理数据呢?\n结构体嵌套定义\r#\r顾名思义，结构体嵌套就是“结构体套结构体”，某个结构体的成员也是一个结构体变量，这样就可以按层次结构合理组织数据，举例如下：\ntype student record score record math integer, english integer end record, info record height,weight decimal(10,2) end record end record student是个外层结构，内部包含着学生的数据，结构体student内又定义了两个结构体变量score (成绩)和info (基本情况),结构体中的成员应当是占据内存空间的变量实体，因此，score和info是student结构的数据成员，结构体scorestruct和infostruct只是两个类型名，不占据实在的内存地址空间。将上述代码如下改写似乎更好理解一点:\ntype score record math integer, english integer end record type info record height,weight decimal(10,2) end record type student record score score, info info end record 在结构体内部申明的结构体类型是不可见的，只能通过外部结构体调用。\ntype student record score record math integer, english integer end record, info record height,weight decimal(10,2) end record end record define zhangsan student 例如以上代码，你只能使用zhangsan.score.math来访问成员math，score无法省略，因为info结构体类型中也可以声明一个成员math，为了避免歧义，每层结构体的名称都必须显示的写出来，而不能省略。\n你也无法使用define lisi info这种形式定义一个只有info的结构体变量，因为info在student内部声明，你只能通过student来访问。\n"},{"id":34,"href":"/docs/BDL/2.medium/11.array/3.two-dimensional/","title":"3.二维数组","section":"第十一章 数组-同一类型的多个元素的集合","content":"\r二维数组\r#\r一维数组常称为向量，本节介绍二维数组。所谓二维数组，最简单的理解是“有两个下标’如果把一维数组理解为一行数据，那么，二维数组可形象地表示为行列结构，如图所示,左侧表示的是一个大小为M的一维数组：\nA[1] A[2] \u0026hellip; A[M] 右侧表示的是-一个大小为M*N的二维数组：\nA[0,1] A[0,2] \u0026hellip; A[0,N] A[1,1] A[1,2] \u0026hellip; A[1,N] \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; A[M,1] A[M,2] \u0026hellip; A[M,N] 二维数组的定义\r#\r和一维数组一样，定义二维数组时，要告诉编译器以下信息：数组名、元素类型、元素的个数。对二维数组来说，元素个数时两位大小的成绩。\n动态数组时只要定义数组的维度即可。\n示例如下：\ndefine a array [2,3] integer -- 定义一个2x3的定长数组，一共有2*3=6个元素。 define b dynamic with dimension 2 of string --定义一个二维的动态字符串数组 定长和动态二维数组都可以访问的语法都是一样的。\narray[m,n] 二维数组应用举例\r#\r查看以下代码，演示二维数组的使用方式。\ndefine score array[6,3] of integer --表示6个学生的3门成绩 define s array[3] of integer --每门课的总成绩 define i , j integer -- 输入总共18门成绩 for i = 1 to 6 prompt sfmt(\u0026#34;请输入第%1位学生的成绩%2：\u0026#34;,i,1) for score[i,1] prompt sfmt(\u0026#34;请输入第%1位学生的成绩%2：\u0026#34;,i,2) for score[i,2] prompt sfmt(\u0026#34;请输入第%1位学生的成绩%2：\u0026#34;,i,3) for score[i,3] end for -- 计算每门课总成绩 for i = 1 to 3 let s[i] = 0 for j = 1 to 6 let s[i] = s[i] + score[j,i] end for end for display \u0026#34;\\n平均成绩：\u0026#34; for i = 1 to 3 display sfmt(\u0026#34;第%1门课的平均成绩为%2\u0026#34;,i,(s[i]/6 using \u0026#34;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;##.\u0026amp;\u0026amp;\u0026#34;)) end for 输出结果为：\n平均成绩：\r第1门课的平均成绩为268.00\r第2门课的平均成绩为120.33\r第3门课的平均成绩为169.17 请注意每次访问数组的时候，[]的索引是用的哪一个。\n"},{"id":35,"href":"/docs/BDL/2.medium/10.function/3.formal-actual/","title":"3.函数调用与返回","section":"第十章 函数入门-写程序就是写函数","content":"\r函数调用与返回\r#\r形参和实参\r#\r请观察一下代码：\nmain define x,y,sum integer let x = 5 let y = 7 call add(x,y) returning sum display sum end main function add(a,b) define a,b integer return a + b end function 在上面代码中参数列表是a和b，而在函数调用时传递进来的参数是x和y，这两种参数是申明关系呢？ 打个形象的比方，这是角色和演员的关系。\n函数定义时列表中参数为形数，是“剧本角色”，而函数调用时传递进来的参数称为实参，是“演员”，函数执行的过程就是演戏的过程。\n程序刚开始执行的时候，系统并不为形参分配存储空间，因为它只是个角色，不是实体，一直要到函数调用时，系统为形参分配存储空间，并将实参的值复制给形参。\n结合代码上面代码可知，在call add(x,y) returning sum语句调用前，a和b都不是真正的程序变量，一直到add函数被调用，a和b才被创建，并分别用x和y为其赋值，在这种情况下，在函数内对a和b的处理并不影响x和y，这类似于“ 某个演员扮演的角色在戏中受伤，并不是说演员真的受伤了”，而且，在函数执行结束返回时，创建的形参被撤销，这类似于“戏演完 了，剧中角色自然也就停止了”。\n举例来看，下列示例代码先交换两个变量的值，但并没有成功，为什么?请试着用演员和角色的关系来解释一下。\n--视图交换两个变量的值 main define num1,num2 integer display \u0026#34;\u0026#34; display sfmt(\u0026#34;num1 is %1,num2 is %2 \u0026#34;,num1,num2) call swap2Variable(num1,num2) display sfmt(\u0026#34;num1 is %1,num2 is %2 \u0026#34;,num1,num2) end mian function swap2Variable(a,b) define a,b,c integer display sfmt(\u0026#34;a is %1,b is %2 \u0026#34;,a,b) let c = a let a = b let b = c display sfmt(\u0026#34;a is %1,b is %2 \u0026#34;,a,b) end function 输出结果为：\nnum1 is 10,num2 is 5\ra is 10,b is 5\ra is 5,b is 10\rnum1 is 10,num2 is 5 代码解析\n在函数调用时，形参a和b才被创建，并分别用num1和num2为其赋值，而后，在函数内对a和b的交换成功，但这与外部的numl和num2完全无关，函数执行完毕退出时，形参a和b被撤销，再次输出num1和num2,两者的值并没有交换。\n形参和实参有如下特点：\n即使同名，实参和形参也不共用一块内存，形参变量只有在函数被调用时才分配内存空间，由实参将数据传给形参，在函数调用结束后，立即释放形参占用的内存空间。 实参可以是变量、常量、表达式甚至是函数等，无论实参是何种类型的量，在进行函数调用时，其必须有确定的值，以便把这些值传给形参，因此，应预先用赋值、输入等方法使实参获得确定值。 对于自定义函数和库函数，形参的类型已经说明，调用函数时，形参和实参在数量、类型和顺序上应保持-致。特别强调类型一致，如果是可自动转换的类型差异，编译器将自动完成相互间的转换。如果对应的形参和实参类型不一致，且编译器无法完成其间的自动转换,编译器将报错。 函数返回\r#\r看一下以下代码：\nfunction add(a,b) define a,b integer return a + b end function 既然说a和b都是形参，在程序调用时才创建，程序退出时便被撤销，那类似\u0026quot;return a+b\u0026quot;之类的返回语句岂不是没有意义，返回一个被撤销的量？\n函数的返回机制应如何理解呢？\n理解的关键词时“复制”，执行到return语句时，return的值被复制到某个内存单元或寄存器中，其地址是由系统来维护的，我们不用操心，也就是说，在a和b被撤销前，返回值被保存在某个地方，系统访问该内存单元即可知道函数的返回值。\n下属语句:\ncall add(x,y) returning z 实际上面代码完成下述一系列操作\n将实参x和y以传值方式传人函数add中，函数触发 返回值的值复制保存到某个内存单元处，假设是M处 用M处保存的函数返回值复制给变量z "},{"id":36,"href":"/docs/BDL/1.basic/9.over_and_over_again/3.cycle-in-cycle/","title":"3.循环嵌套","section":"第九章 循环结构--一遍又一遍","content":"\r循环嵌套\r#\r循环结构也支持嵌套，如果把简单的循环内容为“一遍又一遍”，那循环嵌套便可称为“一层又一层，一遍又一遍”。\n可以用始终来打比方，走一个代表执行一次循环，那么一小时里，分针又要走60个格，而分针每走一格，秒针也要走60格。\n如此，秒针的走动可以看成是内存循环，而分针的走动可看成是外层循环。\n嵌套示例\r#\r已for循环结构举例，限制想在屏幕上输出4*9个星号，这可以利用双重循环来做：\ndefine i,j integer define s string display \u0026#34;\u0026#34; for i = 1 to 4 let s = \u0026#34;\u0026#34; for j = 1 to 9 let s = s, \u0026#34;* \u0026#34; end for display s end for 输出结果为：\n* * * * * * * * *\r* * * * * * * * *\r* * * * * * * * *\r* * * * * * * * * 代码解析\n上述代码中，采用双重循环来画出上述图形，第1层循环控制行，循环变量是i,从1循环到4，第2层循环控制列，循环变量是j，从1循环到9，输出“星号+两个空格”。\n初始时，i=1,满足外层循环条件i\u0026lt;=4，进人循环体，进入第一层循环体时，我们初始化变量字符串s，因为我们需要一个字符串保存每一行我们要输出的内容，否则输出的内容将自动换行，其循环体是由内层循环for结构和换行语句组成，内层循环开始执行，将9个星号都拼接到s字符串中，这和求和类似，当完成内循环，我们diplay处字符串的值；此时，转到执行外部循环体的自动变量增加，开始新一轮外层循环，以此类推，输出了4*9个星号图案。\n对循环控制结构来说，不仅可以双重嵌套，还可做到三重、四重甚至更多层次的嵌套，顺序、分支和循环3种结构互相搭配，组成的算法形式也各种各样，这为开发人员提供了极大的自由空间。\n嵌套的效率\r#\r在循环嵌套中，程序流程需要在内层循环和外层循环间跳转，每次跳转都要付出一定的开销，这体现在对CPU和内存的调度和占用上(具体涉及体系结构方面的知识，本书不再展开 述)。\n因此，在编程时应有意识地考虑嵌套的效率问题。 在多重循环中，如果有可能，一般将重复次数多的循环放在里层，循环次数少的循环放在外层，以减少内外层循环切换的次数，提高程序的效率。\n"},{"id":37,"href":"/docs/BDL/1.basic/8.condition/3.multi-branch/","title":"3.多分枝语句和分支语句嵌套","section":"第八章 条件判断-分支结构","content":"\r多分枝语句和分支语句嵌套\r#\r讲过了“2选1”， 那如果出现“3选1”， 甚至是“N选1”怎么办?可使用多分支语句和分支语句嵌套。此外，BDL语言还提供了开关语句case,这是一种特殊的选择分支结构，稍后一节会讨论case的用法。本节来看一下分支语句嵌套的问题。\n多分支\r#\r用实例说明似乎更好理解，假设需要编制-一个程序，根据学生的得分判定其类别，具体是:少于60分判为D (不及格)，60到74分判为C (一般)， 75到89分判为B (良好)，大于等于90分判为A (优秀)，学习分支结构后读者编写的代码可能如下所示。\ndefine mark integer prompt \u0026#34;请输入该学生成绩：\u0026#34; for mark if mark \u0026gt;= 90 then display \u0026#34;A\u0026#34; end if if mark \u0026gt;= 75 and mark \u0026lt;90 then display \u0026#34;B\u0026#34; end if if mark \u0026gt;= 60 and mark mark \u0026lt;75 then display \u0026#34;C\u0026#34; end if if mark \u0026lt;60 then display \u0026#34;D\u0026#34; end if 代码解析\n代码的结果符合要求，但使用4个并列if结构在效率上会大打折扣，画出其流程图，如图所示。 flowchart TD\ra([\"开始\"])--\u003eb[\"申明变量mark、并输出提示，请用户输入\"]\rb--\u003ec[/\"接受用户输入\"/]\rc--\u003ed{\"mark\u003e=90?\"}\rd--\"yes\"--\u003ee[\"输出'A'\"]\rd--\"no\"--\u003ef{\"mark\u003e=75 and mark \u003c90\"}\re--\u003ef\rf--\"yes\"--\u003eg[\"输出'B'\"]\rf--\"no\"--\u003eh{\"mark\u003e=60 and mark \u003c75\"}\rg--\u003eh\rh--\"yes\"--\u003ei[\"输出C\"]\rh--\"no\"--\u003ej{\"mark\u003c60\"}\ri--\u003ej\rj--\"yes\"--\u003ek[\"输出'D'\"]\rj--\"no\"--\u003el([\"结束\"])\rk--\u003el\r不论用户输入什么样的成绩，都会经过4次判断。有时候，某些判断不是必须的，比如说，如果用户输人的是95，实际上输出A之后程序就可以结束了，后面的3个判断完全是多余的。基于这种思路，可对代码进行改进。\n改进的方法有多种:对于以上代码这种判断并执行对应代码块后就结束的程序，可以在代码块中display后调用exit program函数提前“毙掉”当前程序。\nexit program其功能是中止程序的执行，并在退出前对程序占用的资源进行必要的清理。 exit是一个无返回值的函数，其参数称为退出码，用以通知操作系统当前程序是正常终止(一般为0)还是非正常终止(一般为-1)。\n大多数情况下，在判断后程序并未结束，后面还有代码要执行，可以使用自由跳转语句goto,但这种太过自由的跳转的大量使用会使得程序如一团乱麻，理不清读不顺。因此，很多专家都反对使用goto语句，goto跳转 将在第9章中进行介绍，本节单就分支本身进行讨论。使用多分支if结构或分支结构嵌套来解决这一问题。\n分支语句嵌套\r#\r方if(或者if else)结构红执行语句又是if(或者if else)结构时，称为分支语句嵌套。 分支语句嵌套的样式有千万种，不可能一一列举，举个简单的例子：\nif 表达式1 then\rif 表达式2 then\r语句1\relse\r语句2\rend if\rend if 上述代码时在if结构内嵌套了if else结构，首先计算表达式1的值，如果过值为假（0），直接跳过结构，语句1和语句2都不会执行，如果其值为真（非0），则执行内部的if else结构。 计算表达式2的值，如果其值为真，执行语句1，否则执行语句2。\n可以看出，分支结构嵌套的执行流程实际上是个剥壳的过程，一层层地做出选择。有的读者可能会对上面的示例有所疑惑，两个if和一个else,它们的搭配关系是怎样的? BDL标准规定:else语句总是和它前面最近的if配对。\n练习\r#\r尝试将判断成绩的分支结构改为嵌套分支结构，减少不必要的判断语句计算。\n"},{"id":38,"href":"/docs/BDL/1.basic/7.atoml_statement/3.practice/","title":"3.练习","section":"第七章 语句-程序最小构成单元","content":"\r练习\r#\r根据以下伪代码，写一个小程序\r#\r大于等于60分的输出“合格”，小于60分的输出“不合格”。\n用户输入\r如果（用户输入的数值小于60）\r执行A操作\r否则\r执行B操作 "},{"id":39,"href":"/docs/BDL/1.basic/6.operators_and_expressions/3.logical-operator/","title":"3.逻辑运算符","section":"第六章 运算符和表达式-程序基本构成","content":"\r逻辑运算符和逻辑表达式\r#\r逻辑运算符\r#\r关系表达式的输出结果为“真”和“假”，但关系表达式毕竟只能判断一次，实际问题常常遇到多个条件判断情况。 例如，“如果从济南到北京比上海近，并且明天不下雨，就去北京旅游”。 BDL语言遇到这种情况，就要使用逻辑运算符和逻辑表达式。\n逻辑运算符\n运算符 描述 not 如果右边表示大为true返回false，如果为flase，返回true and 如果左边和右边表达式都为true,返回true,否则false or 如果左边和右边表达式都为false,返回false,否则true 逻辑运算符\r#\r在计算机中，逻辑运算符可以理解为，``与 或 非`。\n与（AND） “表达式1 and 表达式2”，只有当两个条件都为 非0 时，运算结果为非0，否则结果为0。\n所有表达式是并且的关系，都成立时才认为成立，有任意一条不成立，就算不成立。\n或（or） “表达式1 or 表达式2”，只有两个条件都为0时，运算结果才为0,否则为1。\n所有表达式是或且的关系，都不成立的时候才不成立，有任意一条成立，就算成立。\n非（not） “not 表达式”，取反，当表达式为0时，结果为1，当表达式为1时，结果为0。\n所修饰的表达式成立那么就不成立，不成立就成立。\n逻辑真值表\r#\rA B not A not B A and B A or B 真 真 假 假 真 真 真 假 假 真 假 真 假 真 真 假 假 真 假 假 真 真 假 假 总结以下：与运算就是“有一个假，结果为假”，或运算是“有一个真，结果为真”，非运算时“假变真，真变假”。\n下面，是逻辑运算的用法示例：\ndefine a , b integer define c , d boolean let c = a \u0026lt; b let d = a+3 \u0026gt; b display sfmt(\u0026#34;\\nnot c and d =%1\u0026#34;,not c and d) display sfmt(\u0026#34;not (c and d ) =%1\u0026#34;,not (c and d )) display sfmt(\u0026#34;a \u0026gt; 0 or b \u0026gt; 0 =%1\u0026#34;,a \u0026gt; 0 or b \u0026gt; 0) 请自己键入，编译后查看结果。\n"},{"id":40,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/3.format-number/","title":"3.数字的格式化","section":"第五章 利用键盘、鼠标与程序交互","content":"\r数字的格式化\r#\r之前我们说过日期在BDL语言也是储存为整数类型，请运行以下代码，观察其输出值\ndefine t date display t 发现其结果是\n1899/12/31 如果你的环境是1899/12/31，是因为DBDATE环境变量为Y2MD/，修改为Y4MD/之后就变为4位。不建议修改，因为已有代码可能是按照2位编写的。\n日期类型会自动格式输出，那么我如果也想数字格式化输出字符串，应该如果写呢？\n本章就来介绍以下，数字的格式化方式。\n数字货币格式化\r#\r在介绍之前，我们尝试运行一下如下代码：\ndefine a integer define b decimal(20,6) let a = 12345 let b = 2345.1235 display sfmt(\u0026#34;a=%1,b=%2\u0026#34;,a,b) display sfmt(\u0026#34;a=%1,b=%2\u0026#34;,a using \u0026#34;******\u0026#34;,b using \u0026#34;#####.###\u0026#34;) a=12345,b=2345.123500 a=*12345,b= 2345.124 使用了 using \u0026ldquo;******\u0026rdquo; 的12345 在最前面多了一个* 使用了 using \u0026ldquo;#####.###\u0026rdquo; 的2345.1235，整数前多了一个空格，小数保留了3位，且进了一位。 这里的数字/数字变量 using 格式化字符串的格式就是在格式化数字格式。\n格式化字符串中有固定的写法，如下：\n类型 格式化规则 * 不足的位数补上* # 不足的位数补上空格 \u0026amp; 不足的位数补上0 \u0026lt; 和\u0026amp;一样，但是左对齐 - 和#一样，但负数会加上-号 + 和-一样，但整数会加上+号 ( 和-一样，但负数会加上()号 ) 和(一样 $ 数值前加上一个币种符号 , ,号左侧有数字才显示, . 可以限制小数位数 @ 显示多为币种符号 虽然开起来很复杂，但实际使用场景就只有几种\n金额保留位数 数字左对齐或者右对齐 小数不足位数 常用的几种格式示例:\n--数量左对齐 a using \u0026#34;\u0026lt;\u0026lt;\u0026lt;,\u0026lt;\u0026lt;\u0026lt;,\u0026lt;\u0026lt;+.\u0026amp;\u0026amp;\u0026amp;\u0026#34; --整数部分最大9位，小数保留3位，小数不足补0，正数负数都要有+/-号 -- 金额右对齐 a using \u0026#34;###,###,##-.\u0026amp;\u0026amp;\u0026#34; --整数部分最大9位，小数保留2位，小数不足补0，负数显示-号 日期格式化\r#\r章节开头我们说过日期格式化是1899/12/31格式，是环境变量设置。 但如果我们一个程序中需要两种不同格式的日期格式该如果处理呢？\n其实date类型也能用using关键字格式化，格式化规则如下\n类型 格式化规则 dd 两位表示日期，只有一位时会补0 ddd 表示因为英文星期 mm 同日期，两位月份，自动补0 mmm 三位英文月份 yy 两位月份 yyyy 四位年份 c1 在dd或者ddd后加上c1，可以使用从1912年开始计算年份（民国） 在年月日中，你可以加上合适的分隔符，时日期更好读。\ndisplay a using \u0026#34;yyyy年mm月dd日\u0026#34; 日期格式的运算\r#\r在定义日期时，我们知道日期是一个整型，所以如果第二天直接+1即可。\n但是我们在进行赋值一个日期时，还要计算要赋值日期和1899/12/31之前差多少天，也太不方便了。\n所以日期格式有一些更方便的计算和赋值函数(关键字)。\n名称 使用方法 today() 值为今天的日期let a = today() current 当前的时间let a= current,注意没有(),所以它是关键字。 date()1 let a = date(34000)``1899/12/31后的第34000天 date()2 let a = date(\u0026quot;1949/10/01\u0026quot;) 以字符串格式赋值日期，字符串的格式必须与DBDATE格式一致 mdy() let a = mdy(10,01,1949)以整型赋值日期，注意参数顺序 year() let a= year(current)取一个日期的年份 month() let a= month(current)取一个日期的月份 day() let a= day(current)取一个日期的日 weekday() let a = weekday(current)取日期的星期 extend(a,b to c) extend (today,year to fraction(4))将日期调整为year to fraction格式 "},{"id":41,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/3.data-types/","title":"3.数据类型","section":"第四章 存储和获取数据","content":"\r数据类型\r#\rBDL语言规定，程序中使用的每一个数据，必须指定其数据类型。\nBDL语言数据类型\ngraph TD;\rBDL语言数据类型--\u003e构造类型\rBDL语言数据类型--\u003e基本类型\r构造类型--\u003e数组\r构造类型--\u003e结构体\r基本类型--\u003e字符串类型\r基本类型--\u003e数值类型\r数值类型--\u003e整型\r数值类型--\u003e浮点型\rgraph TD;\r整型--\u003eDATE\r整型--\u003eBINGINT\r整型--\u003eINTEGER\r整型--\u003eSMALLINT\r整型--\u003eTINYINT\r整型--\u003eBOOLEAN\rgraph TD;\r浮点型--\u003ec[\"FLOAT[(p)]\"]\r浮点型--\u003ed[\"SMALLFLOAT\"]\r浮点型--\u003ee[\"DECIMAL[(p[,s])]\"]\r浮点型--\u003ef[\"MONEY[(p[,s])]\"]\rgraph TD;\r字符串类型--\u003ea[\"CHAR[(n)]\"]\r字符串类型--\u003eb[\"VARCHAR[(n[,r])]\"]\r字符串类型--\u003eSTRING\r字符串类型--\u003eBYTE\r字符串类型--\u003eTEXT\r基本类型是最基础的简单数据类型，其值无法再分解为其它类型 构造数据类型：顾名思义，构造数据类型是根据已经定义的一个或读个数据类型用构造的方法来定义的。 构造数据类型有多个其它数据类型组合而成。 一个构造类型的值可以分解成若干个成员或元素。 其中每个成员要么是一个基本数据类型，要么又是一个构造类型。 再BDL语言中构造类型又以下几种： 数组类型：所有元素都是同一类型。即数组类型是统一数据类型元素的集合 结构类型：不同数据类型的组合 本节只介绍基本数据类型，其它数据类型再后续陆续介绍。\n整数类型\r#\r整数是日常生活和计算机中用得最频繁的数据类型，也比较容易理解。 整数从数学意义上来说就是从负无穷到正无穷之间的任意整型的数据，也就是任意自然数(如1、2、3、4、5)以及它们的负数或0。 如果用十进制表示一个自然数，十进制的位数越多，表示的整数也越大。 在计算机中用二进制表示数据，二进制的位数不能无限使用，所以在计算机中，整数有一定的大小限制，只能在一定的范围之内。 在以前内存“寸土寸金”的时代，哪怕是为了节约2个字节的内存，也是非常有必要的。\n所以BDL语言的整数类型，又分为BINGINT8，INTEGER4，SMALLINT2，TINYINT1。\n在BDL语言中，日期也是用整型标识的，DATE4,它和INTEGER4在内存中存储方式一致，并规定1899/12/31这一天为0，1900/01/01为1。\n除了这些比较大的整数还有一个1位的整型BOOLEAN，它只能保存1或者0。\n请验证以下代码的运行值，后续所有代码不需要的地方都不会在包括main函数：\ndefine a smallint let a = 32767 display a let a = a + 1 display a let a = a + 1 display a 整数的正负\r#\r浮点型\r#\rFLOAT[(p)]8\nSMALLFLOAT4\nDECIMAL[(p[,s])]\nBDL中一种特殊浮点数，p位整数的位数（10进制的位数），s位小数的位数（10进制的位数）。 利用这种方式我们实现就可以知道这个数可以储存的小数位数精确度。\nMONEY[(p[,s])] MONEY是一种特殊的DECIMAL，唯一区别是scale默认位2。在显示时，根据DBMONEY环境变量的值显示对应的币种符号。\n字符串类型\r#\rCHAR[(n)] 固定大小字串，\u0026ldquo;a \u0026quot;\nVARCHAR[(n[,r])] 动态字串，\u0026ldquo;a\u0026rdquo;,r位保留字段，为了和数据库语法一致，一般不适用\nSTRING 动态大小字串\u0026quot;a\u0026hellip;b\u0026rdquo;\nBYTE31 ~2.14 Gigabytes 二进制文件\nTEXT31 ~2.14 Gigabytes 文本文件\n转义字符\r#\r在计算机中，有一批特殊形式的不可打印字符、单引号、双引号、反斜杠、回车退格等，需要用转义系列表示。前面的章节中printf函数使用的\\n就是一种以“\\”开头的字符序列，代表换行的意思。这种非显示字符难以用一般形式的字符表示，所以C语言规定用“\\” 开头的字符其后跟随的字符用另外的意思代替，“\\” 及其后有特殊意义的字符序列称做转义字符。\n常见的转移字符：\n字符形式 功能描述 \\n 换行 \\t 横向跳格，跳到下一个tab输出区 \\v 竖向跳格 \\b 退格 \\r 回车 \\f 换页 \\\\ 字符\\ ' 字符' \u0026quot; 字符\u0026quot; 请尝试运行以下代码，看程序输出是否和你预期的一样：\ndisplay \u0026#34;\u0026#34; display \u0026#34;1abcdefghijklmn\\n\u0026#34; display \u0026#34;\\t\\\u0026#39;\\\u0026#34;2opqrstuvwxyz01|------\\\u0026#34;\\\u0026#39;\u0026#34; display \u0026#34;3mmmmmmmmmmmmmm\\n\u0026#34; "},{"id":42,"href":"/docs/BDL/1.basic/3.composition_of_bdl/3.main-function/","title":"3.main函数","section":"第三章 最简单bdl程序的组成","content":"\rmain函数\u0026ndash;从哪里开始，到哪里结束\r#\r先看以下代码\nmain display sfmt(\u0026#34;hello world\u0026#34;) end main 代码解析 main ...end main这一段是在定义BDL程序的主函数。函数是可以完成一定功能的子程序。main函数是BDL语言程序的起始执行点。每一个BDL程序必须有且仅有一个main函 数，它是由程序员提供的。\n请读者思考一个问题:操作系统是如何开始运行调用一个程序的? 这个问题的意思是操作系统怎么知道一个程序的入口点在哪里?所谓入口点，就是程序的第一条指令。 操作系统调入程序二进制代码到内存后，从哪条指令开始运行程序呢?\n一种办法是从文件第一行开始，一行一行往下执行，直到文件结束。 很多语言就是采用这种方式。 比如QBASIC语言。 这种方法的好处显而易见，人类是怎么阅读的，计算机就是怎么执行的。 但是缺点也很多，当有两个源文件的时候，从哪个文件开始呢? 另一种办法是和运行程序的启动者协商一个规定的入口名字，从这个名字开始进入。这种方法就是BDL语言采用的方法。\nmain函数就是BDL程序的入口点。无论整个工程有多少个C源文件，必须编写且只能编写一个main函数。程序就是从main的第一条语句开始执行，然后在main函数中，顺序执行其他语句，在这些语句中，调用其他函数，从而使整个程序运行起来。 main函数结束了，整个程序也就结束了。 由此可见，写BDL程序，就是写main函数。\n简单地说明一下定义函数的语法。对函数的详细讲解请参考后续章节。\n对于BDL语言，定义函数的语法规则如下：\nfunction 函数名称(参数1，参数2)\r函数体\rreturn 返回值\rend function 对比上面的语法规则可以看出，在main这一行中，main是函数名称。 函数可以是BDL语言系统提供的系统函数，也可以是用户自己编写的函数。 用户自己编写的函数，函数名字可以自行决定。\n例如：\nfuntion add(x,y) define x,y integer return x+y end function 看以上代码，add为函数名，函数名后有小括号对“()，括号里是传递给函数的参数。 类 似初、高中学习的代数里的函数y=f(x)一样，x就是参数，f是函数名称。 参数可以是一个，也可以是多个，也可以没有参数。\n每个参数都有一个数据类型。本例中的参数的数据类型是integer（整数）。 在function ... end funtion之间的的代码就是add函数实现的功能，被称做函数体。 在函数体里能做哪些事情，也是有规定的。在函数一章里再详细说明。\n"},{"id":43,"href":"/docs/BDL/1.basic/2.first_code/3.see-your-program/","title":"3.编译运行","section":"第二章 第一行代码","content":"\r编译运行-欣赏你的杰作\r#\r使用之前我们说的编译连接命令，开始编译连接。如果成功将不会有错误提示，如果失败请检查一些你的代码，可以对比上一篇中的代码。\n在czz/4gl目录下输入exe2 czzi001,将会显示以下内容。\n"},{"id":44,"href":"/docs/BDL/1.basic/1.before_all/3.what-is-language/","title":"3.语言概述","section":"第一章 踏上征程前的思想动员","content":"\r语言概述\r#\r提到语言这个词，人们自然想到的是英语、汉语这样的自然语言，因为语言是任何人交互交流信息不可缺少的工具。而今天，计算机变不了我们生活每一个角落，除了任何人之前的交互交流之外，我们必须和计算机交流。用什么样的方式和计算机做最直接的交流呢？人们自然想到的是最古老也同时也是最方便的方式-语言。\n什么是语言\r#\r类必人类的语言，汉语言、英语言、法语言等，可以总结出语言有如下特点。\n语言是用来交流沟通的 语言有独特的语法规则 什么是机器语言\r#\r计算机时一个忠实的仆人，时刻等候着主人的命令。 如何才能使计算机听话呢？ 当然时用计算机听得懂的语言去命令它了。 计算的大脑或者说心脏就是CPU，它控制着计算机的运作。 每种CPU都有自己的指令系统。 这个指令系统就是该CPU的机器语言。 机器语言是一组有0和1系列组成的指令码，这些指令码是由CPU制作厂商规定出来的，然后发不出来请程序员遵守。如下是某CPU指定系统的两条zhiling\n1000000 加\r1001000 减\r要让计算机完成相应的任何，就得用这样的语言去命令它。这样的命令不是一条两条，二十上百条。 由于不同型号计算机的指令系统即机器语言是不相同的，按着一种计算机的机器指令编制的程序，不能再另一种计算机商执行。\n用机器语言编写程序，编程人员首先要数据所用计算机的全部指令代码和代码的含义。 在编写程序时，程序员得自己处理每条指令和每一数据存储分配得输入和输出，还得记住编程过程中每步所使用得工作单元处理处在何种状态，这是一件十分繁琐得工作，编写程序花费得时间往往时实际运行时间得几十倍或者几百倍。而且，编出得程序全是0和1得指令代码，直观性差，还容易出错。\n什么是汇编语言\r#\r在用机器语言编程得实践中，一批顽强而聪明得先行者发明了汇编语言\u0026ndash;一门人类可以比较轻松掌握得编程语言。只是这门语言计算机并不人事，人类还不能这门语言命令计算机做事情。\n所以有一类专门得程序，既人事机器语言，又认识汇编语言，而且还很聪明，知道怎么把汇编语言翻译成机器语言。于是，人类和机器又有了一种新的交流方式，而且任何可以轻松地编写程序了。\n上文提到过，不同CPU有不同指令系统，从而有不同机器语言与其对应。所以程序员用汇编语言编写程序，都要记住实在什么CPU商编写的。程序员不仅要考虑程序涉及思路，还要熟记计算机得内部结构这种编程得劳动强度依然很大。\n面向过程得语言\r#\r汇编语言和机器语言都是面向机器得，机器不同，语言也不同。 既然有伴把汇编语言翻译成机器语言，难道就不能把其它更人性化得语言翻译成机器语言？ 1954年，Fortran语言出现了，其后续出现了其它类似语言。这批语言是程序员摆脱了计算机硬件得桎梏，把主要精力放在了程序涉及商，不在关注底层得计算机硬件。 这类语言被成为高级语言。同样得高级语言要被计算机执行，也需要由一个翻译程序将其翻译成机器语言，也就是编译程序。\n这类高级语言解决问题得方法是分析出问题所需要得步骤，把程序看作是数据被加工的过程。 基于这类方法涉及的语言成为面向过程语言。C语言就是一种面向过程的程序设计语言。\n什么是BDL语言\r#\rBDL语言相对于C语言，抽象程序更高，更少的代码可以做更多的事情。 但同样的由于抽象程序高，占用资源也比较高，无法与C语言这样比较底层的语言更加灵活处理问题，为了解决这个问题，BDL中可以直接调用C语言程序。\n"},{"id":45,"href":"/docs/BDL/2.medium/14.database/4.select-single-row/","title":"4.查询单笔资料","section":"第十四章 数据库使用","content":"\r查询单笔资料\r#\rBDL SQL\r#\r同插入一样，查询时BDL SQL也有特殊的语法，但仅可以查询单笔资料，如果查询结果包含多笔，程序报错退出。\ndefine l_ima01 like ima_file.ima01 define l_ima02 like ima_file.ima02 select ima01,ima02 into l_ima01,l_ima02 from ima_file where rownum = 1 在select关键之前from关键字之后，可以使用into关键字，后面可以指定查询保存到哪些变量。\n我们在定义变量类型时有使用过一下语法\ndefine l_ima record like ima_file.* 在查询时我们也可以将表中所有内容查询出来。\ndefine l_ima record like ima_file.* select * into l_ima.* from ima_file where rownum = 1 EXECUTE\r#\r除了BDL自带SQL语法，我们依然可以使用数据库的原生语法，和插入语法类型，我们需要将SQL放到字符串中。\ndefine l_sql string define l_ima record like ima_file.* let l_sql = \u0026#34;select * into l_ima.* from ima_file where rownum = ?\u0026#34; prepare ima_sel from l_sql execute ima_sel using 1 into l_ima.* 查询和插入的区别在于，execute最后可以使用into语法接收查询的结果。\nFETCH\r#\r以上两种方式都可以查询单笔数据，但限制有些大，每次查询结果只能有一笔。 在实际查询中，我们通常要查询多笔资料。\n为了应对多笔查询的场景，BDL提供了一个特殊的FETCH语法。可以灵活查询多笔SQL查询结果。 FETCH查询需要实现定义游标(cursor)，游标定义之后，在数据库中就确定了SQL的结果，之后通过FETCH查询，就不会重新查询一遍，只要在游标中抓取指定的那一笔即可。\n游标\r#\r游标定义有三种方式，效果都是相同的。\n由prepare定义 let l_sql = \u0026#34;select * into l_ima.* from ima_file where rownum = ?\u0026#34; prepare ima_sel_p from l_sql declare ima_sel_cur cursor for ima_sel_p ima_sel_cur为游标的名称，为自定义的标识符\n由字符串定义 declare ima_sel_cur cursor from \u0026#34;select * into l_ima.* from ima_file where rownum = ?\u0026#34; 利用字符串定义，将cursor for 改为cursor from即可。\n由BDL SQL定义 declare ima_sel_cur cursor for select * into l_ima.* from ima_file where rownum = 1 由BDL SQL定义可以直接跟在cursor for即可。\ncursor在事务提交时将关闭，这时再使用会报错。如果cursor资料内容被修改，再使用cursor也会报错。\nOPEN CLOSE FREE\r#\r游标的状态有3中操作，OPEN、CLOSE、FREE。\nOPEN 开启游标，如果SQL含有占位符，使用using 将参数传入 CLOSE 关闭游标，关闭cursor，如果要使用需要再OPEN FREE 释放游标，再次使用时需要重新DECLARE SCROLL / WITH HOLD\r#\rcursor的定义还有两个可选选项scroll with hold\ndeclare ima_sel_cur1 cursor with hold for select ima01 from ima_file where rownum =1 declare ima_sel_cur2 scroll cursor with hold for select ima01 from ima_file with hold 关键字在cursor后添加，可以使cursor事务提交之后也不关闭\nscroll 关键字，在cursor前增加，这个是由使用fetch 可以灵活去不同位置的资料。\nscroll 和 with hold 可以同时使用\n示例\r#\r灵活取任意笔数 declare ima_sel_cur2 scroll cursor with hold for select ima01 from ima_file FETCH NEXT c1 into cust.* --取下一笔 FETCH PREVIOUS c1 into cust.* -- 取上一笔 FETCH FIRST c1 into cust.* -- 取第一笔 FETCH LAST c1 into cust.* -- 取最后一笔 FETCH ABSOLUTE 10 c1 into cust.* -- 取第10笔 "},{"id":46,"href":"/docs/BDL/2.medium/13.struct/4.record-in-array/","title":"4.结构体数组嵌套","section":"第十三章 结构体","content":"\r结构体数组嵌套\r#\r在上一章节例子中，我们使用student类型定义了两个变量zhangsan,lisi。 但是我们需要的变量不止两个，例如，我需要一个班上50个学生，是不是场景很熟悉？没错，变量。\n我们使用变量嵌套结构体，示例：\ntype student record score record math integer, english integer end record, info record height,weight decimal(10,2) end record end record define students array[50] of student 数组中的结构体\r#\r入上面代码，结构体声明是一种自定义的数据类型，在数组\n结构体中的数组\r#\r"},{"id":47,"href":"/docs/BDL/2.medium/11.array/4.multi-dimensional/","title":"4.多维数组","section":"第十一章 数组-同一类型的多个元素的集合","content":"\r更高维的数组\r#\r在了解二位数字定义、初始化和引用之后，不难将概念引申到三维，思维，甚至是更高维数组，本章讨论更高维数组的使用方式。\n高维数组的定义和元素访问\r#\r细心的读者不难发现，如果数组是N维，就需要N个下标来访问数组中的元素，同样，在声明高维数组时，除了和一-维、二维数组声明一样要指定元素类型和数组名外，还要指定每一维的大小，以帮助编译器确定到底要分配多大的内存块。\n举例来说，要声明一个int型3维数组sz,大小为345,代码如下:\ndefine sz array[3,4,5] of integer 多维数组在内存中如何排列元素\r#\r维度决定了数组中元素的组织方式及访问元素所用的下标个数，但本质上讲，所有的数组在内存中都是一维线性的，所有元素都是连续排列的，中间没有间隔。\n以二维数组为例，内存中是先放第一行的元素，再放第二行的元素。下面给出了大小为3*4的二维数组A的排列顺序：\nA[1,1]-\u0026gt;A[1,2]-\u0026gt;A[1,3]-\u0026gt;A[1,4]-\u0026gt; A[2,1]-\u0026gt;A[2,2]-\u0026gt;A[2,3]-\u0026gt;A[2,4]-\u0026gt; A[3,1]-\u0026gt;A[3,2]-\u0026gt;A[3,3]-\u0026gt;A[3,4] 多维数组的存储方式与此类似，可以将下标看成是-一个计数器，像计数的万位、千位、百位、十位和个位一样，右边的下标(靠后的下标)是低位，每一位都在上下界间变化，变化的范围是1到声明时指定的下标值，当某一低位计数器超出范围时(达到声明时指定的下标值)，左边下标加1，同时该低位计数器及其右边的更低位计算器置1 (回到下界)。这样，最左边一维下标变化是最慢的，最右一维 下标变化最快。\n下面给出2*3*2的三维数组B中元素在内存中的排列顺序:\nB[1,1,1]-\u0026gt;B[1,1,2]-\u0026gt;\rB[1,2,1]-\u0026gt;B[1,2,2]-\u0026gt;\rB[1,3,1]-\u0026gt;B[1,3,2]-\u0026gt;\rB[2,1,1]-\u0026gt;B[2,1,2]-\u0026gt;\rB[2,2,1]-\u0026gt;B[2,2,2]-\u0026gt;\rB[2,3,1]-\u0026gt;B[2,3,2] "},{"id":48,"href":"/docs/BDL/2.medium/10.function/4.process-oriented/","title":"4.面向过程编程","section":"第十章 函数入门-写程序就是写函数","content":"\r面向过程的程序结构\r#\r在20世纪60年代计算机发展的初期，程序设计是少数聪明人的工具，程序员可以根据自己的喜好，像捏泥巴一样进行程序设计，注释几乎是一行没有，想到哪写到哪，大多数程序代码组织混乱，可以说只有设计者本人可以看懂，有的甚至设计者读起来也不知所以，常被称为“意大利面条式编程”。\n这种个人英雄主义的单打独斗在解决小规模问题时勉强可以，但程序规模的不断扩大，一大堆的问题凸显出来:程序质量低下，进度延误，预算严重超支，就是“软件危机”，给程序开发的前景蒙上了一层暗淡的色彩。\n结构化程序设计方法就是在这个背景下提出的，除了前面章节中讲过的3种控制结构:顺序、分支和循环外，结构化程序设计的另-一个关键概念是模块化设计。\n模块化\r#\r生活中常常接触到模块化的概念，模块化程序设计大致有点像小时候玩的积木游戏，用木块组合的方式很容易地就构筑起了“大厦”。模块化至少有两点好处: 一是封装，“积木块”是“基本砖块”的组合，对外是个整体，使用方便，二是可复用，“柱子”封装好后，既可以用在这个建筑上，又可以用在那个建筑上。程序设计也可以借鉴这一思想，用模块化的方法进行程序设计，函数正是模块化方法的体现。\n虽说语句是BDL语言的基本单位，但从程序设计总体把握上来看，将函数视为一个整体，大大降低了问题的复杂程度。在解决复杂问题时，首先考虑的是问题的概貌，而不是微小细节，这是人的思维和行动习惯，程序设计也是如此，先将问题分割成-一个个函数，每个函数实现特定的功能，确定函数之间的联系和依赖关系，这是从整体解决某个问题。其次才是考虑每个函数怎么写，算法流程怎么走这些问题，这就是“分而治之、逐步求精”的设计方法学。\n函数的调用过程\r#\rBDL语言是由函数组成的，本章前面以及介绍了函数的定义、声明和调用等基础只是，下面来看一下函数的调用过程，即不同函数是和配合的。如图：\nflowchart TD\rsubgraph a[\"main\"]\re[\"函数1\"]--\u003ef[\"函数2\"]\rend\rsubgraph b[\"函数1\"]\ri[\"语句1\"]--\u003eg[\"函数3\"]\rg--\u003eh[\"语句2\"]\rend\rsubgraph c[\"函数2\"]\rj[\"...\"]\rend\rsubgraph d[\"函数3\"]\rk[\"...\"]\rend\re--\"call\"--\u003eb\rb--\"return\"--\u003ee\rf--\"call\"--\u003ec\rc--\"return\"--\u003ef\rg--\"call\"--\u003ed\rd--\"return\"--\u003eg\r一个入库一个出口\r#\r结构化程序设计主张使用顺序、选择、循环3种基本结构来嵌套连接成具有复杂层次的“结构化程序”，严格控制goto语句的使用。\n需要强调的一点是，对单个模块而言，只有一个人口，一个出口。这是一种从上到下的流程式方法，减少了模块间的相互联系，使模块可作为插件或积木使用，降低程序的复杂性，提高可靠性。\n封装和可重用\r#\r可作为插件或积木使用的模块具有很强的可重用性，完全可用在其他同类型的问题中，省却了将算法重写一遍的麻烦。对一些规模较大的商业软件公司来说，模块的积累是笔巨大的财富，到达一定的规模后，解决问题时要重新写的代码和模块很少，从库中挑选出需要的模块，拼装组合就形成了满足要求的程序。而且，如果在模块编制中注重算法的效率等因素，采用这种插件组合的方式可以很容易产生出高质量的软件产品。\n下面来看一下封装性。在模块化程序设计中，模块内部的结构，对其他模块来说是不重要的，以函数为例来说明，BDL语言中，函数可看成是一个封装体，将一系列相关的、实现某一功能的代码封装起来，并提供了一个使用方法(程序开发中常称接口)，通过该接口可以在程序的任何地方使用这些代码完成特定的功能，至于函数是如何编写的，可能并不是用户关心的重点，用户真正关心的是这个函数如何使用。这就意味着，函数内定义的变量等，外部是不能访问的，为此，引入“内聚”和“耦合”的概念。\n高内聚，低耦合\r#\r既然模块化设计有那么多的好处，那是不是可以不管三七二十-地把整个程序简单地分解成一个个程序段呢?答案是否定的，模块的划分有条准则，即“相对独立，功能单一”。也就是说，一个好的模块必须具有高度的独立性和相对较强的功能，这通常用“耦合度\u0026quot;、“内聚度”两个指标从不同侧面而加以度量。\n耦合度，是指模块之间相互依赖性大小的度量，耦合度越小，模块的相对独立性越大。内聚度，是指模块内各成分之间相互依赖性大小的度量，内聚度越大，模块各成分之间联系越紧密，其功能越强。\n在模块划分时应当做到“耦合度尽量小，内聚度尽量大”。\n"},{"id":49,"href":"/docs/BDL/1.basic/9.over_and_over_again/4.cycle-and-flow-control/","title":"4.流程转向控制语句","section":"第九章 循环结构--一遍又一遍","content":"\r流程转向控制语句\r#\r之前我们了解到BDL中除了判断语句，循环语句，还有大量的流程转向控制语句。\n他们是continue、exit、goto语句，本章节会一一讲述。\nexit\u0026ndash;跳出循环\r#\r如果把重复结构视为一层壳，那么exit的作用可说是“破壳而出”，当流程执行到循环结构中的break语句时，循环结构提前结束，程序转而执行循环结构之后的那条语句，用流程图来表示，如图所示。\nflowchart TD\ra{\"?\"}--\u003eb{\"exit?\"}\rb--\"no\"--\u003ed[\"语句\"]\rb--\"yes\"--\u003ec[\"...\"]\rd--\u003ea\r图中，如果在循环体内部执行了exit语句，程序流程会直接从循环结构中跳出，转而执行循环结构后面的语句，这类似于电路中的“短路”。\n前面讲过，“如非故意为之，不要让循环成为死循环”，那这“故意为之”是怎么回事?如何“从死循环中跳出”，可用break语句实现，见示例代码：\ndefine i integer display \u0026#34;\\n\u0026#34; while 1 display \u0026#34;Hello\u0026#34; let i = i + 1 if i \u0026gt; 5 then exit while end if end while 尝试编译运行，你会发现，while 1看起来是个死循环，但是我们再循环结构中，增加了一个可以exit的机会。\ni每次循环都会+1，当i大于5时，就会运行到exit，退出循环。\n注意 当循环有多层时，exit只能剥一层“壳”，向外跳出一层。\rcontinue\u0026ndash;重来一次\r#\rexit语句时结果整个循环结构，而continue语句结束的只是当前一次循环，形象的说时“再来一次”，流程图如下：\nflowchart TD\ra{\"?\"}--\u003eb{\"continue?\"}\rb--\"yes\"--\u003ea\rb--\"no\"--\u003ec[\"语句\"]\rc--\u003ea\r比较和之前exit，很容易发现两者的不同，continue短路只是本次循环后的内容，不会跳出循环结构，所以，continue语句被称为循环继续语句。\n以下代码演示了continue语句的用法：\ndefine i integer display \u0026#34;\u0026#34; for i = 0 to 20 if i mod 3 != 0 then continue for end if display sfmt(\u0026#34;%1能被3整除\u0026#34;,i) end for 输出结果为：\n0能被3整除\r3能被3整除\r6能被3整除\r9能被3整除\r12能被3整除\r15能被3整除\r18能被3整除 代码解析\n代码使用的是for循环结构，如果控制变量i不能被3整除，调用continue语句结束本次循环，重新开始循环，否则，输出提示信息。\ngoto\u0026ndash;随心所欲\r#\rgoto是“go to”的缩写，称为自由转向语句，使用goto语句可将流程转到程序的任何地方。\n和goto相关的一个概念是“标号”，这相当于现实的地址，更形象点说是“门牌号”， 标号的基本定义形式为:\nlabel 标号名:\r语句 在程序其他地方使用“goto+标号名”的形式将流程转到标号定义处。\n很多程序员甚至权威人士都不赞成使用goto语句，认为它破坏了程序的良好结构，转来转去会让代码读起来像一团乱麻，加上已经证明：使用顺序、分支和循环结构这3种基本流程控制足以写出任意复杂度的算法一不管其有多复杂。\n在是否使用goto语句上，可谓见仁见智，相信读者也有自己的看法，不过，goto语句有 个特殊用法值得注意，前面说过，使用exit语句跳出循环结构时，只能剥一层壳，在循环嵌套时，如果想一次性从中跳出，可使用goto语句，见示例代码：\ndefine i integer while 1 while 1 diplay \u0026#34;*\u0026#34; let i = i +1 if i \u0026gt; 3 then goto outside end if end while end while label outside: 代码解析\n上述代码用于在屏幕上输出4个星号，为了说明goto语句的用法，采用了两重循环结构嵌套，在内层中判断计数整型变量i的大小，当i\u0026gt;3条件成立时，程序从循环中跳出，到outside标号处。\n"},{"id":50,"href":"/docs/BDL/1.basic/8.condition/4.case/","title":"4.case--开关语句","section":"第八章 条件判断-分支结构","content":"\rcase\u0026ndash;开关语句\r#\r用多分支if结构和if结构嵌套都可实现“多选1”,但带来的负面影响是程序的可读性差，面对一大堆的if和if else搅和在一起，很多读代码的人都会觉得头皮发麻，要耐心地去“脱壳\u0026quot;。 实际上，BDL语言还提供了另\u0026ndash;种更简洁的多分支结构，即case结构。\n一般形式\r#\rcase机构一般形式为:\ncase 表达式1 when 常量表达式1 语句1 when 常量表达式2 语句2 when 常量表达式3 语句3 ... default 语句4 end case 语句执行时，首先对case后的表达式进行计算，将计算的结果逐个与when后的常量表达式进行比较，当表达式的值与某个常量表达式的值相等时，即执行该when后的对应的代码段，如果表达式的值与所有when后的常量均不相同时，则执行default后的语句。\ncase 的算法流程如下：\nflowchart TD\ra[\"表达式计算\"]--\u003eb{\"常量表达式1\"}\rb--\"no\"--\u003ec{\"常量表达式2\"}\rc--\"no\"--\u003ed{\"常量表达式3\"}\rd--\"no\"--\u003ee{\"常量表达式n\"}\re--\"no\"--\u003ef[\"defalut:语句m+1\"]\rb--\"yes\"--\u003eg[\"语句1\"]\rc--\"yes\"--\u003eh[\"语句2\"]\rd--\"yes\"--\u003ei[\"语句3\"]\re--\"yes\"--\u003ej[\"语句m\"]\r来看一个具体的应用实例，由用户输入一个1到7之间的数字，程序自动输出对应星期几的英文形式，如输入1，程序输出Monday。如果用户输入的数字不在1到7之间，提示出错，如下:\ndefine index integer prompt \u0026#34;请输入一个1到7之间的整数：\u0026#34; for index display \u0026#34;\u0026#34; case index when 1 display \u0026#34;Monday\u0026#34; when 2 display \u0026#34;Tuesday\u0026#34; when 3 display \u0026#34;Wednesday\u0026#34; when 4 display \u0026#34;Thursday\u0026#34; when 5 display \u0026#34;Friday\u0026#34; when 6 display \u0026#34;Saturday\u0026#34; when 7 display \u0026#34;Sunday\u0026#34; default display \u0026#34;请检查输入是否正确\u0026#34; end case 代码解析\n上述代码中，读者可以改变when子句的先后顺序，程序的执行结构不会受到影响。\n进阶\r#\rcase 语句除了when后面可以根常量，还有一种跟逻辑表达式的写法，见下面代码：\ndefine index integer prompt \u0026#34;请输入一个1到7之间的整数：\u0026#34; for index display \u0026#34;\u0026#34; case when index==1 display \u0026#34;Monday\u0026#34; when index==2 display \u0026#34;Tuesday\u0026#34; when index==3 display \u0026#34;Wednesday\u0026#34; when index==4 display \u0026#34;Thursday\u0026#34; when index==5 display \u0026#34;Friday\u0026#34; when index==6 display \u0026#34;Saturday\u0026#34; when index==7 display \u0026#34;Sunday\u0026#34; default display \u0026#34;请检查输入是否正确\u0026#34; end case 请编译运行看运行结果是否一样。\n"},{"id":51,"href":"/docs/BDL/1.basic/6.operators_and_expressions/4.assignment-operator/","title":"4.赋值运算符","section":"第六章 运算符和表达式-程序基本构成","content":"\r赋值运算符和赋值表达式\r#\r赋值运算时BDL中常见运算，一般用来改变变量的值。 BDL中提供了赋值运算符号let =，和函数返回值赋值returning两种估值方式。\n赋值表达式\r#\rlet = 赋值 之前我们已经多次使用let a = 1对变量进行赋值，我们可以看到使用这种方式赋值的方式，=左边是我们要赋值的变量，且只有一个。 =右边是我们要赋予的值。\nlet a = a + 1之前我们还是用过这样的方式进行求和，=右边作为一个整体计算结果之后，再赋值给=左边。\nreturning 函数返回值赋值 函数之后会详细讲解，我们现使用我们已经用过的sfmt()函数作为说明。\n运行以下代码：\ndatabase ds define a,b,c integer MAIN define s string call to_day() returning s display s sleep 1 --这里是暂停一秒的意思，防止时间太接近而无法区分 let s = to_day() display s END MAIN function to_day() return current end function 我们可以看到以下内容，s的值被赋值了两次。\n2023-07-19 16:03:11.275 2023-07-19 16:03:12.276 这说明使用let s = 函数()和call 函数() returning s两种方式都可以赋值给s，那么为什么还要使用第二种方式呢。\n这是因为在BDL中允许返回多个值，当多个值返回时，就只能用returning进行赋值了。\n左值与程序实体\r#\r程序实体是内存中的一块可标识的区域，左值是左值表达式的简称，是指明一个程序实体的表达式。 判断一个表达式是否左值的方法是看其能否放在赋值号的左边。 能放在赋值号左边的表达式都是左值，它指明了一块内存区域，而赋值运算实质上是改变这一区域内容的操作。\n但应注意，能放在赋值号左边的表达式都是左值，但左值并非一定可以放在赋值号左边，const常量是左值，但不能将其放在赋值号左边，这是个例外。\n如“define a float;\u0026ldquo;声明了一个浮点型变量a，则a是左值，因为它指明了一个程序实体，可放在赋值号的左边，但表达式“a+3”和“a=1\u0026rdquo; 就不能放在赋值号的左边，不是左值。\n"},{"id":52,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/4.input/","title":"4.输入","section":"第五章 利用键盘、鼠标与程序交互","content":"\r输入\u0026ndash;键盘与鼠标的交互\r#\r之前的程序，我们都是在输出，输入的值，我们都是编写在程序中。\n但这让程序每次输出的结果都一样，如果我们要其它结果就要重新编写代码。\n为了解决上述问题，我们引入BDL语言可以支持的输入方式。\nPrompt\u0026ndash;初次接触用户界面\r#\r请运行一下代码，查看输出情况，运行前请确保打开GDC客户端\ndefine birth date prompt \u0026#34;请输入你的生日:\u0026#34; for birth display birth using \u0026#34;yyyy年mm月dd日\u0026#34; 是否出现了这个弹窗，如果未出现，请检查GDC安全性设置，调整为最低，且端口为6400。\n随便输入一点东西试试看，报错了！String to date conversion errr.。 字符串转日期格式失败，它可以帮我自动转为日期格式！而且会检查是否正确！\n我们尝试输入19900101或者900101。\n现在查看控制台，成功转为了日期！\n1990年01月01日 代码分析\nprompt \u0026quot;请输入你的生日:\u0026quot; for birth 这一行为我们做了不少事情，我们来分析一下\n弹出一个新窗，且有一个可以输入的地方和确定取消按钮。 可入处有输入说明。 可输入的地方只能输入能转为日期的内容，否则无法确定并完成。 将输入的内容转为birth变量的数据类型。 仅一行代码，就可以做这么多事情，这就是一开始说的BDL抽象级别比较高。 将大量的常使用功能集成到一起，不需要我们为重复的事情编写代码。\n让我们试一试下面这些代码:\ndefine birth date define name varchar(6) define sex varchar(1) prompt \u0026#34;请输入你的生日:\u0026#34; for birth prompt \u0026#34;请输入你的姓名:\u0026#34; for name prompt \u0026#34;你是男生吗y/n:\u0026#34; for sex display sfmt(\u0026#34;\\n%1你好,你是否是男生(%2),你的生日是%3\u0026#34;,name,sex,birth using \u0026#34;yy/mm/dd\u0026#34;) 你会发现，prompt除了可以转换资料类型，还能够限制可以输入的字数。（一个中文汉字需要yi\\一个varchar(3)）\n练习\r#\r编写一个程序，首先输入一个日期a，然后输入一个整数b，计算a经过这个b天后的日期是哪一天。计算后将结果在控制台打印。 "},{"id":53,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/4.variable/","title":"4.变量","section":"第四章 存储和获取数据","content":"\r变量\r#\r变量定义\r#\r变量定义，变量申明，都是同一个意思的两种翻译方法。\n在定义变量的时候，需要给这个变量-一个名字。有了名字之后才能使用这个变量。回顾曾经编写的BDL语言代码，可以发现这些代码中，凡是用双引号括起来的部分，都是字符串。 那些没有用引号括起来的单词，一部分是C语言提供的关键字，比如integer，string等， 还有一部分是BDL语言提供的符号，如=、+、-、()、{}等，这些单词和符号就是BDL语言的核心部分，编译器生来就认识它们。 另外没有使用双引号括起来的单词，如define a integer,其中的integer是关键字，a就是非BDL语言的关键字，对于编译器来说，它是不认识的。 要让编译器知道这个单词是什么意思，所以有了定义(define)。\n对于变量来说，变量的定义会使得编译器在变量符号表中新增一条记录。 这样编译器在后面如果读入了一个变量名，通过查询符号表，就知道是否声明过了。\n一行可以定义多个变量 define a,b,c integer 一样也可以拆成两行 define a, b, c integer 每行也可以只定义一个变量 define a integer define b integer define c integer 变量定义的顺序可以打乱 define b integer define a integer define c integer 不同类型可以定义在同一个define中，但必须指定每个不同类型变量的数据类型 define a, b integer c varchar(10) 定义变量的意义\r#\rBDL为什么要规定要先定义变量呢？ 为什么要指定变量的名字和对应的数据类型呢？\n建立变量符号表 通过声明变量，编译器可以建立变量符号表，如此一来，程序中用到了多少变量，每个变量的类型是什么，编译器非常清楚。如果使用了没有声明的变量，编译器在编译期间就可以发现，从而帮助程序员远离由于疏忽而将变量名写错的情况。下面演示了写错变量名后编译器编译时的提示信息。\ndefine a integer let a = 1 let b = a * 10 display b 编译提示变量未定义\nczzi001 .............. ../42m/czz_czzi001.4gl:5:5:5:5:error:(-4369) The symbol \u0026#39;b\u0026#39; does not represent a defined variable. ../42m/czz_czzi001.4gl:6:9:6:9:error:(-4369) The symbol \u0026#39;b\u0026#39; does not represent a defined variable. The compilation was not successful. Errors found: 2. The file \u0026#39;../42m/czz_czzi001.err\u0026#39; has been written. 变量的数据类型指示系统分配多少内存空间 变量需要存储空间来存储。不同的数据类型占据不同的空间大小。在声明变量时需要指定变量的数据类型，因而可以准确地为变量分配确定大小的内存空间。 比如integer x,则分配4个字节的空间: float y，则y占用了8个字节的空间。\n变量 变量的数据类型指示了系统如何解释存储空间中的值。 读者已经明白，同样的数值，不同的类型将有不同的解释。 integer占 据4个字节，float也占据4个字节，在内存中同样也是存储的二进制数，并且这个二进制数也没有标志区分当前是integer型 还是float型。 如何区分?就是通过变量的数据类型来区分。 由于声明建立了变量符号表，所以系统知道变量该如何解释。\n变量的数据类型确定了改变了的取值范围\n不同的数据类型有不同的操作\n例如：整数可以做除法，但字符串就不可以，编译时就报错\n标识符和关键字\r#\r在定义变量时，要高速编译器变量的名字。\n这个名字被称作标识符，简单地说，标识符就是一个名字，一个在某范围内唯一的名字， 通过这个名字，就能找到一个唯一与之对应的对象。 变量名，通过名字可以找到变量的值;符号常量名，通过名称可以找到符号常量代表的实际值:函数名，通过名字可以调用函数;数组名、类型名、文件名等都是一个标识符。 在很多时候，将标识符简称为ID,就是identifier的前两个字符的缩写。 标识符必须在某个范围内是唯一的，所谓某个范围内，在以后的章节会继续讲述。 正如在中国，身份证是一个人的ID，在全中国唯一，通过身份证ID就能找到一个具体对应的人。\nBDL语言规定，标识符只能由字母(26个小写字母和26个大写字母)、数字(0~ 9共10个数字)和下划线(_)3种字符组成。 并且标识符的第一个字符不能是数字，也就是只能是字母或者下划线。 BDL语言规定，标识符不区分大写字母和小写字母，即大写定义的标识符小写也可调用，反之亦然。\n合法标识符：\nsum,yes,no,success,student 不合法标识符：\n1year,#year,M.D,m-d BDL语言中的关键字保留不能用作标识符。\n变量标识符规则\r#\r变量名一般小写\n不同作用域以不同开头命名\n在main函数之外定义的参数，一般以g_开头（global），例如g_index,g_age 在mian函数中，或者其它function函数中，以l_开头（local），例如：l_count 在function函数中定义的参数，一般以p_开头(parament),例如：p_name 对于多个词构成的标识符号，有多种可选写法，没有规则，但应该保持一致\n驼峰 g_printEmployeePaychecks 下划线 g_print_employee_paychecks 帕斯卡 g_PrintEmployeePaychecks 变量在内存中占据的空间和变量的值\r#\r变量在内存中要占据-定的内存空间。 不同的变量类型，其空间大小占用也不同。前面章节已经说了很多次了。 现在的计算机，一般可以访问从0~ 64GB空间大小的内存，这64GB的内存空间，如何划分不同的区域，是非常有讲究的。\n计算机也一样，管理这么大的内存，也要分段管理。 就是说，从内存某地址开始到某地址结束，是操作系统使用的内存区域，普通程序想要使用那是难上加难。 在普通程序使用的内存区域里，又有很多类型的内存区域。 一般可以认为被分成了堆、栈、全局/静态存储区和常量存储区几个区域。 这些区域有各自的特点。 常量当然是放在了常量存储区里，所以保证了数据不被修改。 变量放在其他的几个区域。\n所谓“栈”，就是那些在需要的时候由系统分配，在不需要的时候自动清除的变量存储区。 里面的变量通常是局部变量、函数参数等。 注意是编译器在编译的时候分配的。在“栈”中分配内存，其内存大小在编译的时候就知道。\n所谓“堆”，就是那些由程序员调用系统内存分配函数分配的内存块。 编译器并不知道需要分配多大的内存，在程序运行的时候，根据需要来动态分配。这些分配的内存，完全由程序员管理，编译器不会释放。\nfunction foo() define x integer let x=3 display x end function 这是一个函数定义。 当该函数被调用时，系统根据函数的定义，将x在内存分配了一块4字节的内存。 x的生存周期时foo函数的生存周，当end fucntion结束后，函数就结束了。 这个时候，x在内存分配的预对于x来说已经无效了，x就不存在了，与x关联的内存空间可以被其它变量关联了。\n如果对以上叙述不理解的话，可暂时不用深究，有这个映像就可以了。\r读者要分清楚变量名和变量的值。let x=3 此时x是变量名，3是常量，通过赋值符“=”,使得变量x的值变为了3。 在BDL语言中，直接通过变量名，可以访问到变量的值。 display x 通过变量x， 得到了变量x的值了。\n变量赋初值\r#\r在程序设计中，经常要对一写变量预先设置初值。 所谓初值，就是分配内存后填入的第一个值。\nBDL语言中每个类型的初始值不同：\ninteger 默认初始值为 0 float/decimal/string/varchar/char 初始值为null "},{"id":54,"href":"/docs/BDL/1.basic/3.composition_of_bdl/4.call-function/","title":"4.函数调用","section":"第三章 最简单bdl程序的组成","content":"\r函数调用\r#\r看如下代码\ndisplay sfmt(\u0026#34;\\nhello world\u0026#34;) 这一行我们调用了，一个sfmt的函数，小括号中内的双引号括起来的文字是sfmt函数的参数。 该函数的功能就是把小括号的文字变为字符串，而display的功能就是将一个字符串功能打印出来。如果双引号内容改变，打印在控制台的内容也会改变。\n说明\n“\\n”在这里有特殊的含义，读者可以发现“\\n”并没有在屏幕中打印出来。 “\\n”中的“\\”是转义字符，表示其后面紧跟的字符有专门的意思。“\\n” 表示将光标移到第二行第一格。也就是回车换行的意思。\r请读者注意函数定义和函数调用有如下的不同之处。\n简单地说，所谓函数定义就是程序员编写程序代码，去实现函数的功能。 请读者注意，定义好的函数不-定会被调用。 比如BDL语言提供的大批库函数都已经实现，但是程序员编写程序并不会用到库函数中的每一个函数，只是从中挑选有用的库函数来使用。\n函数调用就是调用已经编写好的函数，这些已经编写好的函数，可以是程序员自己编写的，叫做自定义函数;有的是BDL语言系统提供的函数，叫做库函数;有的是第三方提供的函数，叫做第三方库函数。BDL语言系统向程序员提供了非常丰富的库函数，以方便程序员使用。\n本例中，sfmt函数被主函数main调用。sfmt函数的定义读者是看不见的，当然也看不见sfmt函数的代码，也就不清楚sfmt函数是如何实现的。\n"},{"id":55,"href":"/docs/BDL/1.basic/2.first_code/4.debug/","title":"4.调试排错","section":"第二章 第一行代码","content":"\r调试排错-查看代码如何一步步执行\r#\r程序员的主要工作之一是编写代码。 代码从无到有，需要诸葛字符输入，工作量显然比较大。 但实际上，编码容易调试难。 代码编写完毕后，程序员将会法非大量时间进行错误或者问题的排查、修改。 在电脑系统程序中，将隐藏着的一些未发现的缺陷、问题或者错误，成为bug。\ndebug\u0026ndash;由来\r#\r马克2号（Harvard Mark II）编制程序的格蕾丝·霍珀（Grace Hopper）是一位美国海军准将及计算机科学家，同时也是世界最早的一批程序设计师之一。有一天，她在调试设备时出现故障，拆开继电器后，发现有只飞蛾被夹扁在触点中间，从而“卡”住了机器的运行。于是，霍珀诙谐地把程序故障统称为“臭虫（BUG）”，把排除程序故障叫DEBUG，而这奇怪的“称呼”，竟成为后来计算机领域的专业行话。\n调试水平的高低，很大程度上显示出程序员能力的高低。 可以说，不会调试的程序员，是不会开发出好的软件的。\n幸好，无论tiptop gp还是t100都集成了调试工具，运行r.d2+ czzi001(t100为r.dg czzi001)。\n看除了我们写的代码还多了一些代码，这些是tiptop gp自动加上的代码，是已经打包在编译连接中的代码，所以我们无法去除，这也是我们必须要写第一行databse ds的原因，这些自动增加的代码中需要连接数据库。\n设置断点\r#\r断点是为了方便程序员在调试过程中观察程序内容个状态而专门设置的一种调试手段。 也是在调试模式下运行程序的过程中，档程序语句运行到设置的断电时，暂厅程序运行，但是程序当时的内容、寄存器、上下文环境等数据都被保存，并且代码中指示出当前停留在代码哪一行。然后程序可以不慌不忙地利用调试器查看程序内部状态。\n如何设置断点\r#\r在调试器中设置断点，先用鼠标或者方向键，将活动行移动到你需要设置断点的代码行上，然后按下F9键、点击Toggle按钮或者双击当前行即可设置断点，重复操作即可取消断点。\n调试运行\r#\r设置完断点之后，可以通过F5键(Run/Cont按钮)在调试器中启动程序。程序启动后，当运行到断点代码行后，程序暂停\n此时程序暂停于当前设置的断点代码行处，可以发现一个小箭头标识在终端行左侧。这表示当前运行的代码行。 此时这个程序已经运行起来，不过出于暂停状态，可以看到控制台没有“Hello World”输出，这表示当前代码行还未运行。 按F10键（Step Over按钮），可单步运行。每按一次F8键，就运行一行代码，直到程序运行结束。如果不想但不运行，可以直接F5键接着运行到下一个断点。如果后续没有断点，会直接运行到程序结束。 运行结束，程序提示正常退出 "},{"id":56,"href":"/docs/BDL/1.basic/1.before_all/4.program-life-cycle/","title":"4.程序开发生命周期","section":"第一章 踏上征程前的思想动员","content":"\r程序开发生命周期\r#\r在windows 下，利用记事本这个软件，输入并编辑文件可以保存一个.txt后缀名的文件。类似的还有.xlsx。它们都可以通过记事本或者excle这类的软件打开，但本身是无法运行或者展现内容的。\n那么你有没有想过如何产生一个.exe可执行文件呢。\n聪明的你一定知道了。 是的，通过编写某种语言的源代码，编译成功通过后，在经过链接，成功后就可以产生一个可执行的文件。这就是所谓的程序。\n编写BDL源代码\r#\r关于环境的说明\n如果你是使用鼎捷系列软件，那么你需要新建一个程序代码，如何建立本书不会介绍。\n如果你要学习，可以见TIPTOP相关书籍，本书只介绍代码部分。\n由于t100与tiptop gp编译和链接代码也不同，所以本书以tiptop gp命令为主，如果你使用不同的系统，请自行替换为你系统的代码。\n例如：tiptop gp 使用r.l2 连接，t100使用r.l 连接。\n为什么不以底层fgllink写呢，因为license原因，有的环境可能不允许使用这类命令，所以不再赘述。\n编辑BDL源代码\r#\r编辑BDL源代码就是做如下工作：\n逐个输入字符，如汉字、英文、标点符号或者其它可以用键盘输入的字符 通过插入、删除、移动、复制、粘贴等方法修改已经输入的字符 将输入修改完毕的所有字符保存到硬盘上 一篇由汉字、英文、标点符号或者其它可以用键盘输入的字符的内容被称作文本。 能够进行文字编辑的软件被称作编辑器。\n通俗的将，源代码就是程序员输入编写的符和BDL语言语法规则的文本。 如下片段就是一段源代码:\nmain display smft(\u0026#34;Hello World!\u0026#34;) end main 扩展名用.4gl标识其为一个BDL源代码文件。源代码文件简称源文件。\n编辑器的功能很大程度上能够帮助程序员提高工作效率。只要能输入文字的文本编辑软件都可以作为源代码编辑器。 如记事本软件、字处理软件Word、vs code等。但是专业程序员一般采用专业源代码编辑器，如业界鼎鼎有名的编辑工具由VI/VIM、Emacs/XEmacs等。 一个好的源代码编辑器、要求具备关键字着色功能（可以使用不同颜色标识diamagnetic的不同部分）、优秀的代码跳转功能、代码自动不全功能等。\n编译BDL源代码\r#\r编译时BDL源代码翻译成用二进制指令标识的目标文件。 这里的目标文件与机器语言还有一段距离，并不是真正的机器语言，所以不能被计算机直接运行。\n编译过程由编译系统程序完成。编译程序简称为编译器。编译程序运行后，自动对源程序进行句法和语法检查，当发现错误是，就将错误的类型和所在位置显示出来，帮助修改程序中的错误。 用户可以继续利用编辑器对源程序进行修改。修改后，重新编译，直到编译通过为止。\n连接目标文件\r#\r多个源代码文件经过编译后产生了多个目标文件，此时还没有将其组合装备为一个可以运行的整体，因此计算机还是不能执行。\n连接过程是用连接程序将目标文件、第三方目标文件、BDL语言提供的运行时的一些函数装配为一个完成的可执行的目标程序。连接程序检查连接器。\n编译连接过程示例\r#\r有时候为了叙述方便，将编译和连接两个步骤，统一用编译一个词语代替，读者应该清除实际经历了两步。\n当源代码没有报错是，编译连接过程如下： 当编译时，不会产生目标文件，如下： 现在你可能还看不懂提示信息的含义，不用担心，后面章节会慢慢了解到。现在你只要关注如果源代码错误，会出现什么情况即可。\n有时候编译通过了，但连接不一定通过。如下： 运行程序\r#\rBDL程序部署在服务器，在服务器端运行，需要本地电脑开启GDC客户端，并确定端口正确。\n运行的命令为exe2 czzi001,czzi001为程序编号。\n"},{"id":57,"href":"/docs/BDL/2.medium/14.database/5.select-rows/","title":"5.多笔查询","section":"第十四章 数据库使用","content":"\r多笔查询\r#\r在上一节中我们学会了多种方式查询数据中数据，且即使多条结果，也能够灵活查询。\n这节我们将重点介绍多笔查询的注意点，和进阶查询语法FOREACH。\nFETCH\u0026ndash;进行多笔查询\r#\r在上一节中我们用FETCH可以查询一条数据，也可以查询多比数据。\n现在我们假设有一个需求，查询数据中ima_file中字段ima01以E开头的所以资料。并将查询的结果保存到一个数组中。\n让我们利用上一节的FETCH来完成上述需求。\ndefine l_ima dynamic array of record like ima_file.* define l_cnt,l_i integer define l_sql string -- 获取查询结果的资料总笔数 let l_sql = \u0026#34;select count(*) from ima_file where ima01 like ? \u0026#34; prepare ima_cnt from l_sql execute ima_cnt into l_cnt using \u0026#34;E%\u0026#34; -- let l_sql = \u0026#34;select * from ima_file where ima01 like ? \u0026#34; declare ima_sel cursor from l_sql open ima_sel using \u0026#34;E%\u0026#34; for l_i = 1 to l_cnt fetch absolute l_i ima_sel into l_ima[l_i].* -- 有任何错误退出，并提示 if sqlca.sqlcode then message sqlca.sqlcode exit for end if end for 我们使用fetch能够完成上述需求，但查询多笔资料时，我们需要提前知道查询结果的总笔数，否则在查询超过笔数的资料时，会报错并退出程序。\n上面代码我们使用了大量的代码，来避免查询时因为笔数而导致报错。实际上我们还有另一个语法专门用来只查询多笔资料。\u0026ndash;FOREACH\nFOREACH\u0026ndash;多笔资料查询语法\r#\rFOREACH语法专门用来查询多笔资料，它的语法如下：\nforeach cusor1 (using para1,...) into ... ... end foreach 它是一个块语法，类似FOR循环。它的开始类似于fetch语句，不过它还可以接受一个可选的using参数。\n在foreach和end foreach之间，你可运行任何你想要运行的语句，你也可以任何语句都不写。\n我们将之前需求，用foreach语法改写：\ndefine l_ima dynamic array of record like ima_file.* define l_sql string define l_cnt integer let l_sql = \u0026#34;select * from ima_file where ima01 like ?\u0026#34; declare ima_sel cursor from l_sql let l_cnt = 1 foreach ima_sel using \u0026#34;E%\u0026#34; into l_ima[l_cnt].* if sqlca.sqlcode then message sqlca.sqlcode exit foreach end if let l_cnt = l_cnt + 1 end foreach 上面代码比起FETCH语法减少了不少长度和变量的使用，SQL语句也减少了一个。\n在进行查询结果的每笔资料都需要的场景，我们建议是直接使用FOREACH语句。\n如果你的查询可能并不是每笔资料都需要，例如：你只想要看第一笔，然后调到最后一笔，或者从最后一笔向前看几笔。这种场景一般使用FETCH语法。\n"},{"id":58,"href":"/docs/BDL/2.medium/11.array/5.practice/","title":"5.练习","section":"第十一章 数组-同一类型的多个元素的集合","content":"\r练习\r#\r定义一个字符串数组，并输出每个字符串字符对应ASCII的值\r#\r字符串数组的值分别为\u0026quot;A\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;d\u0026quot;,\u0026quot;e\u0026quot;,\u0026quot;F\u0026quot;,\u0026quot;G\u0026quot;\n写出下列代码输出结果\r#\rdefine i,j integer define a array[4] of integer let a[1]=1 let a[2]=2 let a[3]=3 let a[4] =4 for i = 1 to 4 for k = 1 to i let a[i] = a[j] - a[i] end for end for for i = 1 to 4 display sfmt(\u0026#34;%1\u0026#34;,a[i]) end for "},{"id":59,"href":"/docs/BDL/2.medium/10.function/5.practice/","title":"5.练习","section":"第十章 函数入门-写程序就是写函数","content":"\r联系\r#\r自定义一个函数，计算你的存款利率。\r#\r例如输入10000块钱，定期存款3个月，那么3个月后你拥有多少钱？\n假设月利息3.1%\n"},{"id":60,"href":"/docs/BDL/1.basic/9.over_and_over_again/5.practice/","title":"5.练习","section":"第九章 循环结构--一遍又一遍","content":"\r练习\r#\r以下代码输出结果是什么\r#\rdefine i,j integer let i = 1 let j = 3 while j\u0026lt;5 or i\u0026gt;3 let i = i + 1 let j = j + 1 display \u0026#34;*\u0026#34; end while 根据以下代码，写出变量a和b的值\r#\rdefine a,b integer while a \u0026gt; 0 let b = b + 1 let a = a - 2 end while display sfmt(\u0026#34;\\na=%1,b=%2\u0026#34;,a,b) 已以下这种格式控制台打印99乘法表\r#\r1*1=1\r1*2=2 2*2=4\r1*3=3 2*3=6 3*3 =9\r...\r1*8=8 2*8=16 3*8=24 ... 8*8=64\r1*9=9 2*9=18 3*9=27 4*9=36 ... 9*9=81 "},{"id":61,"href":"/docs/BDL/1.basic/8.condition/5.practice/","title":"5.练习","section":"第八章 条件判断-分支结构","content":"\r练习\r#\r#\r"},{"id":62,"href":"/docs/BDL/1.basic/6.operators_and_expressions/5.type-conversion/","title":"5.类型转换","section":"第六章 运算符和表达式-程序基本构成","content":"\r类型转换\r#\r前面章节中大家已经廖家，整数和浮点数在计算机中表示方法不同，占据的内存空间大小也有所不同。\n如果某下时候，需要将一个integer类型数据存储到decimal类型变量中。此时就需要进行转换。这种不同类型的数据进行转换就称作类型转换。\n自动转换\r#\rBDL中为了使编程简单，几乎所有数据类型都可以自动转换。 例如你可以写这种代码\ndefine a integer let a = \u0026#34;12345.23\u0026#34; 字符串将自动转为整数12345，同样，整数也会自动转为字符串。\n不过要注意之前我们说using的时候，数值类型转字符串会自动补空格。\n但是如果我们要是一个无法理解的内容，会如何自动转换呢？\ndefine a integer let a = \u0026#34;你好\u0026#34; 如果你在debug中查看会发现a的值会变为null，如果非法值转换，所有变量都会变为null，这将丢失之前变量的值!\n哪些情况会自动转换呢\r#\r赋值 无论是let还是returning都会自动转换为目的变量类型\n传参 参数部分后续会详细讲，sfmt(\u0026quot;%1\u0026quot;,1)这个函数中\u0026quot;%1和1就叫做参数，1会自动转为字符串。\nSQL语句 select ima01 from ima_file where ima01 = 2234 SQL语句后续会详细讲，这里先知道有印象就好\n字符串拼接 字符串可以用两种方式凭借,和||，这两种方式都会自动转为字符串\n"},{"id":63,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/5.practice/","title":"5.练习","section":"第五章 利用键盘、鼠标与程序交互","content":"\r练习\r#\r输出一下样式的数据 +------------------+-----+\r| 姓名| 年纪|\r+------------------+-----+\r| 小| 10|\r| 小蜜蜂| 9|\r| 小明| 8|\r| 小刚| 12|\r| 小红| 24|\r+------------------+-----+ 输入身份证号，输出身份证号的后4位。 "},{"id":64,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/5.practice/","title":"5.练习","section":"第四章 存储和获取数据","content":"\r练习-几个与变量相关的经典算法\r#\r几乎每一个程序 都必须使用到变量，因为程序就是处理数据的，而数据必须存储在变量中。 本节仅举几个简单的变量使用的例子。 这些例子都是一些经 典的做法，请读者深刻理解并记住。\n累加和累乘\r#\r所谓累加，就是将一系列的数字分别相加，最后得到一个结果。 如计算1+2+3+4+5：\ndefine x integer let x = x + 1 let x = x + 2 let x = x + 3 let x = x + 4 let x = x + 5 display sfmt(\u0026#34;\\n1+2+3+4+5=%1\u0026#34;,x) 编译运行，结果为：\n1+2+3+4+5=15 代码解析\n不要认为这道算术题如此简单，让计算机来计算是大材小用。 读者要知道，通过一些简单的算术计算，可以理解编程中的一些基本技巧，为今后的真正开发软件打基础。\n这些简单的数学题，是在锻炼读者的编程能力。\ndefine x integer 定义了x为整型，整型的默认初始值为0。\n重点来关注:\nlet x = x + 1 这行代码就使用到了一个非常经典的累加算法。 这行代码是一个赋值语句。就是将赋值号“=”右边计算后所得的值，赋给左边的变量。再重申一次，这里的等号“=”是BDL语言中的赋值号，不是数学里表示相等的等号。\n该语句的运算过程是:\n先计算x+1的值，计算得到数值1。 将x+1的值(也就是1)赋给变量x。变量x现在的值是1。 来仔细分析这个过程。\n在运行该语句之前，变量x的值是0。这个是赋的初值。\n计算x+1的步骤如下:\n从内存中取得变量x的值，得到0。 CPU计算0+1,得到1。 然后将1赋值给变量x。此时变量x的值变为1。\nlet x = x + 2 同样的，这也是一个累加，取得变量x的值1，相加后赋给x，x的值是3。\n这样一直累加下去，最后得到1+2+3+4+5的值为15。 通过类似let x = x + e，就将一系列数字统统累加起来。 就像一个篮子，接受了所有丢进去的东西。\n累乘和累加类似，如计算1x2x3x4x5。如下：\ndefine x integer let x = 1 let x = x * 1 let x = x * 2 let x = x * 3 let x = x * 4 let x = x * 5 display sfmt(\u0026#34;\\n1x2x3x4x5=%1\u0026#34;,x) 编译运行结果如下：\n1x2x3x4x5=120 代码解析\n如果对累加理解的话，这里就不需要赘述了。 需要注意的是，累乘初始值就不能从0开始了。\n交换两个变量的值\r#\r假设有两个变量，x=10， y=3， 现在要求使得x=3, y=10， 该如何交换两个变量的值呢?这也是非常经典的交换算法。这些算法都是今后进行更深的算法学习的基础。 显然这里需要使用第三个变量来临时保存数值。\n如图所示， 引入第三个变量z。\ngraph TD;\rsubgraph x\rX[10]\rend\rsubgraph y\rY[3]\rend\rsubgraph z\rZ[0]\rend\rgraph TD;\rsubgraph x\rX[10]\rend\rsubgraph y\rY[3]\rend\rsubgraph z\rZ[10]\rend\rX--\u003eZ\rgraph TD;\rsubgraph x\rX[3]\rend\rsubgraph y\rY[3]\rend\rsubgraph z\rZ[10]\rend\ry--\u003ex\rgraph TD;\rsubgraph x\rX[3]\rend\rsubgraph y\rY[10]\rend\rsubgraph z\rZ[10]\rend\rz--\u003ey\r为初始转台，x=10，y=3 ，z不重要假设为0. 将x的值复制到z中，这样一来，x的值就可以放心修改。已经已经有一个备份了。 将y赋值给x，此时x已经得到y的值了。 而y可以从z中得到x的值。 4个步骤之后，x和y的值交换。 用完之后z也不需要了。 define x,y,z integer let x = 10 let y = 3 display sfmt(\u0026#34;\\nx=%1,y=%1\u0026#34;,x,y) let z = x let x = y let y = z display sfmt(\u0026#34;\\nx=%1,y=%1\u0026#34;,x,y) 编译后运行结果如下：\nx=10,y=3\rx=3,y=10 代码解析\n最重要的交换值得几行代码，可以仔细对照代码因为在日常计算中交换数据经常出现，请务必掌握。\n练习题\r#\r计算100+102+104+106+108+110得累加值\r#\r已知一个原得半径是3.0，请输出圆的面积\r#\r圆周率，请取7位小数\n"},{"id":65,"href":"/docs/BDL/1.basic/3.composition_of_bdl/5.count-1+1/","title":"5.计算1+1","section":"第三章 最简单bdl程序的组成","content":"\r计算1+1\u0026ndash;小有作为\r#\r以下代码实现了计算1+1的值。\ndatabse ds main define a,b integer --定义a,b 为整型 define y integer --定义y为整型 let a = 1 --将变量a赋值为1，此时a的值为1 let b = 1 --将变量b赋值为1，此时b的值为1 let y = a + b --将a，b的值分别取出来，计算结果后，赋值给变量y display sfmt(\u0026#34;\\na+b=%1\u0026#34;,y) --将y的值打印出来 end main 编译运行后，程序结果如下a+b=2\n代码解析\n和之前代码一样，包含了database ds，同样也只有一个main函数。这是BDL语言规定，必须编写main函数。 define a,b integer定义a，b两个整形变量 define y integer定义y整形变量 空行用于分隔变量声明部分和接下来的函数实现部分。主要是逻辑分隔，利于程序员阅读代码，对编译器来说并无意义。 let a=1 给变量a赋值1，此时a的值为1,lei是BDL的规定，赋值时必须使用。 let b=1 给变量b赋值1，此时b的值为1 let y = a + b 将a，b的值分别取出来，计算结果后，赋值给变量y display sfmt(\u0026quot;\\na+b=%1\u0026quot;,y),将y的值打印出来。这个sfmt和以前代码中的用法不同，简单说明下，更详细的解释参见后续章节。 双引号中的“\\n”，时回车换行。 “a+b=”原样输出。 “%1”中的%是格式化的起始字符，只在sfmt函数中这样用，意思是将y在这个位置显示出来。所以最后的输出是： a+b=2 "},{"id":66,"href":"/docs/BDL/1.basic/1.before_all/5.write-your-fisrt-program/","title":"5.开始你的第一个程序","section":"第一章 踏上征程前的思想动员","content":"\r开始你的第一个程序\r#\r使用你自己的编辑器，写一个输出\u0026quot;Hello World\u0026quot;的程序。 display \u0026#34;Hello World\u0026#34; 将你写的程序上传到服务器，并进行编译等一系列操作后，运行并测试是否能输出\u0026quot;Hello World\u0026quot; "},{"id":67,"href":"/docs/BDL/2.medium/14.database/6.practise/","title":"6.练习","section":"第十四章 数据库使用","content":"\r练习\r#\r创建学生资料表student\r#\r字段 数据类型 字段说明 name varchar(20) 姓名 grade varchar(4) 年级 course varchar(40) 课程名称 score number(5) 得分 输入学生资料信息，插入到数据库\r#\r如果相同已经有该姓名、年级、课程名称的资料那么更新已有成绩 如果得分小于0，或者大于100，报错，跳过这笔资料 当有20笔资料时，停止录入 姓名 年级 课程名称 得分 查询每门课的最高成绩，和平均成绩，并以以下格式显示\r#\r课程名称 平均分 最高分\ra 67 90\rb 87 99\r查询按照课程名称和成绩倒序排列显示成绩单\r#\r姓名 年级 课程名称 成绩\r小米 4 数学 78\r小红 5 语文 98\r"},{"id":68,"href":"/docs/BDL/1.basic/6.operators_and_expressions/6.operation-priority/","title":"6.运算符优先级","section":"第六章 运算符和表达式-程序基本构成","content":"\r运算符优先级\r#\rBDL中运算符具有不同优先级和结合性。\n在表达式中，各运算量参与运算的先后顺序不仅要遵守运算符优先级别的规定，还要受运算符集合的制约，以便确定自左向右进行运算还是自右向左预算。\n优先级、结合性汇总\r#\r优先级 运算符 结合性 说明 用法 13 units 左 间隔转换 (12) units day 12 ** 左 幂 x**5 12 mod 左 求余数 x mod 2 11 * 左 乘法 x*y 11 / 左 除法 x/y 10 + 左 加法 x+y 10 - 左 减法 x-y 9 || 左 连接符 \u0026ldquo;ab\u0026rdquo; 8 like 右 字符串比较 mystring like \u0026ldquo;A%\u0026rdquo; 8 matches 右 字符串比较 mystring matches \u0026ldquo;A*\u0026rdquo; 7 in() 左 清单比较 var IN(\u0026lsquo;CA\u0026rsquo;,\u0026lsquo;NY\u0026rsquo;) 6 \u0026lt; 左 小于 a\u0026lt;10 6 \u0026lt;= 左 小于等于 a\u0026lt;=10 6 \u0026gt; 左 大于 a\u0026gt;10 6 \u0026gt;= 左 大于等于 a\u0026gt;=10 6 == 左 等于 a==10 6 \u0026lt;\u0026gt; or != 左 不等于 a\u0026lt;\u0026gt;10 5 is null 左 控制判断 a is null 5 is not null 左 控制判断 a is not null 4 not 左 非 not(a=b) 3 and 左 与 a=b and a=c 2 or 左 或 a=b or a=c 1 ascii() 右 ascii值 ascii(32) 1 clipped 右 尾部去空格 \u0026ldquo;as \u0026quot; clipped 1 column 右 空白字符 display column 32,\u0026ldquo;a\u0026rdquo; 1 spaces 右 空格 a = \u0026ldquo;a\u0026rdquo;(5)space 1 sqlstate 右 sql状态 if sqlstate=\u0026ldquo;ix000\u0026rdquo; 1 sqlerrmessage 右 sql错误信息 display sqlerrmessage 1 using 右 格式化字符串 today using \u0026ldquo;yy/mm/dd\u0026rdquo; 这些不需要死记硬背，你可以随时来查看，在你不确定的时候，直接用()讲需要优先运行的包裹起来，就避免要考虑太复杂情况。\n"},{"id":69,"href":"/docs/BDL/1.basic/3.composition_of_bdl/6.variable/","title":"6.变量","section":"第三章 最简单bdl程序的组成","content":"\r变量\u0026ndash;数据从哪里来，又到那里去\r#\r在计算机程序设计中，经常要用到变量。比如在屏幕中移动光标，需要存储光标的x，y坐标，每次移动光标，就需要对坐标修改，也就是x、y的值要改变;为了得到当前光标的坐标，就需要从x、y中得到当前的值。在程序设计中这些值都是通过变量来完成的。\n变量在内存中的表现形式\r#\r变量是指其值可以变化的量。在计算机中，指令代码、数据都存储于内存中。变量也需要存储在内存中。\n类比人类的思维过程，也很容易明白为什么需要内存空间存储变量:假设现在有3个数据，分别是a=3,b=4,c=5，需要读者去计算“a+b+c\u0026quot;的值。 读者首先回忆a的值是3，b的值是4,c的值是5，然后分别用3、4、5作为计算的数得到“3+4+5=12”。 这是一个很简单的过程，思考过程几乎不花费时间。如果计算的变量超过100个，估计大部分读者都记不住这么多数据的值，需要把这些数据及其对应的数值记录在纸上或其他地方，当需要用到某个数据的时候，再去查看其对应的值。计算机中变量的作用与它类似。\n在计算机中，每个变量都被分配了一块内存空间，在这些空间里存储的就是变量的值。 变量之所以可以变化，就是这个存储空间可以存储不同的数值。存储空间里的值变化，则变量对应的值也变化。 同一个时间，内存空间里只能保存一份值，新值冲掉了原来的旧值。 每个内存单元都有编号，这些是内存的地址。如图所示。\n编译器使用变量符号表\r#\r在源代码中，每个变量都有变量名。 实际上，编译后的目标代码里并没有变量名字，而是记录着变量在内存空间中的地址。 在BDL语言中，通过变量名就可以访问到变量的值，对变量名的访问，就是对变量值的访问。\n在编译的过程中，编译器会建立-张变量符号表，该表记录的数据是:变量类型、变量名、变量地址等信息。\n变量及其使用\r#\r变量有不同的类型，如记录英文字母及标点符号，就需要字符类型(varchar) 的变量;记录整数需要整数类型integer的变量;记录实数有decimal类型的变量。这些变量都是数值类型，BDL语言还提供了其他类型的变量，详细讲解请参见后续章节的论述。\n通过上述的简单叙述，读者可以对变量有了一个大概的感性认识。再回过头来看看源代码中每行的意思。\ndatabse ds main define a,b integer --定义a,b 为整型 define y integer --定义y为整型 let a = 1 --将变量a赋值为1，此时a的值为1 let b = 1 --将变量b赋值为1，此时b的值为1 let y = a + b --将a，b的值分别取出来，计算结果后，赋值给变量y display sfmt(\u0026#34;\\na+b=%1\u0026#34;,y) --将y的值打印出来 end main define a,b integer 这是向编译器声明，以下程序将会用到两个整型变量，其名字为a和b。此时并不会进行真 正的内存分配动作，也就是此时并没有内存地址与变量名关联。\n“define”是BDL语言提供的关键字，需要定义变量时必须使用。\n“integer”是BDL语言提供的关键字，是integer (整数)的缩写，表示为整数数据类型，简称整 型。 其后紧跟的是变量名称。变量名由程序员命名。变量名称也必须是字母开头，其后的部分可以是字母、数字、下划线的组合。 在同一行中可以声明多个变量，变量间用逗号分隔。\ndefine y integer 同样是向编译器声明，以下程序会用到整型变量y。变量可以一行声明多个，也可以一行声明一个，多个变量分多次声明，意义都一样。\nlet a = 1 这是给a赋值。 “let”是是BDL语言提供的关键字，需要给变量赋值是必须使用（后面也有其它办法赋值）。 请读者注意等号“=”，“=”是BDL语言提供的运算符。 在BDL语言里的“=”不同于数学里的等号“=”。 数学中的等号是说“=” 两边相等，左右等价，可以交换。 计算机中的“=”是赋值符号，有一个运算顺序，是先计算“=” 右边的表达式的值，然后把数值赋给左边。左右不能交换。 所谓赋值，就是把运算所得的数值存储在内存中。\n当第一次访问变量的时候，编译器将给变量分配内存。所谓访问，就是“存取”，“存”，是把数据存储在内存中，“取”， 是从内存中把数据取出来。\n注意\n从内存中取数据的“取”和从篮子里把南瓜“取”出来有些区别。 南瓜从篮子里取走后，篮子里不再有任何东西，南瓜被拿走了。 而计算机内存中的取，是把数值复制出来，内存空间里面的数值并不会变化，也就是从内存空间里把数值“ 读”出来。\rlet b = 1 同样的，编译分配内容空间给变量b，然后将数值1放到对应的空间中。\nlet y = a + b 这里的“+”，也是BDL语言提供的运算符号。同数学里的四则运算中的“+”一样，进行加法运算。\n注意本行代码运算顺序：\n先获取a的值。a是变量名称，查询变量符号表，得到地址，再从地址中取到数值1。则a的值为1\u0026ndash;let y = 1 + b 再获取b的值。同样的过程，b的值也为1\u0026ndash;let y = 1 + 1 计算 1 + 1，得到数值2\u0026ndash;let y = 2 把数值2赋给ylet y = 2 display sfmt(\u0026quot;\\na+b=%1\u0026quot;,y) 把y的值打印出来。 这里同样要访问变量y去获取其值。 "},{"id":70,"href":"/docs/BDL/1.basic/6.operators_and_expressions/7.practice/","title":"7.练习","section":"第六章 运算符和表达式-程序基本构成","content":"\r练习\r#\r测试以下代码输出\r#\rdefine m,n integer define x,y decimal(20,6) let m = 1 let n = 2 let x=1.41 let t=2.5 display sfmt(\u0026#34;\\nm\u0026lt;n and y-1\u0026gt;x=%1\u0026#34;,m\u0026lt;n and y-1\u0026gt;x) display sfmt(\u0026#34;m\u0026lt;n or y-1\u0026gt;x=%1\u0026#34;,m\u0026lt;n or y-1\u0026gt;x) display sfmt(\u0026#34;not (y-1\u0026gt;x)=%1\u0026#34;,not (y-1\u0026gt;x)) 用笔计算处以下代码运行结果，然后键入系统。\r#\r看看笔算的结果和系统计算结果一样\ndefine a,b integer let a=5 let b=4 display sfmt(\u0026#34;\\n最后输出的结果是%1，但是a的值是%2\u0026#34;,a=2*8,a/4) let a=2*8 let a=a/4 display sfmt(\u0026#34;a的值是%1\u0026#34;,a) display sfmt(\u0026#34;a和b的比较结果是=%1\u0026#34;,a==b) "},{"id":71,"href":"/docs/BDL/1.basic/3.composition_of_bdl/7.create-a-function/","title":"7.设计一个BDL函数","section":"第三章 最简单bdl程序的组成","content":"\r设计一个BDL函数\r#\r用BDL语言库函数和第三方提供的函数组装程序是程序设计的\u0026ndash;条捷径和重要方法。但是，一个C程序不可能只由一个main函数组成，不能在main函数中实现所有的功能。编写程序，更多的时候需要程序员自己动手创建新的函数。\n在main函数中计算3个整数的平均数\r#\r先看以下代码\ndatabse ds main define a,b,c,y integer --定义abc为整型 let a = 1 --赋值 let b = 2 --赋值 let c = 3 --赋值 let y = (a+b+c)/3 --进行数字计算 display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y) end main 编译后运行，程序输出为\nthe average is 2 代码解析\nmain 不再赘述 define a,b,c,y integer 定义变量为整形， let ...= 1,2,3 变量赋初始值 let y = (a+b+c)/3 向编译器声明变量y为整型变量。计算a+b+c的值得到6，再整除3，得到2。 然后将2赋值给y。 “()\u0026ldquo;在这里同数学里的四则运算中的小括号“()”一样，表示需要优先运算。 “/”相当于四则运算中的除法运算。\ndisplay sfmt(\u0026quot;\\n the average is %1\u0026rdquo;,y) 在控制台中打印处y的值 这段代码计算1、2、3三个整数的平均值，最后正确打印出结果来。\n在main函数中分3次计算3个整数的平均值\r#\r如果需求变化为先计算1、2、3这3个整数的平均值后，再计算1234、2345、3456这3个整数的平均值，最后计算9876、2345、1这3个整数的平均值呢?\n方法一以下所示。\ndatabse ds main define a,b,c,y,a2,a3,b2,b3,c2,c3,y2,y3 integer --定义abc为整型 let a = 1 --赋值 let b = 2 --赋值 let c = 3 --赋值 let a2 = 1234 let a3 = 9876 let b2 = 2345 let b3 = 2345 let c2 = 3456 let c3 = 1 let y = (a+b+c)/3 --进行数字计算 let y2 = (a2+b2+c2)/3 --进行数字计算 let y2 = (a3+b3+c3)/3 --进行数字计算 display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y) display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y2) display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y3) end main 编译运行后输出如下：\nthe average is 2\rthe average is 2345\rthe average is 4074 自编函数实现计算3个整数平均值\r#\r关注以下3行代码：\nlet y = (a+b+c)/3 let y2 = (a2+b2+c2)/3 let y2 = (a3+b3+c3)/3 这3行代码将求平均值的公式使用了3次。重复的代码将使得以后的代码维护困难，因为一个地方修改，其他重复的地方也要修改。这3行代码的功能相同，虽然很简单，但是可以将其抽取出来形成-一个函数。\n具体以下所示。\ndatabse ds main define a,b,c,y,a2,a3,b2,b3,c2,c3,y2,y3 integer --定义abc为整型 let a = 1 --赋值 let b = 2 --赋值 let c = 3 --赋值 let a2 = 1234 let a3 = 9876 let b2 = 2345 let b3 = 2345 let c2 = 3456 let c3 = 1 let y = average(a+b+c) --进行数字计算 let y2 = average(a2+b2+c2) --进行数字计算 let y2 = average(a3+b3+c3) --进行数字计算 display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y) display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y2) display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y3) end main -- 函数定义：具体函数实现 -- 函数名：average -- 参数：a,b,c三个整形参数 -- 返回值：整形，返回3个整数的平均值 function average(a,b,c) define a,b,c integer return (a+b+c)/3 end function 编译运行代码，结果和之前一样。\n如何自编写函数\r#\r对上面的代码说明如下：\n函数调用 let y = average(a+b+c)\rlet y2 = average(a2+b2+c2)\rlet y2 = average(a3+b3+c3) 着3行就是在调用函数average。 2. 函数定义部分\nfunction average(a,b,c) define a,b,c integer return (a+b+c)/3 end function 函数定义的语法规则如下：\nfuntion 函数名(参数1,参数2...) define 参数1,参数2... --参数类型定义 函数体部分 end funtion 代码解析\naverage是函数名称。 名称由程序员自己决定，符合命名规则即可。 小括号内的“a,b,c”是3个参数的列表。 function下一行中，define a,b,c integer 表示3个参数都是整数类型。\nreturn是BDL语言提供的关键字。 其功能是终止函数的执行，从函数中返回到调用它的地方，并可以向调用者返回其后表达式的值。 return 作用有两个： 返回 返回值 "},{"id":72,"href":"/docs/BDL/1.basic/3.composition_of_bdl/8.statement/","title":"8.语句","section":"第三章 最简单bdl程序的组成","content":"\r语句构成程序\r#\rBDL语言有以下5中类型语句。\n表达式语句。 BDL语言中，操作者或动作可成为表达式。 例如以下示例都是表达式语句： define a integer\rdisplay \u0026#34;hello world\u0026#34; BDL还有很多中流程控制语句。 如if-else，for循环语句，while循环语句，continue，结束本次循环语句，break跳出循环语句，switch多路分支语句，goto专项语句，return返回语句。 学习到画面规格后，还将设计到input输入语句，display显示语句（这里display与现在的display不同），dialog交互等画面控制语句。 函数调用构成的函数调用语句 符和语句，将以上语句写在同一行的语句 BDL语言中最小的程序单元是语句。 另外在源代码中有一些是指示编译器如何编译的预处理器指示命令，如\u0026amp;ifdef \u0026amp;endif \u0026amp;include等。 BDL语言源代码，就是由语句和这些指示命令构成的。\n"},{"id":73,"href":"/docs/BDL/1.basic/3.composition_of_bdl/9.code-style/","title":"9.代码风格","section":"第三章 最简单bdl程序的组成","content":"\r代码风格\u0026ndash;向优秀程序员看齐\r#\r所谓代码风格，是编写代码时对代码的排版布局、如何命名代码中的变量名称、函数名称等。 一个优秀的程序员，除了代码质量高、错误少之外，另一个非常重要的标准就是代码风格。\n在很多时候，代码风格比程序的效率更加重要，代码风格的好坏可以直接看出一个程序员编程 的素质。\n优秀的代码风格如同一身得体的打扮，能够给人以良好的印象。\n初学程序设计，首先必须建立良好的编程习惯，这其中就包括代码风格。\n代码风格是很个性化的，每个程序员都会有自己的喜好和见解。\n在本书后续章节的相关内容中，将介绍一些编程中需要注意到的一些代码风格。 一些通用的风格，如每行尽量不超过80个字符，这个标准是有历史原因的，以前的编辑器一行只能显示80个字符，所以超过80字符，就得滚动才能看全。 现在的编辑器已没有这个限制，但是一行中有太长的代码依旧不利于程序员阅读;\n使用有描述意义的变量名函数名，尽量不要使用简写。\n"},{"id":74,"href":"/docs/BDL/1.basic/3.composition_of_bdl/10.practice/","title":"10.练习","section":"第三章 最简单bdl程序的组成","content":"\r练习\r#\r自定义一个函数，实现两个整数求和\r#\r找出以下代码的错误\r#\rdatabase ds main() define a,b integer define y integer let a = 10 let b= 20 let y = add(a,b) display sfmt(\u0026#34;\\n the average is %1\u0026#34;,y) end main function add(a,b) define a,b integer a+b end function "},{"id":75,"href":"/docs/BDL/1.basic/","title":"BDL基础","section":"BDL有钱途的编程语言(tiptop)","content":""},{"id":76,"href":"/docs/BDL/4.actual-combat/1.%E5%8D%95%E6%A1%A3/","title":"第一章 单档","section":"BDL实战","content":" 表单 表格 "},{"id":77,"href":"/docs/BDL/1.basic/1.before_all/","title":"第一章 踏上征程前的思想动员","section":"BDL基础","content":"\r第一章 踏上征程前的思想动员\r#\r首先恭喜你入坑，无论出于什么原有，选择了BDL语言，但我想大部门原因是因为鼎捷的ERP（tiptop gp,T\r100）。\nBDL是一门比较小众的语言，更新换代不算频繁，运行效率比较低的语言，开发其公司网址为\r4js。因为其定位是一门商业开发语言，同类型的还有SAP的abap。\n但与缺点相对的，因为商业开发语言，配套的工具（studio开发工具、数据库驱动、客户端、报表甚至移动端开发）都是完备并且打包好，有成熟的解决方案，只要你舍得套必要的费用。\n所以本书只介绍BDL语言特性，环境以及开发工具等，一概不涉及到。\n"},{"id":78,"href":"/docs/BDL/1.basic/2.first_code/","title":"第二章 第一行代码","section":"BDL基础","content":"\r第一行代码\r#\r在本章，我将带领你一起，一步步创建一个没有实际意义，但是却极其常见的程序\u0026ndash;HelloWorld。 在初学一门编程语言的时候，写一个\u0026quot;Hello World!\u0026ldquo;程序是最常见的入门方法。\n"},{"id":79,"href":"/docs/BDL/4.actual-combat/2.%E5%8F%8C%E6%A1%A3/","title":"第二章 双档","section":"BDL实战","content":" 上表单下表格 双表格 "},{"id":80,"href":"/docs/BDL/2.medium/","title":"渐入佳境","section":"BDL有钱途的编程语言(tiptop)","content":""},{"id":81,"href":"/docs/BDL/3.advance/","title":"BDL进阶","section":"BDL有钱途的编程语言(tiptop)","content":""},{"id":82,"href":"/docs/BDL/4.actual-combat/3.%E6%9F%A5%E8%AF%A2%E6%8A%A5%E8%A1%A8/","title":"第三章 双档","section":"BDL实战","content":""},{"id":83,"href":"/docs/BDL/1.basic/3.composition_of_bdl/","title":"第三章 最简单bdl程序的组成","section":"BDL基础","content":"\r最简单bdl程序的组成\r#\r在第二章，大家一起创建了第一个可运行的程序。 你对源代码可能一头雾水，不止所以，所以本章解释了第二章中Hello Wordl的源代码，先回顾以下第二章的源代码。\ndatabase ds main display sfmt(\u0026#34;hello world\u0026#34;) end main 这里我们增加一个单词sfmt，运行一下，你会发现和之前的输出一样。\n"},{"id":84,"href":"/docs/BDL/4.actual-combat/","title":"BDL实战","section":"BDL有钱途的编程语言(tiptop)","content":""},{"id":85,"href":"/docs/BDL/1.basic/4.how_save_and_get_data/","title":"第四章 存储和获取数据","section":"BDL基础","content":"\r存储和获取数据\r#\r上一章中我们对BDL语言有了一个大概的了解，认识了函数、关键字、变量和数据类型。 书和操作是构成程序的两个最基本的要素。本章详细讨论BDL语言描述数据的形式和对数据的基本操作。\n"},{"id":86,"href":"/docs/BDL/4.actual-combat/4.CR%E6%8A%A5%E8%A1%A8/","title":"第四章 双档","section":"BDL实战","content":""},{"id":87,"href":"/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/","title":"第五章 利用键盘、鼠标与程序交互","section":"BDL基础","content":"\r利用键盘、鼠标与程序交互\r#\r计算机的主要功能，是获取输入，将输入的数据计算处理后输出结果。 计算机的输入，最常见的是通过键盘和鼠标;输出，最常见的是显示器。 本章介绍如何显示字符和字符串到显示器屏幕上，以及如何接收用户的键盘输人。\n"},{"id":88,"href":"/docs/BDL/4.actual-combat/5.%E6%89%B9%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/","title":"第五章 批处理作业","section":"BDL实战","content":""},{"id":89,"href":"/docs/BDL/4.actual-combat/6.webservice/","title":"第六章 webservice","section":"BDL实战","content":""},{"id":90,"href":"/docs/BDL/1.basic/6.operators_and_expressions/","title":"第六章 运算符和表达式-程序基本构成","section":"BDL基础","content":"\r运算符和表达式-程序基本构成\r#\r计算机的主要工作之一就是运算。 这里所说的运算，不仅仅指简单的算术运算如加、减、乘，除，还包括其他的运算，如关系运算、逻辑运算等。 本章将介绍一些比较基础的运算。 另外有一些运算留在后续章节慢慢介绍。 不同的运算有不同的写法，也有不同的规则，这些规则是程序员必须遵守的规则。\n表达式是对运算进行表达的句式，经过计算，最终有一个确定的值。 在BDL语言中，表达式也有很多种，当然也有很多规则，也是需要程序员遵守的。\n"},{"id":91,"href":"/docs/BDL/1.basic/7.atoml_statement/","title":"第七章 语句-程序最小构成单元","section":"BDL基础","content":"\r语句-程序最小构成单元\r#\r如果把程序和写小说类比、常量、变量等可以堪称是字和词，函数可以看成一个段落，运算符等可以看作是字词的组合方式规则，那么，字词组成的句子就是小说的最小独立单元，表达了一定的意思。 同样，程序的最小独立单元式“语句”，每个语句表达出完整的意思。\n"},{"id":92,"href":"/docs/BDL/1.basic/8.condition/","title":"第八章 条件判断-分支结构","section":"BDL基础","content":"\r条件判断-分支结构\r#\r3种基本控制结构中，顺序结构是最简单的一个，只要沿着指定的语句序列一路向下即可，无须选择、拐弯或者折回，而分支结构和循环结构相对要复杂一点，分支结构涉及从多条岔路中选择合适的语句执行，而循环结构则会重复执行某块语句，也就是说，在执行完后还要折回，再次执行。本章主要讨论几种常见的分支结构和它们的用法。\n"},{"id":93,"href":"/docs/BDL/1.basic/9.over_and_over_again/","title":"第九章 循环结构--一遍又一遍","section":"BDL基础","content":"\r循环结构\u0026ndash;一遍又一遍\r#\r所谓“循环”，就是重复多次地执行某块代码段，循环结构是C语言程序书写中常用的一种重要控制结构。\nBDL语言提供了2种循环结构，分别是while结构和for结构，本章将对其展开讨论。\n"},{"id":94,"href":"/docs/BDL/2.medium/10.function/","title":"第十章 函数入门-写程序就是写函数","section":"渐入佳境","content":"\r函数入门-写程序就是写函数\r#\r相信读者大致都了解一点数学意义上“函数”的概念，比如“y=f (x)”\u0026quot;，且不论f的具体形式如何，其基本特点是“对一个x (输入), 有一个y (输出)与之对应”。 BDL语言中，“函数”是个重要的概念，是模块化编程的基础。\n"},{"id":95,"href":"/docs/BDL/2.medium/11.array/","title":"第十一章 数组-同一类型的多个元素的集合","section":"渐入佳境","content":"\r数组-同一类型的多个元素的集合\r#\r在实际的程序设计和代码编写中，经常会用到大批同类型的数据，比如某个班学生的成绩等。为方便解决这类问题，BDL语言提供了数组这一数据结构，这里的数据结构，可理解为数据的存放和管理方式。\n和普通变量一样，在使用数组前必须先对其声明以开辟所需要的内存空间，由于数组是很多数据的集合，这些数据对应的内存单元是如何排列的，这都是本章要讲解的内容。\n"},{"id":96,"href":"/docs/BDL/2.medium/12.string/","title":"第十二章 字符串操作","section":"渐入佳境","content":"\r字符串操作\r#\r在各种编程语言中，字符串都占据着十分重要的地位，为方便用户处理字符串，BDL语言标准库函数提供了很多字符串处理函数。\n"},{"id":97,"href":"/docs/BDL/2.medium/13.struct/","title":"第十三章 结构体","section":"渐入佳境","content":"\r结构体\r#\r程序设计中，如何合理组织数据是门学问，前面介绍过的数组是种组织数据的方式，但数组只适用于同类型的数据，如果类型不同又当如何?而且在现实中，很多对象都具有不同的属性，以人为例，像姓名、性别、身高等都是其属性。如何合理存储并方便地访问这些信息，是本章要介绍的内容。\n"},{"id":98,"href":"/docs/BDL/2.medium/14.database/","title":"第十四章 数据库使用","section":"渐入佳境","content":"本章我们将介绍在BDL中使用数据库：\n连接数据库 *** record like ***** 插入数据、更新数据、删除数据 ***** 查询单条数据 ***** 查询多条数据 ***** 事务 **** 临时表 *** "},{"id":99,"href":"/docs/BDL/2.medium/15.function_plus/","title":"第十五章 函数进阶","section":"渐入佳境","content":" 无参数无返回值函数 无参数有返回值函数 有参数无返回值函数 有参数有返回值函数 数组作为参数 数组作为返回值 结构体作为参数 结构体作为返回值 "},{"id":100,"href":"/docs/BDL/2.medium/17.module/","title":"第十六章 模块","section":"渐入佳境","content":"\r模块\r#\rfglrun,fglcomp,fgllink,(fglform) debug 断点 watch b call step step in step out globals sub/lib "},{"id":101,"href":"/docs/BDL/2.medium/18.interface/","title":"第十七章 用户界面","section":"渐入佳境","content":"\r用户界面\r#\r4fd/per 文件，genero studio的使用 **** menu ** input ***** display ***** construct ***** prompt *** dialog **** Drag \u0026amp; drop * "},{"id":102,"href":"/docs/BDL/3.advance/19.exceptions/","title":"第十九章 异常处理","section":"BDL进阶","content":""},{"id":103,"href":"/docs/BDL/3.advance/20.build-in-packages/","title":"第二十章 标准包","section":"BDL进阶","content":" base Channel 文件操作 StringBuffer 文本操作 StringTokenizer 字符串分割 TypeInfo 类型操作 om xml节点操作 DomDocument DomNode NodeList XmlReader XmlWriter util DateTime 时间操作 Math 数学公式 os.Path 路径操作 com WebService Class HTTP TCP xml "},{"id":104,"href":"/docs/","title":"Docs","section":"介绍","content":""},{"id":105,"href":"/docs/BDL/2.medium/13.struct/5.practice/","title":"5.practice","section":"第十三章 结构体","content":""},{"id":106,"href":"/docs/BDL/1.basic/2.first_code/5.practice/","title":"5.练习","section":"第二章 第一行代码","content":"\r练习\r#\r编程输出中文“你好，世界！”\r#\r输出5个空行，不显示任何字符或字\r#\r输出数字1、2、3、4、5，但是每行显示一个数字\r#\r"}]