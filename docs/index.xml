<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>介绍 on BDL教程</title>
    <link>https://bdl.darcyjoven.com/</link>
    <description>Recent content in 介绍 on BDL教程</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://bdl.darcyjoven.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1.前言--抽象界面</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/1.interface-tree/</link>
      <pubDate>Tue, 29 Aug 2023 08:53:19 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/1.interface-tree/</guid>
      <description>抽象界面#在编程领域中，GUI 界面如何描述一直是桌面程序开发中的一个难题。 在 BDL 中，我们使用 XML 来描述界面，BDL 操作界面作为补充。
XML是一种标记语言，它并不是编程语言。
你如果了解HTML，那么你就可以轻松理解XML。XML是一种要求严格的HTML，但他们实际并不存在包含不包含关系。
在百度首页，按下F12，你能看到如下界面，这就是HTML语言。XML也遵循着类似的结构风格。
XML 语法# XML 语法仅需要了解即可，并不会要求能够写出一个标准的 XML。只需要了解即可。
 XML的语法非常简单，它由标签组成，标签分为开始标签和结束标签。
名词介绍#&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;note name=&amp;#34;n1&amp;#34; &amp;gt;  &amp;lt;to&amp;gt;Tove&amp;lt;/to&amp;gt;  &amp;lt;from&amp;gt;Jani&amp;lt;/from&amp;gt;  &amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt;  &amp;lt;body&amp;gt;Don&amp;#39;t forget me this weekend!&amp;lt;/body&amp;gt; &amp;lt;/note&amp;gt; 以上 XML 代码中，
  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; 是 XML 的申明
  任何一个 &amp;lt;...&amp;gt;到它的&amp;lt;.../&amp;gt;被称作元素，元素也被称为节点，是同一个意思
 以下是一个元素   &amp;lt;note name=&amp;#34;n1&amp;#34; &amp;gt;  &amp;lt;to&amp;gt;Tove&amp;lt;/to&amp;gt;  &amp;lt;from&amp;gt;Jani&amp;lt;/from&amp;gt;  &amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt;  &amp;lt;body&amp;gt;Don&amp;#39;t forget me this weekend!</description>
    </item>
    
    <item>
      <title>1.重新回顾编译链接</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/1.%E9%87%8D%E6%96%B0%E5%9B%9E%E9%A1%BE%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Mon, 28 Aug 2023 14:38:36 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/1.%E9%87%8D%E6%96%B0%E5%9B%9E%E9%A1%BE%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/</guid>
      <description>重新回顾编译链接#在第二章时，我们就介绍了r.c2与r.l2编译链接的命令。 还介绍了exe2运行的命令。
现在我们新建一个czzi004.4gl程序：
main  display &amp;#34;program code is czzi004&amp;#34; end main 我们上传在$TOP/czz/4gl目录中，运行r.c2命令：
如果环境没有问题，将输出类似下面结果:
czzi004 .............. 编译成功，因为我们没有调用外部函数，所以不用链接也可以运行。
我们使用exe2命令运行，如没有意外，会出现以下意外：
这是因为我们在tiptop gp中，未通过p_zz作业建立程序，所以系统找不到执行文件目录。
我们运行以下命令
cd $CZZ/42m fglrun czz_czzi004 ... program code is czzi004 成功运行！这是因为我们的可执行文件是在czz/42m目录下，我们来看下42m生成的文件。
cd $CZZ/42m ls -l *czzi004* -rw-rw-rw- 1 tiptop tiptop 242 Aug 28 14:46 czz_czzi004.42m -rw-rw-r-- 1 tiptop tiptop 52 Aug 28 14:46 czz_czzi004.4gl czz_czzi004.42m是4gl编译后的二进制文件，czz_czzi004.4gl是我们在使用r.d2+debug调式时需要的文件。
而fglrun命令是真正的BDL执行文件，exe2命令其实是tiptop gp专用的运行命令，所以p_zz中没有录入的程序无法用exe2运行。
既然运行有底层命令，那么编译、链接自然也有对应的底层命令。
fglcomp#还是之前的czzi004.4gl文件，我们切换到4gl目录下，使用底层函数编译。
cd $CZZ/4gl fglcomp czzi004.</description>
    </item>
    
    <item>
      <title>1.函数的参数</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/15.function_plus/1.parameter/</link>
      <pubDate>Sun, 27 Aug 2023 16:11:25 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/15.function_plus/1.parameter/</guid>
      <description>函数的参数#在BDL中除了变量定义，其它所有操作都需要在函数中进行。
所以能够灵活使用函数是编程能力重要体现，使用函数时，除了程序逻辑需要考虑，如何定义函数的结构也是值得考虑的。
函数的结构包括两部分，参数与返回值。
参数个数#函数的参数个数是无上限的，且不是必须含有参数。
&amp;laquo;&amp;laquo;&amp;laquo;&amp;lt; HEAD#0个参数#       1d67cdd5786f4fafd74c3017d23ade5bb17724be 如果你的函数不受程序的上下文影响，或者说不需要考虑调用之前做了哪些操作，那么你的函数就不要参数。
       BDL自带函数中有不少类似函数如下：
fgl_lastkey() --获取最后一次按下的按键 &amp;laquo;&amp;laquo;&amp;laquo;&amp;lt; HEAD#任意个数参数#任意个数的参数需要在在定义function时就确认，参数时变量的一种，需要定义在函数体的括号中，由,作为分隔符。
在函数中还必须定义所有参数的数据类型。 调用时传入的参数需要和定义的参数个数一样，且数据类型一致(可以转换的数据类型会自动转换)。
main  display add(1,&amp;#39;2&amp;#39;,3,&amp;#39;4&amp;#39;,...,n) end main function add(x1,x2,x3,x4,...,xn)  return x1+x2+x3+x4+...+xn function 参数类型#字符串、数值参数#在BDL中，基本类型只有两种字符串和数值，如果参数是这两种基础类型之一，那么参数是将实际的值传递到函数中。
例如：
main  define x,y string  define i,j integer  let x = &amp;#39;demo&amp;#39;  let i = 2  let j = 3  display sfmt(&amp;#39;add(i,j) is %1,i is %2 ,j is %3&amp;#39;,add(i,j),i,j)   let y = ext(x)  display sfmt(&amp;#34;x is %1 y is %2&amp;#34;,x,y) end main function add(a,b)  define a,b integer  let a = a + 1  let b = b + 1  return a+b end function function ext(x)  define x string  let x = x+&amp;#34;.</description>
    </item>
    
    <item>
      <title>1.数据库连接</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Thu, 24 Aug 2023 08:06:11 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/1.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/</guid>
      <description>数据库连接#TIPTOP GP/T100 在按照时会配置号数据库，一般为ORACLE DB，也可能是postgresql。
本章所有内容都是基于ORACLE DB，但大部门内容应该是通用的。
数据库已经配置的连接可以在文件$FGLPROFILE中看见，这里配置好的数据库都是可以在BDL中使用的。
连接数据库#在已有的BDL代码中我们经常见到在main函数外，有一个databse ds语句。
database就是连接数据库的语句，ds就是要连接的数据库。ds为TIPTOP中一个特殊的数据库，此数据保存了所有表的表结构，和同义词表的数据。
 同义词值得是不同库之间都可以使用的一个表，但此表实际只保存在ds库，每个库查看的数据内容都是相同的。
 database ds1即可切换到ds1数据库中。
main funtion main()的区别#main end main 还可以写出function的格式function main() end function。
这两者在连接数据库时是有区别main end main 会自动连接到 main之外的databse ds数据库。 而function main() end function只会用到databse ds的表结构，而不会自动连接到数据库。
 使用表结构的方法在下一节将会讲到
 除此之外他们还有另一个区别main end main需定义在一个模块所有函数之前，而function main() end function的位置没有限制。</description>
    </item>
    
    <item>
      <title>1.结构体</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/1.record/</link>
      <pubDate>Thu, 20 Jul 2023 19:25:42 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/1.record/</guid>
      <description>结构体#仍以人为例来介绍，要管理姓名、单位、E-mail地址、 联系电话等信息，现实生活中，很多人采用名片的形式，将这些信息印在一张卡片上。
收集的一张张名片大大方便了数据的管理，将这种理念借鉴到BDL语言程序设计中，是否有类似于名片的那么一种变量呢?
有，答案就是“结构体变量”，这是一种复合变量，在进一步说明结构体变量前，先来看“结构体”的概念，结构体和结构体变量的关系类似与类型与普通变量的关系，结构体中说明了结构体变量的信息格式，而结构体变量是结构体的实例。
结构体的定义#只有先完成结构体的定义，才能声明并使用结构体变量，正如，只有确定了名片，上要印什么内容，才能开始印刷名片。结构体的定义即是为了说明结构体变量要存储什么信息的过程。
define 变量 record  存储数据列表  end record 举例说明：
define person record  name,age varchar(20),  email varchar(50)  end record 上面我们定义了一个变量person，这个变量没有实际的累计，既不是字符串也不是数字。而其内有有另外类似变量的定义name、age和email。
结构体定义规则：
 每个成员名称符合标识符规则 在同一个结构体中名称不得重复 每个成员定义后要加,号，最后一个成员不能加, 与下一个成员类型一致，可以省略类型  访问结构体成员#习惯上我们将诸如字符串name、age和email在结构体变量内部这些变量称作数据成员（简称成员），有的时候也称作元素、属性。
在定义了一个结构体变量后，我们使用成员操作符号.来访问每个成员，例如person.name、person.age，分别表示person这个变量中储存的姓名年纪等信息。
提示
结构体成员，和我们之前使用的变量的方法都是使用.操作符号来访问/调用。他们的区别在于方法需要有()，而成员没有()。
我们看一段示例代码：
 define zhangsan record  name varchar(20),  age integer,  email varchar(50)  end record   let zhangsan.name = &amp;#34;zhang san&amp;#34;  let zhangsan.</description>
    </item>
    
    <item>
      <title>1.动态长度字符串</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/12.string/1.dynamic-string/</link>
      <pubDate>Thu, 20 Jul 2023 18:03:04 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/12.string/1.dynamic-string/</guid>
      <description>动态长度字符串#我们知道BDL中可以存放数据类型的类型有好几种，string、char、varchar。text和byte有特殊不再本章讨论范围。
对于定长类型varchar、char也不再本章讨论范围内。之后所说字符串特指string类型的字符串。
所以要处理除了string类型的字符串，需要先转换为string类型。
如果最大长度允许，string 与char、varchar在大部分地方都可以自动转换。但在SQL语句中无法自动转换。
注意
BDL4.01版本之后string类型也可以用于SQL中。
字符串的方法#字符串的处理，就是通过BDL预定义的方式实现的，因为方法是绑定数据类型，所以char和varchar都是不能调用字符串string的方法的。
拼接字符串#语法
append(a string) returning s string 使用案例
 define s stringlet s = &amp;#34;darcy&amp;#34;let s = s.append(&amp;#34;.joven&amp;#34;) 除了调用方法，拼接字符串还有很多其它方式。
 逗号拼接   define s string  let s = &amp;#34;darcy&amp;#34;,&amp;#34;.joven&amp;#34; 这是最常用的字符串拼接方法 2. ||拼接
 define s string  let s = &amp;#34;darcyjoven&amp;#34;||&amp;#34;&amp;#39;s blog&amp;#34; 这种方式与逗号拼接区别在于，不能存在空值，有任意一个字符串为空值，最后的结果都为空值 3. sfmt()拼接
 define s string  let s = sfmt(&amp;#34;darcy%1&amp;#34;,&amp;#34;joven&amp;#34;) sfmt()拼接的好处在于：非字符串类型为显示转换。</description>
    </item>
    
    <item>
      <title>1.什么是数组</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/1.what-is-array/</link>
      <pubDate>Thu, 20 Jul 2023 13:45:07 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/1.what-is-array/</guid>
      <description>什么是数组#程序经常使用同类型的数据，比如要处理某个班级的学生成绩信息，如果只有几个学生，我们可以使用几个同类型的变量，比如：define mark0, mark1, mark2, mark3, mark4 integer;` 这样，便可以存放5个学生的成绩，但如果是几百人呢?要一直这么写下去吗?如果读者觉得继续写下去没什么不妥的话，那几千甚至几万人呢!所以，如何合理组织大量同类数据是个问题。
在这种应用背景下，数组应运而生，成功解决了上述问题。
数组是一大片连续的存储空间#声明一个数组时，编译器为数组分配内存存储空间，以存放多个同型数据。每个数据称为数组的一个元素，要存储的元素个数称为数组的大小，元素的类型称为数组的类型。数据占据的内存空间大小取决于数组的大小和类型，而且，编译器为数组分配一片连续的内存空间。很容易计算数组占据的内存大小和每个元素对应的内存首地址。
下图，形象地示意了数组占据内存空间的情况，其中每个小方框代表一个内存字节，smallint占据2个内存字节，因此，数组中每个元素占据2个内存字节。
数组元素的访问#下面来看要解决的第2个问题“每个数据应当有唯一的标识符进行读写和查找”，这是通过下标来实现的。以一-维数组为例，元素的访问形式为:
数组名[下标] 举例来说，有一个数组，名为mark,里面记录着全班60个人的成绩，mark中的第1个元素可写为mark[1]，第2个元素为mark[2]，第3个元素为mark[3]，以此类推，第60个元素为mark[60]，好了，结束。有效的下标为1到N,不在此范围的下标访问都会引发越界错误。 线界错误是初学者经常犯错的地方。
了解了数组的基本组织形式，下面具体看一下如何使用数组解决实际问题。</description>
    </item>
    
    <item>
      <title>1.什么是函数</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/1.what-is-function/</link>
      <pubDate>Thu, 20 Jul 2023 10:09:06 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/1.what-is-function/</guid>
      <description>什么是函数&amp;ndash;根据输入进行处理返回输出#代码编多了会发现一个问题:一些通用的操作，比如交换两个变量的值、对一组变量进行排序等，可能在多个程序中都会用到，不仅如此，在单独一个程序中也可能会对某个代码段执行多次。
问题
有必要在每次执行时都把该代码段书写一次吗?这不仅会让程序变得很长，而且难以理解，使可读性下降。
分割#为了解决以上问题，C语言将程序按功能分割成-.系列的小模块，所谓“小模块”，可理解为完成-定功能的可执行代码块，称之为“函数”。
函数是BDL语言源程序的基本功能单位，打个比方，可以将函数视为一个黑盒子，或“加工设备”，从一头输人数据(原材料),从另一头就可以得到结果(产品)。至于函数内部是如何工作的，外部并不关心。 C语言源程序均是由函数组成的，在前面章节中给出的示例代码，只有一个main函数，这仅适用于比较简单的问题，实际的程序往往由多个函数组成。函数的调用是由另&amp;ndash;个函数发起的，举例来说，在A函数中调用B函数，从B函数的角度上说，A函数可视为外部函数,外部函数A对“函数B是如何定义的，功能是如何实现的”毫不关心，A对B所知道的仅限于输入给B什么，以及B输出什么。
标准函数、lib/sub函数和自定义函数#为了方便解决一些基本问题，BDL语言提供了一些标准函数。 除此之外，tiptop gp和T100都集成了一些经常使用的函数。
 注意这是产品提供的，不是BDL语言提供的，可以被修改，增加。
 除了上述函数外，BDL也允许用户自定义函数以便灵活解决各种问题，用户可以将自己的算法编写为一个个相对独立的函数模块，用调用的方法来使用函数。
从某种程度上说，BDL全部功能都是由这样或那样的函数实现的。</description>
    </item>
    
    <item>
      <title>基础练习题</title>
      <link>https://bdl.darcyjoven.com/docs/Practice/basic/</link>
      <pubDate>Thu, 20 Jul 2023 10:09:06 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/Practice/basic/</guid>
      <description>基础练习题#基础练习题目，并不是指难度基础，而是不涉及到除了语言特性其它的范围。
不涉及到画面规格（GUI）、和数据库等，专注于 BDL 基础语法。
反而某些题目难度可能很大，不必强求所有题目都能解出，果断时间再来看，可能就可以解出了。
第 1 题# 已完成√
 题目： 有 1、2、3、4 四个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？
程序分析： 可填在百位、十位、个位的数字都是 1、2、3、4，组成所有的排列后再去掉不满足条件的排列。第 2 题# 已完成√
 题目： 企业发放的奖金根据利润提成。
 利润(I)低于或等于 10 万元时，奖金可提 10%； 利润高于 10 万元，低于 20 万元时，低于 10 万元的部分按 10%提成，高于 10 万元的部分，可提+ 成 7.5%； 20 万到 40 万之间时，高于 20 万元的部分，可提成 5%； 40 万到 60 万之间时高于 40 万元的部分，可提成 3%； 60 万到 100 万之间时，高于 60 万元的部分，可提成 1.</description>
    </item>
    
    <item>
      <title>1.构造循环</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/1.create-cycle/</link>
      <pubDate>Thu, 20 Jul 2023 08:12:40 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/1.create-cycle/</guid>
      <description>构造循环#循环结构有两大要素:循环条件和循环体，当满足某个条件时，重复执行某些动作，直到该条件不再满足，这个表述很好地体现了循环条件和循环体的关系。
构造循环时，首先应明白要做什么，即“循环体是什么”，这是和程序的目的相关的。知道要干什么了还不够，还要明白什么时候开始做，什么时候停，如果没有设定合理的循环条件，很容易造成程序死循环，至使资源耗尽而导致电脑死机。
举个最简单的例子，要求计算从1加到100，因为本章讨论的是循环，所以我们撇开高斯的简便方法((1+100)*50=5050)。
程序的编写采用如下形式显然是不现实的:sum=1+2+3+.....+100写完这个式子就够费劲的，还好只有100个，要是有成千上万个，活活要累个半死。
在这种应用背景下，需要使用循环结构，只要一小段代码，如下。
 define i,sum integer  while i&amp;lt;=100  let sum = sum + i  let i = i + 1  end while  display sfmt(&amp;#34;\n结果是：%1&amp;#34;,sum) 输出结果是结果是：5050。
代码解析
代码中采用的是while结构，i作为加数，sum作为被加数，用以保存结果，程序的关键部分是第3~4行。
i的初始值为1，当i小于等于100时( 循环条件)，会重复执行循环体，在循环体内做了两件事情，- -是将i和sum相加，结果重新保存到sum中，二是将i增加1，一步步逼近循环结束的条件。
由此可知，循环条件和循环体相互配合完成特定的功能。一次次的循环，距离循环结束 应越来越近，避免出现死循环，试想，如果循环体中只是完成let sum=sum+i 这一操，而不对i进行修改，那么循环条件i&amp;lt;=100 的条件将一 直满足，循环永不会终止。
注意 在代码中，即使要计算1加到10000，只要将100修改为10000即可，十分方便快捷。语法规则#while 表达式  循环结构体 end while 在while结构中，表达式既可以是逻辑表达式或关系表达式，也可以是普通表达式，甚至常量或变量，判断的关键这个值是否为真（非0），下面看一下表达式仅是个变量的示例：
 define sum,i integer  let i =100  while i  let sum = sum + i  let i = i -1  end while  display sfmt(&amp;#34;\n结果是：%1&amp;#34;,sum) 编译运行后结果为：</description>
    </item>
    
    <item>
      <title>1.if语句--简单条件判断</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/1.judgment-statement-if/</link>
      <pubDate>Wed, 19 Jul 2023 19:08:57 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/1.judgment-statement-if/</guid>
      <description>if语句&amp;ndash;简单条件判断#生活中充满了选择，在BDL语言编程中同样如此。 最简单的条件判断语句是if语句，其基本格式为：
if 判断表达式 then语句1语句2...end if 判断表达式#判断表达式可以是简单的逻辑语句(逻辑表达式或关系表达式)，可以是多个逻辑语句的“与”、“或”、“非”组合，也可以是一般表达式，甚至还可以是一个变量或常量。
执行到if结构时，该表达式的值被首先计算，当判断表达式的值不为0 (真) 时，if then后花括号中的结构体代码被执行，否则，跳过if end if中的代码。
做个形象的比方，在街上购物的时候，看到某件商品，常常会这样想:如果不高于50块，就买下了，否则，就继续逛街。用if结构可表述为:
if 商品价格&amp;lt;50 then买下它end if 看一下下列代码:
 define price integer  prompt &amp;#34;请输入商品价格（正整数）：&amp;#34; for price  if price &amp;lt; 50 then  display &amp;#34;\n好，买好了&amp;#34;  end if 当输入的金额小于50时，控制台输出的结果为
好，买好了 否则为空。</description>
    </item>
    
    <item>
      <title>1.语句类型</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/7.atoml_statement/1.statement-type/</link>
      <pubDate>Wed, 19 Jul 2023 18:01:22 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/7.atoml_statement/1.statement-type/</guid>
      <description>语句类型#前文已经介绍过，BDL中有4中类型的语句，分别是表达式语句、流程控制语句、函数调用语句和符和语句。
mermaid.initialize({&#34;theme&#34;: &#34;neutral&#34;})flowchart LRa[&#34;BDL语言&#34;]b1[&#34;表达式语句&#34;]b2[&#34;函数调用语句&#34;]b3[&#34;复合语句&#34;]b4[&#34;流程控制语句&#34;]c1[&#34;运算符表达式语句&#34;]c2[&#34;赋值语句&#34;]c3[&#34;结构化语句&#34;]c4[&#34;非结构化语句&#34;]d1[&#34;条件语句&#34;]d2[&#34;循环语句&#34;]d3[&#34;限定转向语句&#34;]d4[&#34;非限定转向语句&#34;]e1[&#34;if语句&#34;]e2[&#34;case语句&#34;]e3[&#34;while语句&#34;]e4[&#34;for语句&#34;]e5[&#34;break语句&#34;]e6[&#34;continue语句&#34;]e7[&#34;return语句&#34;]e8[&#34;goto语句&#34;]a--b1a--b2a--b3a--b4b1--c1b1--c2b4--c3b4--c4c3--d1c3--d2c4--d3c4--d4d1--e1d1--e2d2--e3d2--e4d3--e5d3--e6d3--e7d4--e8表达式语句#在上一章，我们已经介绍了表达式的概念，通俗说，“有表达式组成的语句叫做表达式语句”。
表达式语句只有一种赋值表达式，在BDL中不允许计算一个值而不使用。
下属语句都是赋值语句：
 let x = 3  let x = x + 1  let y = 1 &amp;gt; 2 函数调用语句#以下语句都是函数调用语句。</description>
    </item>
    
    <item>
      <title>1.运算符和表达式</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/1.operators/</link>
      <pubDate>Tue, 18 Jul 2023 16:10:57 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/1.operators/</guid>
      <description>认识BDL语言中的运算符和表达式#在前面的章节中，已经接触过运算符和表达式了。 可以说，运算符和表达式是BDL语言的最基本构成，没有运算符和表达式，则不能编写任何程序。 程序的任务是对数据进行处理，数据是程序处理的对象，而运算符是施加给这些数据的操作。数据和运算符是表达式的基本元素。
认识运算符和表达式#最近本的运算符，莫过于加、减、乘、除四则运算了
1+12*410-20100/3 由于键盘无法输出算数中的乘号(✖)，和出号(➗)，改用*和、代替。删改你的例子都是常量参与运算，在BDL中，变量也可以参与运算，如：
define a,b,c integer let a = 0 let b = 10 b - a a +b +10 a+b+10/b 上面的每一个式子都可以称为一个表达式。 BDL中的算术表达式和普通算术中的表达式写法基本一样，运算符两边是参与运算的对象，非常容易理解； 而有些语言，其表达式的写法非常古怪，让人望而生畏。 同样地，算术运算中，除数是不能为0的，在计算机中，如果除数为0，将产生一个“除数为0的异常”。 所以上面的示例中，有一个表达式因为除数为0，将使得程序运行崩溃。
另外在给变量赋值的时候，使用赋值运算符=，如：
let a = a+b+10/b let b = a+b+10 在介绍这个运算符的时候，特别强调了它和算术运算中的等号“=”的区别。 BDL中的“=”，是将右边的值赋给左边的变量，而并不表示等号两边相等。 在BDL中，要表示两边是否相等，可用“==”表示（你也可能见到过使用一个“=”比较大小的，这样语法也没问题，但建议使用两个），即两个等号连接在一起，用来检查等号两边是否相等。 类似这种进行两个对象的大小关系比较的运算，是一种关系运算。
操作数、运算符和表达式#参与运算的对象称做操作数（operator）。 如3+5中的3和5，a+b+10中的a，b和10，他们是参与具体预算的对象。同样地：
(3+5)*a 这个表达式中，对于运算符“*”，两边的操作数就分别是(3+5)和a。 可见，操作数也可以是比较复杂的对象。 3+5也可以看做是一个加法表达式。
运算符是指定要执行某项操作的一个标志符号，它指明了对操作数所进行的运算。 如“+”号，表示了一个相加运算;“==” 号表示了一个关系判断是否“ 相等”的运算。 表达式表示一个求值的规则。 表达式是由变量、常量、运算符、函数和圆括号按一定的规则组合而成的。 BDL语言的表达式可根据运算的不同而分为不同的表达式类型，如算术表达式、关系表达式、函数表达式等。一般来说，表达式有如下的书写规则。
 运算符不能相邻。如a+-b是错误的。 乘号不能省略。如x乘以y应写成: x*y， 不能写成xy。 可用多层括号表示运算次序，括号必须成对出现，均使用小括号。  注意</description>
    </item>
    
    <item>
      <title>1.输出-处理-输出</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/1.input-proces-output/</link>
      <pubDate>Tue, 18 Jul 2023 10:55:59 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/1.input-proces-output/</guid>
      <description>输出-处理-输出&amp;ndash;这就是程序#工厂的生产车间生产出来的产品是最终的输出。
比如某药厂生产的保健药，号称是经历了80多道工序。 这些工序，当然是从输入原材料开始，每道工序处理-件事情，最终生产出包装精美的保健药品。
第一道工序，清洗，输人的是刚刚采摘下来的药材，其中，有不少的烂叶子、烂根。 清洗工序处理完毕后，输出来的是干净的有用的药材。
第二道工序，榨汁，输人的是干净有用的药材，榨汁工序处理时，添加纯净水，榨出药汁。 接着是萃取工序，将药汁中的有用的部分苹取.来&amp;hellip;.80多道工序就这样一一处理完毕， 保健 药就制作完毕。
从进场时的原材料，到最终出产的保健药，就是一个“输入一处理一输出” 的过程。 深入到药厂中的处理部分，80多道工序，每个工序也是一个“输入- -处理一输出”的过程。 没有输入，就没有处理的素材，也就没有输出。
程序就是这样，根据输人进行不同的处理，输入不同，处理结果不同，这就是程序。 没有输出的程序是没有用的;没有输入的程序，缺乏灵活性，因为运行一次后，由于处理的数据相同，下一次运行结果也&amp;ndash;样，而程序在多次运行时，用到的数据可能是不同的。
在程序运行时，由用户临时根据情况输人所需的数据，可以提高程序的通用性，增加程序的利用价值。
BDL语言中有多种多样的输出方式，大部分是封装好的函数，只要调用就可以将结果输出出来。之前我们使用的display后面直接方变量或者直接写的字符串数字，就可以将结果直接打印输出到控制到命令行。本章我们还会介绍输入和其它输出方式。</description>
    </item>
    
    <item>
      <title>1.二进制、八进制、十六进制</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/1.binary-octal-hexadecimal/</link>
      <pubDate>Mon, 17 Jul 2023 18:48:00 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/1.binary-octal-hexadecimal/</guid>
      <description>二进制、八进制、十六进制#二进制、八进制和十六进制是计算机中常用的进制形式。N进制的算法就是逢N进1。
 二进制  二进制数使用0和1两个数码来表示的书，如111110112表示二进制。它的基数是2，进位规则是“逢二进一”。
八进制  八进制是用0~7 8个数码来表示的数，如1678,进为规则是“逢八进一”。
十六进制  十六进制是用0~9和A~F 16个字符表示，如1AE16,它的基数是16,进为规则为“逢16进1”。</description>
    </item>
    
    <item>
      <title>1.BDL程序全貌</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/1.BDL-look/</link>
      <pubDate>Mon, 17 Jul 2023 14:50:50 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/1.BDL-look/</guid>
      <description>BDL程序全貌#database ds main  display sfmt(&amp;#34;hello world&amp;#34;) end main 代码很短，只有几行就建立一个可运行的程序。 代码虽小，但五脏俱全，纵观整个代码，可以总结如下特点：
  代码有单词、符号、空白组成。 单词以英语单词为主，有的单词是纯正的英语单词，如main、display、end、database；有的不是如sfmt。代码中的标点符号并不是随意输入的。 每个符号在编程中都有特定含义。 单词于单词之间用空白分割，空白可以是空格，也可以是tab制表符。个数没有限制
  BDL源码是从上往下阅读，也就是源码的先后顺序是有讲究的。
  行与行之前可以有空白行，数量也没有限制。 有的行顶格书写，有的却向后退了几个空格，这种后退，成为“缩进”。如何缩进也是有讲究的。 3. 并没有专门的标识标识文件从哪里开始，也没标识文件从哪里结束。从第一个字符开始，文件就开始了，到最后一个字符结束，文件就结束了。</description>
    </item>
    
    <item>
      <title>1.自己动手创建程序</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/1.wirte-program-by-youself/</link>
      <pubDate>Mon, 17 Jul 2023 13:19:56 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/1.wirte-program-by-youself/</guid>
      <description>自己动手创建程序#就像小学生解决应用题一样，在答题之前，必须了解题目给的条件，然后明确题目的问题，最后才是解题。 开发软件也需要这样一个过程，必须先清楚用户的需求，根据需求来进行设计和开发，不遗漏需求，也不能有超过需求的功能。
本章的目标就是创建一个可以执行的程序，并输出一句话：“Hello World”。如果读者看了这个要求就开始写代码，就烦了大忌。 这个需求起始很不明确，并没有规定如何输出这句话。 在实际的软件发开工作中，类似不明确的需求比比皆是，所以动手写代码前，一定要非常明确软件的需求。
很多曾经有过语言学习经理的读者看见上面的需求后，第一印象，认为就是在控制台打印出这句话来，然后就开始思索如何设计程序了。 但假设用户需求是用人声读出这句话呢？发声也是一种输出！ 或者用户需求是在一个窗口界面输出这句话，甚至要求这句话的大小、样式、颜色符和某种规定，那么只在控制台打印“Hello World！”的程序是不符合要求的。 所以在开发软件前，用大量的时间进行实际需求的调研时非常有必要的。 否则，花费大量时间出来的程序可能没有任何价值。
更明确的修去时：在控制台程序中，输出依据简单的文字：“Hello World！”。具体要求明确后就可以开始程序设计了。
本章只是引导大家了解BDL语言，故没有输入，只有输出。</description>
    </item>
    
    <item>
      <title>1.为什么学习（使用）BDL语言</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/1.why-dbl/</link>
      <pubDate>Mon, 17 Jul 2023 10:32:54 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/1.why-dbl/</guid>
      <description>为什么学习（使用）BDL语言#开发迅速#BDL配套的开发工具和GUI都是打包好，所以开发周期非常的短，也不需要考虑过多的事情。
程序易读性高#如果你使用过SQL查询语言，或者对数据库有一定了解，甚至对excel使用比较熟练，你会发现BDL的处理方式与它们非常相似。
不得不使用#你的公司使用了BDL语言的产品，现在要修改或者增加功能，不得不去读，写BDL程序。</description>
    </item>
    
    <item>
      <title>进阶练习题</title>
      <link>https://bdl.darcyjoven.com/docs/Practice/medium/</link>
      <pubDate>Mon, 09 Oct 2023 10:09:06 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/Practice/medium/</guid>
      <description>第 1 题#题目： 输入两个正整数，输出这两个数的最小公倍数，和最大公约数。
程序分析：
 两个自然数的公倍数是指能被两个自然数整除的最小正整数 公倍数是能够被这两个数整除的数  第 2 题#题目： 输出 1~200 之间的素数
程序分析：
素数，是只能被 1 或自身整除的整数
第 3 题#题目：
打印 100 以内除了尾数为 3、5、7 的所有自然数
程序分析：
获取一个数的个位数
第 4 题#题目： 输入一个数，判断该数是否是水仙花数
水仙花数：是指一个三位数，其各位数字立方和等于该数字本身 例如：153 就是一个水仙花数，因为 153 = 1³ + 5³ + 3³
程序分析：
获取一个数的各个位数数字
第 5 题#题目：
输入一个华氏温度，要求输出摄氏温度。公式为 c=5(F-32)/9，取位 2 小数。</description>
    </item>
    
    <item>
      <title>2.控件&amp;容器</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/2.wiget/</link>
      <pubDate>Tue, 29 Aug 2023 14:20:48 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/2.wiget/</guid>
      <description>控件&amp;amp;容器#打开genero studio，我的版本为2.40.11，请打开和 ERP 版本相对应的genero studio。
 使用fglform -V可以查看版本，只要大版本一直即可，即2.40.xx
 新建一个 4fd 文件，我这里命名为czzi002.4fd，你可以按照喜好自己行命名。
一个空的 4fd 文件看起来就是一张空白纸，我们只要将你需要的东西用鼠标拖拽到这张之上即可。
当然拖拽也是有规律的，否则无法生成你想要的画面，甚至还会报错。
在顶部菜单中不同名称的按钮，都是一个个控件和容器。
 控件：  GUI 中数据操作方法的合集叫做控件，它能够对数据进行操作。
 容器：  容器是用来包裹控件，让控件已希望的方式展现出来的元素。
容器#容器均具有本身的属性及特殊用途，容器间可相互包覆（基本物件除外），以呈现不同的效果。
不同容器清单说明如下：
   名称 功能说明 可使用的下层容器物件     Grid 简易空白画布 ScrollGrid、Table、GroupBox   ScrollGrid 有卷轴的空白画布 ScrollGrid、Table、GroupBox   Table 以表格方式显示阵列资料 无   MFArray 以画布方式显示阵列资料 无   GroupBox 将外层加上框线 VBOX、HBOX、GroupBox、PageControl、Grid、ScrollGrid、Table   PageControl 以分页方式显示资料 VBOX、HBOX、GroupBox、PageControl、Grid、ScrollGrid、Table   VBOX(Vertical layout) 将内含的物件以垂直方式排列 VBOX、HBOX、GroupBox、PageControl、Grid、ScrollGrid、Table   HBOX(Horizontal layout) 将内含的物件以水平方式排列 VBOX、HBOX、GroupBox、PageControl、Grid、ScrollGrid、Table    Grid#可将此容器视为一块空白的画布，布置在上方的元件都可以显示在画面相对位置上。</description>
    </item>
    
    <item>
      <title>2.lib和sub函数</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/2.lib-sub/</link>
      <pubDate>Mon, 28 Aug 2023 16:00:05 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/2.lib-sub/</guid>
      <description>lib 和 sub 函数#42x 文件#回顾上一节的练习，调用cl_null()函数，是不是比较简单。
但是我们来看下一下p_zz.4gl的源码中调用了多少次 lib 函数(lib 函数一般以cl开始，有误差，但误差不大)，$AZZ/4gl目录下。
cd $AZZ/4gl grep -c &amp;#34;cl&amp;#34; p_zz.4gl ... 265 调用了 265 次 lib 函数，如果按照上一节的办法，我们要找到这 265 个 lib 函数对应的文件，链接后并编译。
这实在太不方便了，所以 BDL 在链接时其实还隐藏了一个功能。
不需要额外的命令和源代码，我们依然使用czzi004.4gl和s_czzi004.4gl进行示例。
我们先删除之前生成的文件，防止影响本次结果。
cd $CZZ/4gl rm *czzi004*.42m rm *czzi004*.42r   编译 czzi004.4gl和s_czzi004.4gl，和之前一样
  单独链接 s_czzi004.42m
  fgllink -o czzi004_sub.42x s_czzi004.42m 编译 czzi004_sub.42x和czzi004.42m  fgllink -o czzi004.42r czzi004.42m czzi004_sub.42x fglrun czzi004  一样可以运行，看起来并没有减少步骤。
但是我们可以将第二步运用到整个 lib 目录下的所有文件，将所有 lib 目录下源代码都链接为lib.</description>
    </item>
    
    <item>
      <title>2.函数的返回值</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/15.function_plus/2.parament/</link>
      <pubDate>Mon, 28 Aug 2023 13:18:50 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/15.function_plus/2.parament/</guid>
      <description>函数的返回值#上一节中我们讲到，函数结构由参数和返回值决定。
这节我们介绍函数的返回值。
返回值个数#和参数一样，函数的返回值个数可以是0，也可以是任意个。
0个返回值#main 函数就是一个无返回值的参数，没有函数能够接受main函数的返回值。 同时main也是一个没有参数的函数。
main end main function main() end function 在无返回值的函数中，依然可以使用关键字return，这时return关键字的作用是结束当前函数运行，返回调用函数处。
任意数量的返回值#和参数不一样，函数的返回值个数是不需要提前定义好的。在程序执行到return处，才能确定返回值的个数和数据类型。
所以一个函数在不同情况下调用，返回值的个数有可能不同。
注意
返回不同数量的值，影响程序后续维护，除非能够快速解决当前问题，否则建议函数总是返回相同数量的返回值。
虽然返回个数不会保存，单调用函数时，必须接受每一个返回值，所以调用时，你必须知道这个函数将要返回的返回值的个数。
返回值的返回，即return后面的常量或者变量，已,作为分隔符。
例如，以下代码返回2020年的月份，如果当前不是2020年，则返回当前年份和月份。
main  define yy,mm integer  if year(current) == 2020 then  display currentYM()  else  call currentYM() returning yy,mm  display yy,mm  end if end main function currentYM()  if year(current) != 2020 then  return year(current),month(current)  else  return month(current)  end if end function 返回值类型#字符串、数值#作为基础类型，字符串和数值返回时使用对应的变量调用即可。</description>
    </item>
    
    <item>
      <title>2.数据表结构在BDL中的使用</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/2.schema/</link>
      <pubDate>Thu, 24 Aug 2023 08:36:16 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/2.schema/</guid>
      <description>数据表结构在 BDL 中的使用#在数据库中，每个表的建立都会产生表结构文件，叫做schema文件。
在我们使用数据库时，如果你需要大量的数据中的资料，不需要频繁的查询数据中的表结构，通过表结构中字段的数据类型去对应BDL中的数据类型。在BDL中已经为我们做好了这一步，ORACLE中大部分数据类型在BDL中都映射到指定的类型。
我们只要使用数据库的schema文件，就能通过数据的字段去定义BDL中的数据类型。
上一章我们学到了function main() end function这种main函数写法，只会使用表结构，而不连接到数据库，指得就是使用schema文件，而不连接到数据库。
在 BDL 中使用 schema 定义变量#只要将之前定义变量中的数据类型修改为like ds:table.cloumn 即可定义这个变量类型为 ds 库中 table 这个表的 column 这个字段在数据库中的类型。
其中ds:库名可以省略，如果省略，表示使用当前已经连接到的库。
例如:
database ds main  define l_ima01 like ima_file.ima01  define l_ima02 like ima_file.ima02 end main 除了在使用ima_file字段时，可以依据ima_file字段的名称定义，在 TIPTOP 中，常用的字段类型都定义在了type_file中，可以根据 type_file 类型定义我们经常使用的变量，如金额、库存数量、单价这些常用变量。
 type_file字段清单如下
    字段名称 数据类型 字段名称 数据类型     chr1000 varchar2(1000) chr6 varchar2(6)   chr1 varchar2(1) chr50 varchar2(50)   num5 number(5) chr37 varchar2(37)   num20_6 number(20,6) chr9 varchar2(9)   dat date chr12 varchar2(12)   chr18 varchar2(18) chr30 varchar2(30)   num10 number(10) chr14 varchar2(14)   chr8 varchar2(8) chr7 varchar2(7)   chr20 varchar2(20) chr10 varchar2(10)   chr21 varchar2(21) chr100 varchar2(100)   num20 number(20) chr200 varchar2(200)   chr3 varchar2(3) chr300 varchar2(300)   num26_10 number(26,10) chr500 varchar2(500)   chr2 varchar2(2) blob blob   chr4 varchar2(4) num15_3 number(15,3)   chr5 varchar2(5) row_id varchar2(18)    进阶使用&amp;ndash;record#在实际业务中，我们经常使用的场景是，查询一个表每个字段的数据，更新/新增一个表所有字段。</description>
    </item>
    
    <item>
      <title>2.声明结构体类型</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/2.type/</link>
      <pubDate>Thu, 20 Jul 2023 19:25:56 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/2.type/</guid>
      <description>声明结构体类型#在上一章节，我们定义了两个相同的结构体变量。
 define zhangsan record  name varchar(20),  age integer,  email varchar(50)  end record  define lisi record  name varchar(20),  age integer,  email varchar(50)  end record 这两个变量成员以及每个成员的数据类型完全一样，除了成员的值其它内容都一样。
现在成员数量少赋值一遍，还不算难，如果成员数量达到几十个的时候呢？
如果后面我要增加一个成员，难道要先找到所有的结构体变量，一次增加吗？
所以我们引用了一个新的功能&amp;mdash;结构体声明，关键字type，本章主要介绍它的使用方法。
结构体如何声明#结构体声明的示例：
 type person record  name varchar(20),  age integer,  email varchar(50)  end record 看起来和结构体变量定义完全一样，只是将define换成了type。
我们来看看如何使用：
 type person record  name varchar(20),  age integer,  email varchar(50)  end record  define zhangsan,lisi person  let zhangsan.</description>
    </item>
    
    <item>
      <title>2.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/12.string/2.practice/</link>
      <pubDate>Thu, 20 Jul 2023 19:13:40 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/12.string/2.practice/</guid>
      <description>练习#将以下数组连接起来组织为依据通顺的英语句子# define a array[3] of string  let a[1] = &amp;#34;You&amp;#34;  let a[2] = &amp;#34;Welcome&amp;#34;  let a[3] = &amp;#34;Are&amp;#34; 编程实现，成绩输入系统#要求：
 依次输入学生的姓名，语文成绩、数学成绩、英语成绩 按以下格式输出该学生的信息  姓名：小明 语文：80 数学：90 英语：85平均分：85.00 总分：255 进阶
如果要输入3名学生的成绩，并按上面要求输出，你会做吗？
</description>
    </item>
    
    <item>
      <title>2.一维数组</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/2.one-dimensional-array/</link>
      <pubDate>Thu, 20 Jul 2023 13:51:56 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/2.one-dimensional-array/</guid>
      <description>一维数组#一维数组也称向量，用以组织具有一维顺序关系的一组同类型数据，在使用数组前，必须先声明数组，编译器根据声明语句为其分配内存，这样数组才有意义。
一维数组如何定义#与简单数据类型一样，数组也由关键字define定义
define 数组名 array [size] of 类型 --定长数组 define 数组名 dynamic array of 类型 --动态长度数组 数组由两种形式：
 指定长度的定长数组 不指定长度动态长度数组  一位数组的访问#之前我们提过，数组越界的错误，对于定长的数组，超过原来长度的访问，或程序奔溃。对于动态长度的数组，访问未经过初始化的长度的时候，会对之前没有初始化的索引赋空值。
我们通过一个例子看一下一位数组的访问方式：
 define score array [6] of integer  define sum,i integer  define average decimal(10,2)  prompt &amp;#34;请输入第1名学生的成绩&amp;#34; for score[1]  prompt &amp;#34;请输入第2名学生的成绩&amp;#34; for score[2]  prompt &amp;#34;请输入第3名学生的成绩&amp;#34; for score[3]  prompt &amp;#34;请输入第4名学生的成绩&amp;#34; for score[4]  prompt &amp;#34;请输入第5名学生的成绩&amp;#34; for score[5]  prompt &amp;#34;请输入第6名学生的成绩&amp;#34; for score[6]  for i = 1 to 6  let sum = sum + score[i]  end for  let average = sum/6  display sfmt(&amp;#34;\n平均成绩：%1&amp;#34;,average) 数值的初始化#上面我们说过动态数组访问超界时会将之前数组都赋值为null，如果每次都是这样，那么不小心写了一次array[1000]，那么这个数组长度之后都从1000后开始用吗？</description>
    </item>
    
    <item>
      <title>2.自定义函数</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/2.diy-function/</link>
      <pubDate>Thu, 20 Jul 2023 10:57:44 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/2.diy-function/</guid>
      <description>自定义函数#函数的调用可能是由另一个函数触发，但函数的定义都是平行的，包括main函数在内。所谓“平行”，有两层含义，一是“不允许把一个函数定义在另一个函数内”，这说明，函数定义都要在main函数外部，二是“不同函数定义放置位置没有关系”，可以定义在main函数之前，也可以定义在main函数之后。
函数定义的语法#和变量一样，要想使用一个函数，定义是不可缺少的。
函数定义有4个要素:参数列表、返回值、函数名和函数体， 参数列表和返回值对应着输入输出， 函数名用于和程序中其他程序实体区分， 而函数体是一段可执行的代码块，实现特定的算法或功能。
函数的基本定义语法如下：
function 函数名(参数列表)  define 参数... --参数类型定义  函数体 end function  输入：参数列表  参数列表的基本形式为：
变量名1,变量名2,变量名3... 每个变量名在函数内必须定义数据类型，有些情况下，不需要像函数传递参数，此时，参数列表为空，但圆括号不能省略。 例如：
function printa()display &amp;#34;a&amp;#34;end function 输出：返回值  返回值用户返回函数的输出值。 格式如下:
return 输出值1,输出值2,... 如果没有输出值，可以只写一个return这个时候函数结束，但不返回任何值。
函数名  函数名用于标示该函数，和其它函数区分开来，因此和变量取名一样，函数名必须是合乎编译器命名规则的标识符。
函数体  函数体是一段用于实现特定功能的代码块，比如局部变量声明和其它执行语句等。注意，在函数体内声明的变量不能和参数列表中的变量同名。
函数体可以没有任何语句，此时称为空看书，表示占一个位置，以后可以将空能实现添加上。
在做软件开发规划时，这是一个经常使用的方法，在开发初期，为了在功能木块切割的同时维护程序的总体性。常常时先使用一个个的空函数将程序的框架搭起来，再逐步添加功能使程序一步步完善起来。</description>
    </item>
    
    <item>
      <title>2.for结构</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/2.for/</link>
      <pubDate>Thu, 20 Jul 2023 08:30:40 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/2.for/</guid>
      <description>for结构&amp;ndash;更常用的循环结构#阅读代码时可以发现，for结 构是应用最多的一种 循环控制结构，这大抵是因为for结构提供的控制功能更为完善，而且，相比while结构，for结构写出的代码也更为简洁，可读性也稍好。
基本形式#for 变量 = 初始值 to 目的值 step 每次增加的量  循环结构 end for 注意 这里的step关键不写的时候，默认每次+1，step还可以跟负数，如果是负数，每次判断的就是小于目的值时跳出循环。用while表示同样的表达式:
let 变量 = 初始值 while 变量&amp;lt;=目的值  循环结构  let 变量 = 变量 + 每次增加的量 end while 由此可见，要写出同样功能代码，for结构比while结构简洁易读。
for结构执行流程图：
mermaid.initialize({&#34;theme&#34;: &#34;neutral&#34;})flowchart TDa[&#34;变量 = 初始值&#34;]--d{&#34;变量是否超过目的值&#34;}c[&#34;循环结构&#34;]c--b[&#34;变量增加&#34;]b--dd--&#34;yes&#34;--e[&#34;跳出循环&#34;]d--&#34;no&#34;--c其执行过程如下：
 变量赋初始值 判断变量是否超过目的值，超过退出循环，进行第5步；不超过执行循环结构，执行第3步 自动变量增加指定的值 再判断第2步 循环结果，跳出for结构，继续向下执行  利用for结构改写我们之前计算1到100和的代码：
define i,sum integer for i =1 to 100  let sum = sum + 1 end for display sfmt(&amp;#34;\n结果是：%1&amp;#34;,sum) </description>
    </item>
    
    <item>
      <title>2.if else--两条岔路的选择</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/2.if-else/</link>
      <pubDate>Wed, 19 Jul 2023 19:16:40 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/2.if-else/</guid>
      <description>if else&amp;ndash;两条岔路的选择#还是拿买东西做比方，口袋里只有50块钱，想买一件衣服，衣服的价格标签不见了。这时，你也许会在心里盘算，问一下衣服的价格，如果价格低于50，就说“好，买了”，否则，就说“太贵了，算了”。这种“两条岔路中选一个”的流程，在BDL语言中对应着if else结构。
关键在else#改写上一章的代码，使用if else 结构，如下：
define price integer  prompt &amp;#34;请输入商品价格（正整数）：&amp;#34; for price  if price &amp;lt; 50 then  display &amp;#34;\n好，买好了&amp;#34;  else  displau &amp;#34;\n太贵了，算了&amp;#34;  end if 无论输入多少价格，输出的结果要么是好，买好了，要么是太贵了，算了。
代码解析
第一个代码中采用的是if结构，在price超过50的时候不做出任何反应，一声不吭地走开，如此看来，第二个代码中的顾客似乎更礼貌一点， 在price小于50这个 条件不成立时，会输出拒绝信息“太贵了，算了”。
如果转为流程图如下：
mermaid.initialize({&#34;theme&#34;: &#34;neutral&#34;})flowchart TDa([&#34;开始&#34;])--b[/&#34;申明变量price，并输出提示信息，请求用户输入&#34;/]b--c[/&#34;接受用户输入&#34;/]c--d{&#34;pricee[&#34;输出：&#39;好，买好了&#39;&#34;]d--&#34;no&#34;--f[&#34;输出：&#39;太贵了，算了&#39;&#34;]e--g([&#34;结束&#34;])f--g当程序流程来到if else结构时，首先计算关键字if后“表达式”的值，如果表达式的值为“真”(不为0)，代码段1被执行，否则，else关 键字后的代码段2被执行。</description>
    </item>
    
    <item>
      <title>2.结构化设计程序</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/7.atoml_statement/2.structured-design-program/</link>
      <pubDate>Wed, 19 Jul 2023 18:34:31 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/7.atoml_statement/2.structured-design-program/</guid>
      <description>结构化设计程序#结构化程序设计的思想是:把一个需要解决的复杂问题分解成若干模块来处理，每个模块解决一个小问题，这种分而治之的方法大大降低了程序设计的难度。结构化程序设计的核心问题是算法和控制结构。
什么是算法#所谓算法，指的是解决问题时的一系列方法和步骤。
算法的思维体现在生活的各个方面,比如我们要去北京旅游，会问一些问题:“用什么交通工具?”“在哪里中转?”“是否要去奥运现场?”等，这都包含着算法。
可见，算法的步骤间有一定的逻辑顺序，按这些顺序执行步骤便可以解决问题，达到目的。这种逻辑顺序，在BDL语言中体现为控制结构。
算法的表示#抛开厚厚的教科书，不去谈哪些深奥无比的属性。 本章节讨论与算法使用最为相关的问题:算法如何表示。
原则上，自然语言也可用于算法表示，但由于自然语言的多义性，不同的人对同-一个版本的描述可能有不同的理解，因此，一般不采用自然语言来描述算法，要求采用一种精确的、无歧义的机制。
有两种广泛使用的算法表示方法，一是伪代码法，二是流程图法。
算法的伪代码表示#伪代码是对自然语言表示的改进，给自然语言加上了形式化的框架，以一种简单、容易理解的方式描述算法的逻辑过程。用伪代码表示的算法无二义性，易于理解。
使用伪代码表示算法无须遵守严格的语法规则，只要完整表达了意思，书写清晰，容易阅读和读懂即可。举例如下:
用户输入：如果（用户输入的字符是Y）执行B操作否则执行C操作 上述代码便采用了伪代码表示方式，完成一种简单的分支选择结构
算法的流程图表示#流程图法是种有效、直观的算法表示方法，利用不同的框代表不同的操作，利用有向线段表示算法的执行方向。
现在通用的流程图符号画法采纳的是ANSI (美国国家标准化协会)的标准，如图所示。
mermaid.initialize({&#34;theme&#34;: &#34;neutral&#34;})flowchart LRid1([&#34;起止框，表示程序起始和结束&#34;])id2{&#34;判断框&#34;}id3[/&#34;输入输出框，表示输入输出数据&#34;/]id4[&#34;处理框，完成某些操作&#34;]subgraph a[&#34;这是连接点，如果流程太长将用词截断&#34;]id5((...))endid6--&#34;程序执行方向&#34;--id7将前面的伪代码表示转换为流程图表示，如图所示。 和伪代码方式相比，流程图方式采用了图形化的方式，更为直观，可以很清晰地反映控制结构的运作过程。
在描述基本结构时，本书尽量采用流程图方式。
以上伪代码，用流程表示如下:
flowchart TDa([&#34;开始&#34;])--b[/&#34;用户输入&#34;/]b--c{&#34;判断是否是字符Y&#34;}c--&#34;YES&#34;--d[&#34;C操作&#34;]c--&#34;NO&#34;--e[&#34;B操作&#34;]d--f([&#34;结束&#34;])e--f三种控制结构#结构化程序设计提供了3种控制结构，分别是顺序结构、分支结构和循环结构，早在1966年，Bohm和Jacopini的研究证明，用此3种基本结构可以构成任意复杂的算法。 3种基本控制结构如图所示。
flowchart TDa[&#34;</description>
    </item>
    
    <item>
      <title>2.关系运算符</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/2.relational-operator/</link>
      <pubDate>Wed, 19 Jul 2023 15:12:11 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/2.relational-operator/</guid>
      <description>关系运算符和关系表达式#关系运算就是作比较，日常生活中经常遇到一些真假判断，比如说，“张三比李四高”，“济南到北京比到上海近”，“5大于2”，这些问题的答案是真或假。
程序设计是对实际问题解决过程的模拟，长城需要左判断，像“如果这样，我就执行动作A，如果那样，我就执行动作B”。
那么怎么判断这样那样呢？ 这就需要用到关系运算和关系表达式。
关系运算符号种类#关系运算就是比较变量或常量是否符和预期，比较结果为一个逻辑值“真”或“假”。 举个简单的例子，说“x&amp;lt;10”，如果x值为9，“9&amp;lt;10”成立，故上述式子的值为“真”，若x的值为15，则“15&amp;lt;10”不成立，上述式子的值为“假”。
BDL中，“真”和“假”也是用数值来体现的，0就是“假”，其它值为“真”。
关系运算符
   运算符 描述     is null 判断控制   like 如果字符串和给定的格式匹配成功返回true   matches 如果字符串和给定的格式匹配成功返回true   相同(==or=) 判断两个值是否相同   不相同(!=or&amp;lt;&amp;gt;) 判断两个值是否不相同   小于&amp;lt; 判断左边的值小于右边   小于等于&amp;lt;= 判断左边的值小于等于右边   大于&amp;gt; 判断左边的值大于右边   大于等于&amp;gt;= 判断左边的值大于等于右边   nvl() 如果第一参数为空，返回第二个参数   iif() 如果第一个参数为true,返回第二个参数，否则返回第三个参数   in() 判断值是否在一个范围内    运算顺序#关系运算符比算数运算符优先级低，这说明：</description>
    </item>
    
    <item>
      <title>2.display与sfmt函数</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/2.sfmt/</link>
      <pubDate>Tue, 18 Jul 2023 11:25:43 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/2.sfmt/</guid>
      <description>display与sfmt函数#display函数已经接触过，是将后面的变量或者值显示到控制台的命令行中。
请尝试下以下代码，看看运行的值有何区别
 define a integer  define b decimal(20,6)  define c varchar(20)  define d decimal(10,6)   let a = 1  let b = 1  let c = 1  let d = 1  display &amp;#34;&amp;#34;  display a  display b  display d  display c  let c = &amp;#34;1&amp;#34;  display c  let c = b  display c 运行后，会发现显示如下</description>
    </item>
    
    <item>
      <title>2.字节和位</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/2.bite-bit/</link>
      <pubDate>Mon, 17 Jul 2023 18:56:08 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/2.bite-bit/</guid>
      <description>字节和为&amp;ndash;计算机表示数据的方法#程序员编写的程序以及所使用的数据在计算机中是以二进制位序列的方式保存的。 典型的计算机内存段二进制位如下：
...010010101010101010010001100111001100... 上面的二进制位序列中，每个数字，要么是0，要么是1。在计算机中，位（bit）是包含-或者1的一个单元。在物理上，它的值是一负或者一个正电荷。 也就是计算机中通过电压高低来表示以为所含有的值。 如果是0，则用低电压表示；如果是1，则用高电压表示。
在上述的二进制位序这个层次上，位的集合没有结构，很难解释这些系列的意义。 为了能够从整体上考虑这些位，于是给这些位序列枪架上结构的概念，这样的结构被称为字节（byte）和字（word）。 通常，一个字节由8位构成，而一个字由32位构成，或者说4个字节构成。
经常可能被问到的一个问题是：“存款有几位数了？”如果回答是4位数，那了不起也就是万元少点。如果回答是6位数，那就是几十万了。 日常生活中，通过十进制的位数，就可以发现要表达的数越大，需要十进制的位数也就越多。
一个字节只有8位，一个字节能表达的最大数据也就是111111112，即8位数的二进制就是255。也就是说，一个字节最大能存储的证书是255。两个字节呢？11111111111111112的十进制是65535。四个字节呢？是4294967295。32位计算机中，一个整型需要4个字节博爱是，所以最大整数是4294967295，超过4294967295之后，比如4294967296在计算机中用一个整型就表示不了了。 在计算机中，需要表示的数越大，需要的二进制位也就越多，也需要更多字节来保存。
26个英文字母可以用26个数字分别对应，如果算上大小写，也就52个数字。再加上英文标点符号和10个数字，总共加起来也不足127个字符。 于是美国有关的标准化组织就出台了所谓的美国标准信息交换码（ASCII编码），同意规定了上述常用符号用那些二进制数来表示。
如果汉字要在计算机中表示，就没那么简单了。 汉字由上万个，用一个字节表示一个汉字的话，最多只能表示256个汉字，必须使用两个字节才能把所有汉字表示完全。 所以在计算机中，一个汉字用两个字节表示。 假设一篇文章由100个汉字组成，那么至少需要2*100=200个字节表示。
计算机中物理内存的空间大小是有限的，现在内存条一般是8G大小。 硬盘的空间也有限，现在的硬盘一般都超过了512G大小。 在这里8G 和512G是什么意思呢？ 这里其实是一个简单的单位换算。
1字节=8位1K字节=1024字节=2&amp;lt;sup&amp;gt;10&amp;lt;/sup&amp;gt;字节，也就是1K=10241M字节=1024K字节=1024*1024字节=2&amp;lt;sup&amp;gt;20&amp;lt;/sup&amp;gt;字节，也就是1M=1024K1G字节=1024M=1024*1024*1024字节=2&amp;lt;sup&amp;gt;30&amp;lt;/sup&amp;gt;字节，也就是1G =1024M 所以如果一个512G大小的硬盘用来全部储存汉字，可以储存多少个字呢？ 512G =512*1024*1024*1024/2个汉字=274,877,906,944个汉字。</description>
    </item>
    
    <item>
      <title>2.为何要注释</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/2.annotation/</link>
      <pubDate>Mon, 17 Jul 2023 15:01:24 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/2.annotation/</guid>
      <description>注释&amp;ndash;为何有必要在代码里留下程序员的解释#database ds --连接数据库 main # 入口函数  display sfmt(&amp;#34;hello world&amp;#34;) {打印} end main 以上代码中出现最多的是“&amp;ndash;”，“#”和“{}”后面或中间包含中文，这些就是注释。
注释是用来帮助程序员阅读源代码和理解源代码的。 编译器在编译时候，会把注释剔除掉然后再进行编译，当前编译器是不会修改源文件，这些都是在内存中完成。 由于对于注释部分忽略不处理，就如同没有这些字符一样，所以注释不会增加编译后的文件长度，对程序运行不起任何作用。对于注释，有以下几点说明。
 BDL的注释 由“&amp;ndash;”，“#”行注释，和“{}”包裹起来的块注释对。 编译器将行注释后的任何文件，和块注释包裹起来的任何文件都不予处理。 例如  {这些都是注释}--这些都是注释#这个有 空格 注释可以放在任何地方。通常，把注释放在要描述的代码上方，比较合适。对比比较短的代码，也可以放在后面。 注释和代码一定要同步更新。 代码修改而注释不做改变，这样的事情再实际开发中经常看见，而这一的情况可能带来严重后果。 注释内部不能再出现注释  {{这是不允许的}} 适量和恰当的注释是良好的编程风格的重要体现。  注释可以用来概括程序的算法、标识变量和函数的意义，或者解释一段代码的意图。 但是在代码中混杂过多的注释会使得程序更难以理解，反而影响代码阅读。</description>
    </item>
    
    <item>
      <title>2.BDL开发环境</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/2.environment_of_BDL/</link>
      <pubDate>Mon, 17 Jul 2023 13:31:16 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/2.environment_of_BDL/</guid>
      <description>BDL开发环境#本书所有代码运行的环境都在fjs-fgl-2.4版本，开发环境为linux系统。 本书不涉及环境如何部署。
项目目录结构#tiptop gp 和 t100 都有固定的项目结构，点此查看。 建议你在不影响正式使用的程序前提下，建立或修改程序代码。
tiptop gp编译#tiptop gp环境中需在代码对应的4gl目录下，运行命令r.c2 czzi001，czzi001是你建立的程序编号。即4gl文件去掉后缀名后的内容。
连接#tiptop gp连接命令为 r.l2 czzi001，注意：这里的czzi001不是4gl文件程序编号，而是在p_zz中注册的程序。所以在运行r.l2连接之前，你还需要做以下这些步骤。
 新增p_zz资料 如果你现在还不知道p_zz作业的功能，没关系，现在你可以参考czzi001的内容，将czzi001替换为你的程序编号，czz替换为你的程序编号前三位。   需要注意的时czzi001.4gl 一般放在czz/4gl目录下，同样azzi001.4gl 也放在azz/4gl目录下，在你更进一步理解BDL的目录结构前，就一直按照这种方式建立新程序。
 点击维护链接资料建立连接资料 (链接和连接是同一种说法的不同翻译)  新建程序时，会提示你无资料，是否建立，这里选择是。 看到下方有一笔路径为$CUST/czz/42m/czz_czzi001.42m的资料。 当后续我们程序更复杂时，会主动添加更多需要的连接资料。
最后保存时此弹窗的意思，是让你自动连接一次，可以选择是，连接失败也不要仅，只要资料有产生就可以。
t100编译#开始编辑代码#以上设置好之后，你就可以编辑代码了。
我用的vs code编辑器，配合Informix 4GL这款插件，所以代码可以高亮，不同的单次有不同的颜色，起到了提醒的作用。
除了vscode，t100自带的开发平台T100 design、submlime text、4js官方提供的genero studio等工具也能有高亮样式。
database ds -- 指定数据库，因为t100和tiptop gp有部分功能必须使用数据，所以这里必须先连接数据库 MAIN --主函数 入口点  DISPLAY &amp;#34;Hello World&amp;#34; -- 打印字符串 END MAIN  也许你注意到了，database是小写，MAIN是大写，在BDL语言中，大小写是不区分了，类似于SQL。你甚至了混合使用。</description>
    </item>
    
    <item>
      <title>2.如何学好BDL语言</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/2.how-learn-dbl/</link>
      <pubDate>Mon, 17 Jul 2023 10:46:50 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/2.how-learn-dbl/</guid>
      <description>如何学好BDL语言#无论出于什么目的，一旦下定绝心学习BDL语言，就要端正自信，因为听过BDL用的少，和其它语言差异太多，所以觉得学不好，或者随便学学，是不可取的。只要你掌握一些方法，克服畏惧心理，不轻言放弃，是完全可以学好的。
多动手多求人#所有的问题都可以通过自己编写代码观察结果解决。凡是可以通过编写代码观察到结果的问题，都不应该成为一个问题。不会的，也不要太固执，多问问有经验的人。
多学习优秀代码#BDL相当灵活，即使写的代码不优秀，也可以编译后达到你的运行目标，但是有的代码可以使用更少的代码实现相同功能，或者代码更加具有复用价值。我相信你很容就能找到不错的BDL代码。
多以人类的思考方法来类比计算机#计算机需要什么数据、如何获取这些数据、得到后如何存放、如何处理、处理后如何表现等，对这些问题要多问写为什么，一旦理解了计算机处理这些问题的过程，编程就是一件异常轻松的事情了。
多了解可以直接使用的功能#如果你在使用tiptop gp t100，会有相当多的功能都已经做好成为函数，等待你的调用。请多了解有哪些函数可以使用。</description>
    </item>
    
    <item>
      <title>3.画面档文件的编译</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/3.fglform/</link>
      <pubDate>Tue, 29 Aug 2023 15:02:51 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/3.fglform/</guid>
      <description>画面档文件的编译#4fd文件是我们的使用studio开发后保存的文件，但我们无法直接调用这个文件。
在BDL中我们最终能使用的画面档文件是42f，从4fd到42f还需要经历一个编译的过程。
4fd 对应代码的文件的4gl
42f对应代码文件的42m
per文件#在上个世纪，和这个世纪初，编写画面档并不是鼠标拖拽这么简单，画面档也需要编写代码实现。
per就是BDL之前的画面档文件，和4fd不同，per文件是纯代码编写。
以上4fd文件，转为per描述如下：
SCHEMA formonly  LAYOUT (text=%&amp;#34;Form&amp;#34;) VBox VBox1 Folder Folder1 Page Page1(text=%&amp;#34;Page1&amp;#34;) Grid Grid2 {   [label1 ]  } END -- Grid2 END -- Page1 Page Page2(text=%&amp;#34;Page2&amp;#34;) Grid Grid1 {   [label2 ]   } END -- Grid1- END -- Page2 END -- Folder1 Table Table1 { [edit1 |edit2 ] [edit1 |edit2 ] [edit1 |edit2 ] [edit1 |edit2 ] [edit1 |edit2 ] } END -- Table1 END -- VBox1 END -- Form  ATTRIBUTES Label label1:Label1, text=%&amp;#34;Label1&amp;#34;; Label label2:Label2, text=%&amp;#34;Label2&amp;#34;; Edit edit1=formonly.</description>
    </item>
    
    <item>
      <title>3.p_link作业</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/3.p_link/</link>
      <pubDate>Mon, 28 Aug 2023 16:27:00 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/3.p_link/</guid>
      <description>p_link作业&amp;ndash;使用r.l2 链接作业#无论是链接所有42m文件，还是先链接为42r文件，再链接到主程序。都需要我们将需要调用程序链接起来，如果只运行一次还好。 但是编写程序过程中难免会出错，即使能力很强，能够保证每次不出错，后续新功能增加时，也需要重新连接编译。
我们需要一种新的简单的方式去链接主程序。
p_link#之前我们使用r.c2命令时，此命令自动将42m文件放到42m目录下，如果链接也能够自动链接对应的文件就好了。
p_link就是方便程序链接的作业。
你可以直接运行exe2 p_link打开作业，也可以再p_zz中维护链结档资料按钮中打开。
让我们用tiptop gp方式重新编译链接czzi004.4gl文件。
 建立p_zz资料  运行指令其实就是42r文件，$CZZi目录就是czz/42r目录。
点击维护链结档资料  如果第一次建立，会提示生成链接档资料，选择是会打开p_link作业
自动新增的p_link资料只包含czzi004.42m主程序文件。
r.c2 s_czzi004并在p_link中新增   必须先使用r.c2编译，42m目录中没有czzi004.42m的话，会报错 完整路径是由模组编号和程序代码组合生成的   输入完成后，会自动链接，如果有报错，先忽略报错，关掉报错窗口
  回到命令行r.c2 czzi004编译主程序
  database ds编译前在第一行增加这个语句，否则会报错
链接主程序r.l2 czzi004  /u1/genero/fgl.dev/bin/fgl2p -o czzi004.42r libgre.42x WSHelper.42m lib.42x sub.42x qry.42x czz_czzi004.42m czz_s_czzi004.42m  czzi004.42r has been generated successfully! 上面为成功通知。
我们看链接的过程，和我们直接fgllink有很多区别
 fgl2p r.l2 没有使用fgllink  fgl2p 相比fgllink除了有链接的功能，如果链接文件包含4gl文件，还可以自动将4gl编译为42m后再链接。</description>
    </item>
    
    <item>
      <title>3.生命周期</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/15.function_plus/3.life-cycle/</link>
      <pubDate>Mon, 28 Aug 2023 13:54:57 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/15.function_plus/3.life-cycle/</guid>
      <description>函数生命周期#编程就是写函数，main的开始结束就是程序的开始结束。
函数的开始就是函数调用，结束就是函数最后一行运行结束，或者运行到return处。
调用
 call add() returning &amp;hellip; display add() let a = add() call minus(10,add()) &amp;hellip;  mermaid.initialize({&#34;theme&#34;: &#34;neutral&#34;})graph LRa0([&#34;开始&#34;])--a[&#34;调用&#34;]a--b[&#34;执行语句&#34;]b--c[&#34;end funtion/return&#34;]c--d([&#34;结束&#34;])变量的生命周期#编程就是写函数，函数本质是什么呢？ 函数的本质是输入、处理、输出
输入的是变量，输出的是变量。处理的也是变量。
如果程序中一直增加功能，那么变量的数量会一直增加，如果不停增加下去，内存迟早有用完的一天。
但实际上一个规划良好的程序并不会将内存全部占用。
这是因为，在BDL中变量不是一直加载到内存中，有些变量用到的时候才会分配内存，不用的时候，内存会释放掉。
那么变量在定义时就会分配内存，那么什么时候释放其内存呢？
变量所在的作用域，所有语句执行完成时释放内存，在BDL中最小的作用域是函数。
  所以在函数中定义的变量，在函数执行完后，变量就释放内存了。所以我们需要返回值，并用变量接受这个返回值。
  定义在main函数之前的函数，在main执行结束后才能释放内存。
  函数中定义的变量 graph LRa[&#34;函数调用&#34;]--b[[&#34;分配内存&#34;]]b--c((&#34;...&#34;))c--d[&#34;end funtion/return&#34;]d--z[[&#34;释放内存&#34;]]</description>
    </item>
    
    <item>
      <title>3.插入更新删除</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/3.update-insert-delete/</link>
      <pubDate>Thu, 24 Aug 2023 09:33:25 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/3.update-insert-delete/</guid>
      <description>插入更新删除&amp;ndash;BDL操作数据#提前确认#在每次操作数据之前，请确认当前连接的数据库是否正确。
不要更新错了库！
 本节内容需要你了解SQL基础语法，如果不了解可以参考此教程一篇文章学会SQL。
 插入INSERT#在BDL中操作数据库有两种方式，一种是直接使用SQL原生语句，另一种是使用BDL的SQL语句。
原生语句# 将要执行SQL语句放到字符串中  let l_sql = &amp;#34;INSERT INTO demo_file (demo001,demo002,demo003) values(&amp;#39;mar-001&amp;#39;,&amp;#39;xxx&amp;#39;,&amp;#39;xxx&amp;#39;)&amp;#34; prepare SQL语句  prepare demo_ins from l_sql -- demo_ins为标识符 执行SQL语句  execute demo_ins 检查SQL是否执行成功  在BDL中有一个特殊的全局变量sqlca用来记录SQL执行情况。
 define sqlca record  sqlcode integer, -- 报错代码 100 表示未找到 &amp;lt;0表示有错误  sqlerrm string, --错误消息数量  sqlerrp string,  sqlerrd array[6] integer,  -- 1.</description>
    </item>
    
    <item>
      <title>3.结构体嵌套</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/3.nesting-record/</link>
      <pubDate>Thu, 20 Jul 2023 19:26:32 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/3.nesting-record/</guid>
      <description>结构体嵌套#上一节中讨论的person结构相对简单，只包含了3个数据成员: name、age和email, 如果面对的是更为复杂的结构，将所有数据成员并排似乎不是个高效的方法。那能否使用结构体嵌套，一层层管理数据呢?
结构体嵌套定义#顾名思义，结构体嵌套就是“结构体套结构体”，某个结构体的成员也是一个结构体变量，这样就可以按层次结构合理组织数据，举例如下：
type student record  score record  math integer,  english integer  end record,  info record  height,weight decimal(10,2)  end record end record student是个外层结构，内部包含着学生的数据，结构体student内又定义了两个结构体变量score (成绩)和info (基本情况),结构体中的成员应当是占据内存空间的变量实体，因此，score和info是student结构的数据成员，结构体scorestruct和infostruct只是两个类型名，不占据实在的内存地址空间。将上述代码如下改写似乎更好理解一点:
type score record  math integer,  english integer end record type info record  height,weight decimal(10,2) end record type student record  score score,  info info end record 在结构体内部申明的结构体类型是不可见的，只能通过外部结构体调用。</description>
    </item>
    
    <item>
      <title>3.二维数组</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/3.two-dimensional/</link>
      <pubDate>Thu, 20 Jul 2023 16:20:31 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/3.two-dimensional/</guid>
      <description>二维数组#一维数组常称为向量，本节介绍二维数组。所谓二维数组，最简单的理解是“有两个下标’如果把一维数组理解为一行数据，那么，二维数组可形象地表示为行列结构，如图所示,左侧表示的是一个大小为M的一维数组：
   A[1] A[2] &amp;hellip; A[M]    右侧表示的是-一个大小为M*N的二维数组：
   A[0,1] A[0,2] &amp;hellip; A[0,N]     A[1,1] A[1,2] &amp;hellip; A[1,N]   &amp;hellip; &amp;hellip; &amp;hellip; &amp;hellip;   A[M,1] A[M,2] &amp;hellip; A[M,N]    二维数组的定义#和一维数组一样，定义二维数组时，要告诉编译器以下信息：数组名、元素类型、元素的个数。对二维数组来说，元素个数时两位大小的成绩。
动态数组时只要定义数组的维度即可。
示例如下：
 define a array [2,3] integer -- 定义一个2x3的定长数组，一共有2*3=6个元素。  define b dynamic with dimension 2 of string --定义一个二维的动态字符串数组 定长和动态二维数组都可以访问的语法都是一样的。</description>
    </item>
    
    <item>
      <title>3.函数调用与返回</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/3.formal-actual/</link>
      <pubDate>Thu, 20 Jul 2023 11:27:41 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/3.formal-actual/</guid>
      <description>函数调用与返回#形参和实参#请观察一下代码：
main  define x,y,sum integer  let x = 5 let y = 7  call add(x,y) returning sum  display sum end main function add(a,b)  define a,b integer  return a + b end function 在上面代码中参数列表是a和b，而在函数调用时传递进来的参数是x和y，这两种参数是申明关系呢？ 打个形象的比方，这是角色和演员的关系。
函数定义时列表中参数为形数，是“剧本角色”，而函数调用时传递进来的参数称为实参，是“演员”，函数执行的过程就是演戏的过程。
程序刚开始执行的时候，系统并不为形参分配存储空间，因为它只是个角色，不是实体，一直要到函数调用时，系统为形参分配存储空间，并将实参的值复制给形参。
结合代码上面代码可知，在call add(x,y) returning sum语句调用前，a和b都不是真正的程序变量，一直到add函数被调用，a和b才被创建，并分别用x和y为其赋值，在这种情况下，在函数内对a和b的处理并不影响x和y，这类似于“ 某个演员扮演的角色在戏中受伤，并不是说演员真的受伤了”，而且，在函数执行结束返回时，创建的形参被撤销，这类似于“戏演完 了，剧中角色自然也就停止了”。
举例来看，下列示例代码先交换两个变量的值，但并没有成功，为什么?请试着用演员和角色的关系来解释一下。
--视图交换两个变量的值 main  define num1,num2 integer  display &amp;#34;&amp;#34;  display sfmt(&amp;#34;num1 is %1,num2 is %2 &amp;#34;,num1,num2)  call swap2Variable(num1,num2)  display sfmt(&amp;#34;num1 is %1,num2 is %2 &amp;#34;,num1,num2) end mian function swap2Variable(a,b)  define a,b,c integer   display sfmt(&amp;#34;a is %1,b is %2 &amp;#34;,a,b)  let c = a  let a = b  let b = c  display sfmt(&amp;#34;a is %1,b is %2 &amp;#34;,a,b) end function 输出结果为：</description>
    </item>
    
    <item>
      <title>3.循环嵌套</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/3.cycle-in-cycle/</link>
      <pubDate>Thu, 20 Jul 2023 08:53:09 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/3.cycle-in-cycle/</guid>
      <description>循环嵌套#循环结构也支持嵌套，如果把简单的循环内容为“一遍又一遍”，那循环嵌套便可称为“一层又一层，一遍又一遍”。
可以用始终来打比方，走一个代表执行一次循环，那么一小时里，分针又要走60个格，而分针每走一格，秒针也要走60格。
如此，秒针的走动可以看成是内存循环，而分针的走动可看成是外层循环。
嵌套示例#已for循环结构举例，限制想在屏幕上输出4*9个星号，这可以利用双重循环来做：
 define i,j integer  define s string  display &amp;#34;&amp;#34;  for i = 1 to 4  let s = &amp;#34;&amp;#34;  for j = 1 to 9  let s = s, &amp;#34;* &amp;#34;  end for  display s  end for 输出结果为：
* * * * * * * * ** * * * * * * * ** * * * * * * * ** * * * * * * * * 代码解析</description>
    </item>
    
    <item>
      <title>3.多分枝语句和分支语句嵌套</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/3.multi-branch/</link>
      <pubDate>Wed, 19 Jul 2023 19:25:12 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/3.multi-branch/</guid>
      <description>多分枝语句和分支语句嵌套#讲过了“2选1”， 那如果出现“3选1”， 甚至是“N选1”怎么办?可使用多分支语句和分支语句嵌套。此外，BDL语言还提供了开关语句case,这是一种特殊的选择分支结构，稍后一节会讨论case的用法。本节来看一下分支语句嵌套的问题。
多分支#用实例说明似乎更好理解，假设需要编制-一个程序，根据学生的得分判定其类别，具体是:少于60分判为D (不及格)，60到74分判为C (一般)， 75到89分判为B (良好)，大于等于90分判为A (优秀)，学习分支结构后读者编写的代码可能如下所示。
 define mark integer  prompt &amp;#34;请输入该学生成绩：&amp;#34; for mark  if mark &amp;gt;= 90 then  display &amp;#34;A&amp;#34;  end if  if mark &amp;gt;= 75 and mark &amp;lt;90 then  display &amp;#34;B&amp;#34;  end if  if mark &amp;gt;= 60 and mark mark &amp;lt;75 then  display &amp;#34;C&amp;#34;  end if  if mark &amp;lt;60 then  display &amp;#34;D&amp;#34;  end if 代码解析</description>
    </item>
    
    <item>
      <title>3.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/7.atoml_statement/3.practice/</link>
      <pubDate>Wed, 19 Jul 2023 19:05:11 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/7.atoml_statement/3.practice/</guid>
      <description>练习#根据以下伪代码，写一个小程序# 大于等于60分的输出“合格”，小于60分的输出“不合格”。
 用户输入如果（用户输入的数值小于60）执行A操作否则执行B操作 </description>
    </item>
    
    <item>
      <title>3.逻辑运算符</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/3.logical-operator/</link>
      <pubDate>Wed, 19 Jul 2023 15:36:30 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/3.logical-operator/</guid>
      <description>逻辑运算符和逻辑表达式#逻辑运算符#关系表达式的输出结果为“真”和“假”，但关系表达式毕竟只能判断一次，实际问题常常遇到多个条件判断情况。 例如，“如果从济南到北京比上海近，并且明天不下雨，就去北京旅游”。 BDL语言遇到这种情况，就要使用逻辑运算符和逻辑表达式。
逻辑运算符
   运算符 描述     not 如果右边表示大为true返回false，如果为flase，返回true   and 如果左边和右边表达式都为true,返回true,否则false   or 如果左边和右边表达式都为false,返回false,否则true    逻辑运算符#在计算机中，逻辑运算符可以理解为，``与 或 非`。
 与（AND）  “表达式1 and 表达式2”，只有当两个条件都为 非0 时，运算结果为非0，否则结果为0。
所有表达式是并且的关系，都成立时才认为成立，有任意一条不成立，就算不成立。
或（or）  “表达式1 or 表达式2”，只有两个条件都为0时，运算结果才为0,否则为1。
所有表达式是或且的关系，都不成立的时候才不成立，有任意一条成立，就算成立。
非（not）  “not 表达式”，取反，当表达式为0时，结果为1，当表达式为1时，结果为0。
所修饰的表达式成立那么就不成立，不成立就成立。
逻辑真值表#   A B not A not B A and B A or B     真 真 假 假 真 真   真 假 假 真 假 真   假 真 真 假 假 真   假 假 真 真 假 假    总结以下：与运算就是“有一个假，结果为假”，或运算是“有一个真，结果为真”，非运算时“假变真，真变假”。</description>
    </item>
    
    <item>
      <title>3.数字的格式化</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/3.format-number/</link>
      <pubDate>Tue, 18 Jul 2023 13:24:57 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/3.format-number/</guid>
      <description>数字的格式化#之前我们说过日期在BDL语言也是储存为整数类型，请运行以下代码，观察其输出值
define t date display t 发现其结果是
1899/12/31  如果你的环境是1899/12/31，是因为DBDATE环境变量为Y2MD/，修改为Y4MD/之后就变为4位。不建议修改，因为已有代码可能是按照2位编写的。
 日期类型会自动格式输出，那么我如果也想数字格式化输出字符串，应该如果写呢？
本章就来介绍以下，数字的格式化方式。
数字货币格式化#在介绍之前，我们尝试运行一下如下代码：
 define a integer  define b decimal(20,6)   let a = 12345  let b = 2345.1235  display sfmt(&amp;#34;a=%1,b=%2&amp;#34;,a,b)  display sfmt(&amp;#34;a=%1,b=%2&amp;#34;,a using &amp;#34;******&amp;#34;,b using &amp;#34;#####.###&amp;#34;) a=12345,b=2345.123500 a=*12345,b= 2345.124  使用了 using &amp;ldquo;******&amp;rdquo; 的12345 在最前面多了一个* 使用了 using &amp;ldquo;#####.###&amp;rdquo; 的2345.1235，整数前多了一个空格，小数保留了3位，且进了一位。  这里的数字/数字变量 using 格式化字符串的格式就是在格式化数字格式。
格式化字符串中有固定的写法，如下：
   类型 格式化规则     * 不足的位数补上*   # 不足的位数补上空格   &amp;amp; 不足的位数补上0   &amp;lt; 和&amp;amp;一样，但是左对齐   - 和#一样，但负数会加上-号   + 和-一样，但整数会加上+号   ( 和-一样，但负数会加上()号   ) 和(一样   $ 数值前加上一个币种符号   , ,号左侧有数字才显示,   .</description>
    </item>
    
    <item>
      <title>3.数据类型</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/3.data-types/</link>
      <pubDate>Tue, 18 Jul 2023 08:10:23 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/3.data-types/</guid>
      <description>数据类型#BDL语言规定，程序中使用的每一个数据，必须指定其数据类型。
BDL语言数据类型
mermaid.initialize({&#34;theme&#34;: &#34;neutral&#34;})graph TD;BDL语言数据类型--构造类型BDL语言数据类型--基本类型构造类型--数组构造类型--结构体基本类型--字符串类型基本类型--数值类型数值类型--整型数值类型--浮点型graph TD;整型--DATE整型--BINGINT整型--INTEGER整型--SMALLINT整型--TINYINT整型--BOOLEANgraph TD;浮点型--c[&#34;FLOAT[(p)]&#34;]浮点型--d[&#34;SMALLFLOAT&#34;]浮点型--e[&#34;DECIMAL[(p[,s])]&#34;]浮点型--f[&#34;MONEY[(p[,s])]&#34;]graph TD;字符串类型--a[&#34;CHAR[(n)]&#34;]字符串类型--b[&#34;VARCHAR[(n[,r])]&#34;]字符串类型--STRING字符串类型--BYTE字符串类型--TEXT 基本类型是最基础的简单数据类型，其值无法再分解为其它类型 构造数据类型：顾名思义，构造数据类型是根据已经定义的一个或读个数据类型用构造的方法来定义的。 构造数据类型有多个其它数据类型组合而成。 一个构造类型的值可以分解成若干个成员或元素。 其中每个成员要么是一个基本数据类型，要么又是一个构造类型。 再BDL语言中构造类型又以下几种：   数组类型：所有元素都是同一类型。即数组类型是统一数据类型元素的集合 结构类型：不同数据类型的组合  本节只介绍基本数据类型，其它数据类型再后续陆续介绍。
整数类型#整数是日常生活和计算机中用得最频繁的数据类型，也比较容易理解。 整数从数学意义上来说就是从负无穷到正无穷之间的任意整型的数据，也就是任意自然数(如1、2、3、4、5)以及它们的负数或0。 如果用十进制表示一个自然数，十进制的位数越多，表示的整数也越大。 在计算机中用二进制表示数据，二进制的位数不能无限使用，所以在计算机中，整数有一定的大小限制，只能在一定的范围之内。 在以前内存“寸土寸金”的时代，哪怕是为了节约2个字节的内存，也是非常有必要的。
所以BDL语言的整数类型，又分为BINGINT8，INTEGER4，SMALLINT2，TINYINT1。
在BDL语言中，日期也是用整型标识的，DATE4,它和INTEGER4在内存中存储方式一致，并规定1899/12/31这一天为0，1900/01/01为1。
除了这些比较大的整数还有一个1位的整型BOOLEAN，它只能保存1或者0。
请验证以下代码的运行值，后续所有代码不需要的地方都不会在包括main函数：
define a smallint let a = 32767 display a let a = a + 1 display a let a = a + 1 display a 整数的正负#浮点型#  FLOAT[(p)]8</description>
    </item>
    
    <item>
      <title>3.main函数</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/3.main-function/</link>
      <pubDate>Mon, 17 Jul 2023 15:12:04 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/3.main-function/</guid>
      <description>main函数&amp;ndash;从哪里开始，到哪里结束#先看以下代码
main  display sfmt(&amp;#34;hello world&amp;#34;) end main 代码解析
main ...end main这一段是在定义BDL程序的主函数。 函数是可以完成一定功能的子程序。main函数是BDL语言程序的起始执行点。
每一个BDL程序必须有且仅有一个main函数，它是由程序员提供的。
请读者思考一个问题:操作系统是如何开始运行调用一个程序的?
这个问题的意思是操作系统怎么知道一个程序的入口点在哪里?所谓入口点，就是程序的第一条指令。 操作系统调入程序二进制代码到内存后，从哪条指令开始运行程序呢?
一种办法是从文件第一行开始，一行一行往下执行，直到文件结束。 很多语言就是采用这种方式。 比如QBASIC语言。 这种方法的好处显而易见，人类是怎么阅读的，计算机就是怎么执行的。 但是缺点也很多，当有两个源文件的时候，从哪个文件开始呢? 另一种办法是和运行程序的启动者协商一个规定的入口名字，从这个名字开始进入。这种方法就是BDL语言采用的方法。
main函数就是BDL程序的入口点。无论整个工程有多少个C源文件，必须编写且只能编写一个main函数。程序就是从main的第一条语句开始执行，然后在main函数中，顺序执行其他语句，在这些语句中，调用其他函数，从而使整个程序运行起来。 main函数结束了，整个程序也就结束了。 由此可见，写BDL程序，就是写main函数。
 简单地说明一下定义函数的语法。对函数的详细讲解请参考后续章节。
 对于BDL语言，定义函数的语法规则如下：
function 函数名称(参数1，参数2)函数体return 返回值end function 对比上面的语法规则可以看出，在main这一行中，main是函数名称。 函数可以是BDL语言系统提供的系统函数，也可以是用户自己编写的函数。 用户自己编写的函数，函数名字可以自行决定。
例如：
funtion add(x,y)  define x,y integer  return x+y end function 看以上代码，add为函数名，函数名后有小括号对“()，括号里是传递给函数的参数。
类似初、高中学习的代数里的函数y=f(x)一样，x就是参数，f是函数名称。 参数可以是一个，也可以是多个，也可以没有参数。
每个参数都有一个数据类型。本例中的参数的数据类型是integer（整数）。 在function ... end funtion之间的的代码就是add函数实现的功能，被称做函数体。 在函数体里能做哪些事情，也是有规定的。在函数一章里再详细说明。</description>
    </item>
    
    <item>
      <title>3.编译运行</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/3.see-your-program/</link>
      <pubDate>Mon, 17 Jul 2023 14:08:41 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/3.see-your-program/</guid>
      <description>编译运行-欣赏你的杰作#使用之前我们说的编译连接命令，开始编译连接。如果成功将不会有错误提示，如果失败请检查一些你的代码，可以对比上一篇中的代码。
在czz/4gl目录下输入exe2 czzi001,将会显示以下内容。
</description>
    </item>
    
    <item>
      <title>3.语言概述</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/3.what-is-language/</link>
      <pubDate>Mon, 17 Jul 2023 10:58:17 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/3.what-is-language/</guid>
      <description>语言概述#提到语言这个词，人们自然想到的是英语、汉语这样的自然语言，因为语言是任何人交互交流信息不可缺少的工具。而今天，计算机遍布了我们生活每一个角落，除了任何人之前的交互交流之外，我们必须和计算机交流。 用什么样的方式和计算机做最直接的交流呢？ 人们自然想到的是最古老也同时也是最方便的方式&amp;ndash;语言。
什么是语言#类比人类的语言，汉语言、英语言、法语言等，可以总结出语言有如下特点。
 语言是用来交流沟通的 语言有独特的语法规则  什么是机器语言#计算机是一个忠实的仆人，时刻等候着主人的命令。 如何才能使计算机听话呢？ 当然是用计算机听得懂的语言去命令它了。 计算的大脑或者说心脏就是CPU，它控制着计算机的运作。 每种CPU都有自己的指令系统。 这个指令系统就是该CPU的机器语言。 机器语言是一组有0和1系列组成的指令码，这些指令码是由CPU制作厂商规定出来的，然后发布出来请程序员遵守。如下是某CPU指定系统的两条指令：
1000000 加1001000 减 要让计算机完成相应的任务，就得用这样的语言去命令它。这样的命令不是一条两条，而是二十上百条。 由于不同型号计算机的指令系统即机器语言是不相同的，按照一种计算机的机器指令编制的程序，不能在另一种计算机上执行。
用机器语言编写程序，编程人员首先要熟悉所用计算机的全部指令代码和代码的含义。
在编写程序时，程序员得自己处理每条指令和每一数据存储分配得输入和输出，还得记住编程过程中每步所使用得工作单元处理处在何种状态，这是一件十分繁琐的工作，编写程序花费的时间往往是实际运行时间的几十倍或者几百倍。
而且，编出的程序全是0和1的指令代码，直观性差，还容易出错。
什么是汇编语言#在用机器语言编程的实践中，一批顽强而聪明的先行者发明了汇编语言&amp;ndash;一门人类可以比较轻松掌握编程语言。 只是这门语言计算机并不认识，人类还不能使用这门语言命令计算机做事情。
所以有一类专门的程序，既认识机器语言，又认识汇编语言，而且还很聪明，知道怎么把汇编语言翻译成机器语言。于是，人类和机器又有了一种新的交流方式，而且任何可以轻松地编写程序了。
 上文提到过，不同CPU有不同指令系统，从而有不同机器语言与其对应。所以程序员用汇编语言编写程序，都要记住是在什么CPU上编写的。 程序员不仅要考虑程序涉及思路，还要熟记计算机的内部结构这种编程的劳动强度依然很大。
 面向过程的语言#汇编语言和机器语言都是面向机器的，机器不同，语言也不同。 既然有办法汇编语言翻译成机器语言，难道就不能把其它更人性化的语言翻译成机器语言？ 1954年，Fortran语言出现了，其后续出现了其它类似语言。这批语言是程序员摆脱了计算机硬件的桎梏，把主要精力放在了程序涉及上，不再关注底层的计算机硬件。 这类语言被称为高级语言。同样得高级语言要被计算机执行，也需要由一个翻译程序将其翻译成机器语言，也就是编译程序。
这类高级语言解决问题的方法是分析出问题所需要的步骤，把程序看作是数据被加工的过程。 基于这类方法涉及的语言称为面向过程语言。C语言就是一种面向过程的程序设计语言。
什么是BDL语言#BDL语言相对于C语言，抽象程序更高，更少的代码可以做更多的事情。 但同样的由于抽象程序高，占用资源也比较高，无法与C语言这样比较底层的语言灵活处理问题，为了解决这个问题，BDL中可以直接调用C语言程序。</description>
    </item>
    
    <item>
      <title>4.MENU</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/5.menu/</link>
      <pubDate>Tue, 29 Aug 2023 15:44:56 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/5.menu/</guid>
      <description>MENU#Genero BDL 所提供的 MENU 命令，是一种环状显示的功能表（Ring Menu）。以下介绍如何操作并设定想要的功能。
MENU 命令#MENU语法类似下面这样:
MENU [title] ATTRIBUTE ( control-attributes )   BEFORE MENU   COMMAND option [comment]  [ HELP help-number ]   COMMAND KEY ( key-name )  option [comment]  [ HELP help-number ]   ON ACTION action-name   ON IDLE idle-seconds  END MENU 说明：
 在一个 MENU 中，可以定义 menu 的属性，STYLE 属性预设&amp;rsquo;default&amp;rsquo;。  属性包括:</description>
    </item>
    
    <item>
      <title>4.Window&amp;Form</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/4.window-form/</link>
      <pubDate>Tue, 29 Aug 2023 15:43:05 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/4.window-form/</guid>
      <description>Window &amp;amp; Form#在上一章节介绍如何编辑画面，但 WINDOWS 与 FORM 本身是无法执行的，它必须透过 Program 去启动它，以下介绍在程序中启动及显示 WINDOWS &amp;amp; FORM 的指令。
本节用到画面档时czzi001.4fd，你也可以自己创建一个喜欢的样式。
WINDOW#OPEN &amp;amp; CLOSE#database ds -- 之后的代码默认都通过r.c2 编译，都必须指定数据库 main  open window czz_w with form &amp;#34;czz/42f/czzi001&amp;#34;  sleep 10  close window czz_w end main 如果你直接运行发现，并没有打开作业，请通过 debug 调试模式重新运行一下查看。
注意
BDL 中如果没有指定使用操作画面语句块，那么直接打开画面是看不见的。
运行一下代码：
database ds -- 之后的代码默认都通过r.c2 编译，都必须指定数据库 main  open window czz_w with form &amp;#34;czz/42f/czzi001&amp;#34;  call cl_ui_init() -- 这lib函数为初始化画面，如果不调用会出现一个空窗口。  menu &amp;#34;&amp;#34;  on action test  message &amp;#34;test&amp;#34;  on action untest  message &amp;#34;untest&amp;#34;  on action close  exit menu  end menu  close window czz_w end main MENU 就是一个画面操作语句块，后面会讲到，它的功能就是生成一些按钮，tiptop gp 将这些按钮放置到了右侧。</description>
    </item>
    
    <item>
      <title>4.BDL中的模块</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/4.module/</link>
      <pubDate>Mon, 28 Aug 2023 20:06:19 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/4.module/</guid>
      <description>BDL中的模块#BDL源代码从编译主程序、子程序，链接主程序，过程中会产生多个文件。
所以按照模块可以将BDL程序划分为不同的块，一个程序的执行往往依赖大量的模块。
globals#如果说不同文件之间的通过链接的形式，组成不同模组最终组成了一个可执行程序。
那么globals就是使不同模块中共享变量不可缺少的关键字。
我们已知的变量最大的作用域，也就是函数外，即全局变量。在本文件中所有函数都可以使用。但是随之我们编写程序复杂度增加，我们使用很多不同文件，不同的模块，这个时候即使是全局变量也无法在不同文件中使用。
globals就是解决这个问题的，在globals中定义的变量，在程序整个运行周期都是可用的，无论你是哪个文件、模块中的函数。
globals是一个块语句，它有对于的end globals结束语。只能定义在函数外。 它的用法是，在块中包裹变量或者自定义类型&amp;ndash;即define和type语句。
使用方法有两种
 在源代码中直接定义  globals  define g_cnt integer end globals main end main 定义一个globals文件，然后在源码中引入文件   文件czzi004.global  globals  define g_cnt integer end globals  文件czzi004.4gl  globals &amp;#34;./czzi004.global&amp;#34; main end main 第二种方式是我们常用的方式，这样不同文件只要引入同一个global文件即可，不需要每次修改globals变量，都修改所有文件。
练习#观察分析azz/4gl/p_zz.4gl和lib/4gl/cl_null.4gl文件中globals的使用。</description>
    </item>
    
    <item>
      <title>4.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/15.function_plus/4.practise/</link>
      <pubDate>Mon, 28 Aug 2023 14:21:21 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/15.function_plus/4.practise/</guid>
      <description>练习#生成一个长度为100的整数数组，并输出数组中可以被5整除的个数# 长度100的整数数组，每个元素都为随机数，大于0且小于1000的整数  提示
util.Math.rand(100)可以获取小于等于100的随机整数。
import util main  display util.Math.rand(100) end main 生成随机数功能写为一个函数，且接受两个参数，生成数组的长度和随机数最大整数  生成一个长度为50的整数数组，并从小到大排序，排序后输出到屏幕# 随机数生成请参考上一题  </description>
    </item>
    
    <item>
      <title>4.查询单笔资料</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/4.select-single-row/</link>
      <pubDate>Thu, 24 Aug 2023 14:49:27 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/4.select-single-row/</guid>
      <description>查询单笔资料#BDL SQL#同插入一样，查询时BDL SQL也有特殊的语法，但仅可以查询单笔资料，如果查询结果包含多笔，程序报错退出。
define l_ima01 like ima_file.ima01 define l_ima02 like ima_file.ima02 select ima01,ima02 into l_ima01,l_ima02 from ima_file where rownum = 1 在select关键之前from关键字之后，可以使用into关键字，后面可以指定查询保存到哪些变量。
我们在定义变量类型时有使用过一下语法
define l_ima record like ima_file.* 在查询时我们也可以将表中所有内容查询出来。
define l_ima record like ima_file.* select * into l_ima.* from ima_file where rownum = 1 EXECUTE#除了BDL自带SQL语法，我们依然可以使用数据库的原生语法，和插入语法类型，我们需要将SQL放到字符串中。
define l_sql string define l_ima record like ima_file.* let l_sql = &amp;#34;select * into l_ima.* from ima_file where rownum = ?</description>
    </item>
    
    <item>
      <title>4.结构体数组嵌套</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/4.record-in-array/</link>
      <pubDate>Thu, 20 Jul 2023 19:27:18 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/4.record-in-array/</guid>
      <description>结构体数组嵌套#在上一章节例子中，我们使用student类型定义了两个变量zhangsan,lisi。 但是我们需要的变量不止两个，例如，我需要一个班上50个学生，是不是场景很熟悉？没错，变量。
我们使用变量嵌套结构体，示例：
type student record  score record  math integer,  english integer  end record,  info record  height,weight decimal(10,2)  end record end record define students array[50] of student 数组中的结构体#入上面代码，结构体声明是一种自定义的数据类型，在数组
结构体中的数组#</description>
    </item>
    
    <item>
      <title>4.多维数组</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/4.multi-dimensional/</link>
      <pubDate>Thu, 20 Jul 2023 17:03:58 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/4.multi-dimensional/</guid>
      <description>更高维的数组#在了解二位数字定义、初始化和引用之后，不难将概念引申到三维，思维，甚至是更高维数组，本章讨论更高维数组的使用方式。
高维数组的定义和元素访问#细心的读者不难发现，如果数组是N维，就需要N个下标来访问数组中的元素，同样，在声明高维数组时，除了和一-维、二维数组声明一样要指定元素类型和数组名外，还要指定每一维的大小，以帮助编译器确定到底要分配多大的内存块。
举例来说，要声明一个int型3维数组sz,大小为345,代码如下:
 define sz array[3,4,5] of integer 多维数组在内存中如何排列元素#维度决定了数组中元素的组织方式及访问元素所用的下标个数，但本质上讲，所有的数组在内存中都是一维线性的，所有元素都是连续排列的，中间没有间隔。
以二维数组为例，内存中是先放第一行的元素，再放第二行的元素。下面给出了大小为3*4的二维数组A的排列顺序：
A[1,1]-&amp;gt;A[1,2]-&amp;gt;A[1,3]-&amp;gt;A[1,4]-&amp;gt; A[2,1]-&amp;gt;A[2,2]-&amp;gt;A[2,3]-&amp;gt;A[2,4]-&amp;gt; A[3,1]-&amp;gt;A[3,2]-&amp;gt;A[3,3]-&amp;gt;A[3,4] 多维数组的存储方式与此类似，可以将下标看成是-一个计数器，像计数的万位、千位、百位、十位和个位一样，右边的下标(靠后的下标)是低位，每一位都在上下界间变化，变化的范围是1到声明时指定的下标值，当某一低位计数器超出范围时(达到声明时指定的下标值)，左边下标加1，同时该低位计数器及其右边的更低位计算器置1 (回到下界)。这样，最左边一维下标变化是最慢的，最右一维 下标变化最快。
下面给出2*3*2的三维数组B中元素在内存中的排列顺序:
B[1,1,1]-&amp;gt;B[1,1,2]-&amp;gt;B[1,2,1]-&amp;gt;B[1,2,2]-&amp;gt;B[1,3,1]-&amp;gt;B[1,3,2]-&amp;gt;B[2,1,1]-&amp;gt;B[2,1,2]-&amp;gt;B[2,2,1]-&amp;gt;B[2,2,2]-&amp;gt;B[2,3,1]-&amp;gt;B[2,3,2] </description>
    </item>
    
    <item>
      <title>4.面向过程编程</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/4.process-oriented/</link>
      <pubDate>Thu, 20 Jul 2023 13:17:51 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/4.process-oriented/</guid>
      <description>面向过程的程序结构#在20世纪60年代计算机发展的初期，程序设计是少数聪明人的工具，程序员可以根据自己的喜好，像捏泥巴一样进行程序设计，注释几乎是一行没有，想到哪写到哪，大多数程序代码组织混乱，可以说只有设计者本人可以看懂，有的甚至设计者读起来也不知所以，常被称为“意大利面条式编程”。
这种个人英雄主义的单打独斗在解决小规模问题时勉强可以，但程序规模的不断扩大，一大堆的问题凸显出来:程序质量低下，进度延误，预算严重超支，就是“软件危机”，给程序开发的前景蒙上了一层暗淡的色彩。
结构化程序设计方法就是在这个背景下提出的，除了前面章节中讲过的3种控制结构:顺序、分支和循环外，结构化程序设计的另-一个关键概念是模块化设计。
模块化#生活中常常接触到模块化的概念，模块化程序设计大致有点像小时候玩的积木游戏，用木块组合的方式很容易地就构筑起了“大厦”。模块化至少有两点好处: 一是封装，“积木块”是“基本砖块”的组合，对外是个整体，使用方便，二是可复用，“柱子”封装好后，既可以用在这个建筑上，又可以用在那个建筑上。程序设计也可以借鉴这一思想，用模块化的方法进行程序设计，函数正是模块化方法的体现。
虽说语句是BDL语言的基本单位，但从程序设计总体把握上来看，将函数视为一个整体，大大降低了问题的复杂程度。在解决复杂问题时，首先考虑的是问题的概貌，而不是微小细节，这是人的思维和行动习惯，程序设计也是如此，先将问题分割成-一个个函数，每个函数实现特定的功能，确定函数之间的联系和依赖关系，这是从整体解决某个问题。其次才是考虑每个函数怎么写，算法流程怎么走这些问题，这就是“分而治之、逐步求精”的设计方法学。
函数的调用过程#BDL语言是由函数组成的，本章前面以及介绍了函数的定义、声明和调用等基础只是，下面来看一下函数的调用过程，即不同函数是和配合的。如图：
mermaid.initialize({&#34;theme&#34;: &#34;neutral&#34;})flowchart TDsubgraph a[&#34;main&#34;]e[&#34;函数1&#34;]--f[&#34;函数2&#34;]endsubgraph b[&#34;函数1&#34;]i[&#34;语句1&#34;]--g[&#34;函数3&#34;]g--h[&#34;语句2&#34;]endsubgraph c[&#34;函数2&#34;]j[&#34;...&#34;]endsubgraph d[&#34;函数3&#34;]k[&#34;...&#34;]ende--&#34;call&#34;--bb--&#34;return&#34;--ef--&#34;call&#34;--cc--&#34;return&#34;--fg--&#34;call&#34;--dd--&#34;return&#34;--g一个入库一个出口#结构化程序设计主张使用顺序、选择、循环3种基本结构来嵌套连接成具有复杂层次的“结构化程序”，严格控制goto语句的使用。
需要强调的一点是，对单个模块而言，只有一个人口，一个出口。这是一种从上到下的流程式方法，减少了模块间的相互联系，使模块可作为插件或积木使用，降低程序的复杂性，提高可靠性。
封装和可重用#可作为插件或积木使用的模块具有很强的可重用性，完全可用在其他同类型的问题中，省却了将算法重写一遍的麻烦。对一些规模较大的商业软件公司来说，模块的积累是笔巨大的财富，到达一定的规模后，解决问题时要重新写的代码和模块很少，从库中挑选出需要的模块，拼装组合就形成了满足要求的程序。而且，如果在模块编制中注重算法的效率等因素，采用这种插件组合的方式可以很容易产生出高质量的软件产品。
下面来看一下封装性。在模块化程序设计中，模块内部的结构，对其他模块来说是不重要的，以函数为例来说明，BDL语言中，函数可看成是一个封装体，将一系列相关的、实现某一功能的代码封装起来，并提供了一个使用方法(程序开发中常称接口)，通过该接口可以在程序的任何地方使用这些代码完成特定的功能，至于函数是如何编写的，可能并不是用户关心的重点，用户真正关心的是这个函数如何使用。这就意味着，函数内定义的变量等，外部是不能访问的，为此，引入“内聚”和“耦合”的概念。
高内聚，低耦合#既然模块化设计有那么多的好处，那是不是可以不管三七二十-地把整个程序简单地分解成一个个程序段呢?答案是否定的，模块的划分有条准则，即“相对独立，功能单一”。也就是说，一个好的模块必须具有高度的独立性和相对较强的功能，这通常用“耦合度&amp;quot;、“内聚度”两个指标从不同侧面而加以度量。
耦合度，是指模块之间相互依赖性大小的度量，耦合度越小，模块的相对独立性越大。内聚度，是指模块内各成分之间相互依赖性大小的度量，内聚度越大，模块各成分之间联系越紧密，其功能越强。
在模块划分时应当做到“耦合度尽量小，内聚度尽量大”。</description>
    </item>
    
    <item>
      <title>4.流程转向控制语句</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/4.cycle-and-flow-control/</link>
      <pubDate>Thu, 20 Jul 2023 09:08:04 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/4.cycle-and-flow-control/</guid>
      <description>流程转向控制语句#之前我们了解到BDL中除了判断语句，循环语句，还有大量的流程转向控制语句。
他们是continue、exit、goto语句，本章节会一一讲述。
exit&amp;ndash;跳出循环#如果把重复结构视为一层壳，那么exit的作用可说是“破壳而出”，当流程执行到循环结构中的break语句时，循环结构提前结束，程序转而执行循环结构之后的那条语句，用流程图来表示，如图所示。
mermaid.initialize({&#34;theme&#34;: &#34;neutral&#34;})flowchart TDa{&#34;?&#34;}--b{&#34;exit?&#34;}b--&#34;no&#34;--d[&#34;语句&#34;]b--&#34;yes&#34;--c[&#34;...&#34;]d--a图中，如果在循环体内部执行了exit语句，程序流程会直接从循环结构中跳出，转而执行循环结构后面的语句，这类似于电路中的“短路”。
前面讲过，“如非故意为之，不要让循环成为死循环”，那这“故意为之”是怎么回事?如何“从死循环中跳出”，可用break语句实现，见示例代码：
 define i integer  display &amp;#34;\n&amp;#34;  while 1  display &amp;#34;Hello&amp;#34;  let i = i + 1  if i &amp;gt; 5 then  exit while  end if  end while 尝试编译运行，你会发现，while 1看起来是个死循环，但是我们再循环结构中，增加了一个可以exit的机会。
i每次循环都会+1，当i大于5时，就会运行到exit，退出循环。
注意 当循环有多层时，exit只能剥一层“壳”，向外跳出一层。continue&amp;ndash;重来一次#exit语句时结果整个循环结构，而continue语句结束的只是当前一次循环，形象的说时“再来一次”，流程图如下：
flowchart TDa{&#34;?&#34;}--b{&#34;continue?&#34;}b--&#34;</description>
    </item>
    
    <item>
      <title>4.case--开关语句</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/4.case/</link>
      <pubDate>Wed, 19 Jul 2023 19:44:34 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/4.case/</guid>
      <description>case&amp;ndash;开关语句#用多分支if结构和if结构嵌套都可实现“多选1”,但带来的负面影响是程序的可读性差，面对一大堆的if和if else搅和在一起，很多读代码的人都会觉得头皮发麻，要耐心地去“脱壳&amp;quot;。 实际上，BDL语言还提供了另&amp;ndash;种更简洁的多分支结构，即case结构。
一般形式#case机构一般形式为:
case 表达式1  when 常量表达式1  语句1  when 常量表达式2  语句2  when 常量表达式3  语句3  ...  default  语句4 end case 语句执行时，首先对case后的表达式进行计算，将计算的结果逐个与when后的常量表达式进行比较，当表达式的值与某个常量表达式的值相等时，即执行该when后的对应的代码段，如果表达式的值与所有when后的常量均不相同时，则执行default后的语句。
case 的算法流程如下：
mermaid.initialize({&#34;theme&#34;: &#34;neutral&#34;})flowchart TDa[&#34;表达式计算&#34;]--b{&#34;常量表达式1&#34;}b--&#34;no&#34;--c{&#34;常量表达式2&#34;}c--&#34;no&#34;--d{&#34;常量表达式3&#34;}d--&#34;no&#34;--e{&#34;常量表达式n&#34;}e--&#34;no&#34;--f[&#34;defalut:语句m+1&#34;]b--&#34;yes&#34;--g[&#34;语句1&#34;]c--&#34;yes&#34;--h[&#34;语句2&#34;]d--&#34;yes&#34;--i[&#34;语句3&#34;]e--&#34;yes&#34;--j[&#34;语句m&#34;]来看一个具体的应用实例，由用户输入一个1到7之间的数字，程序自动输出对应星期几的英文形式，如输入1，程序输出Monday。如果用户输入的数字不在1到7之间，提示出错，如下:
 define index integer  prompt &amp;#34;请输入一个1到7之间的整数：&amp;#34; for index  display &amp;#34;&amp;#34;  case index  when 1  display &amp;#34;Monday&amp;#34;  when 2  display &amp;#34;Tuesday&amp;#34;  when 3  display &amp;#34;Wednesday&amp;#34;  when 4  display &amp;#34;Thursday&amp;#34;  when 5  display &amp;#34;Friday&amp;#34;  when 6  display &amp;#34;Saturday&amp;#34;  when 7  display &amp;#34;Sunday&amp;#34;  default  display &amp;#34;请检查输入是否正确&amp;#34;  end case 代码解析</description>
    </item>
    
    <item>
      <title>4.赋值运算符</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/4.assignment-operator/</link>
      <pubDate>Wed, 19 Jul 2023 15:52:27 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/4.assignment-operator/</guid>
      <description>赋值运算符和赋值表达式#赋值运算时BDL中常见运算，一般用来改变变量的值。 BDL中提供了赋值运算符号let =，和函数返回值赋值returning两种估值方式。
赋值表达式# let = 赋值  之前我们已经多次使用let a = 1对变量进行赋值，我们可以看到使用这种方式赋值的方式，=左边是我们要赋值的变量，且只有一个。 =右边是我们要赋予的值。
let a = a + 1之前我们还是用过这样的方式进行求和，=右边作为一个整体计算结果之后，再赋值给=左边。
returning 函数返回值赋值  函数之后会详细讲解，我们现使用我们已经用过的sfmt()函数作为说明。
运行以下代码：
database ds define a,b,c integer MAIN  define s string  call to_day() returning s  display s  sleep 1 --这里是暂停一秒的意思，防止时间太接近而无法区分  let s = to_day()  display s END MAIN  function to_day()  return current end function 我们可以看到以下内容，s的值被赋值了两次。</description>
    </item>
    
    <item>
      <title>4.输入</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/4.input/</link>
      <pubDate>Tue, 18 Jul 2023 14:51:44 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/4.input/</guid>
      <description>输入&amp;ndash;键盘与鼠标的交互#之前的程序，我们都是在输出，输入的值，我们都是编写在程序中。
但这让程序每次输出的结果都一样，如果我们要其它结果就要重新编写代码。
为了解决上述问题，我们引入BDL语言可以支持的输入方式。
Prompt&amp;ndash;初次接触用户界面#请运行一下代码，查看输出情况，运行前请确保打开GDC客户端
define birth date prompt &amp;#34;请输入你的生日:&amp;#34; for birth display birth using &amp;#34;yyyy年mm月dd日&amp;#34; 是否出现了这个弹窗，如果未出现，请检查GDC安全性设置，调整为最低，且端口为6400。
随便输入一点东西试试看，报错了！String to date conversion errr.。 字符串转日期格式失败，它可以帮我自动转为日期格式！而且会检查是否正确！
我们尝试输入19900101或者900101。
现在查看控制台，成功转为了日期！
1990年01月01日 代码分析
prompt &amp;quot;请输入你的生日:&amp;quot; for birth 这一行为我们做了不少事情，我们来分析一下
 弹出一个新窗，且有一个可以输入的地方和确定取消按钮。 可入处有输入说明。 可输入的地方只能输入能转为日期的内容，否则无法确定并完成。 将输入的内容转为birth变量的数据类型。  仅一行代码，就可以做这么多事情，这就是一开始说的BDL抽象级别比较高。 将大量的常使用功能集成到一起，不需要我们为重复的事情编写代码。
让我们试一试下面这些代码:
define birth date define name varchar(6) define sex varchar(1) prompt &amp;#34;请输入你的生日:&amp;#34; for birth prompt &amp;#34;请输入你的姓名:&amp;#34; for name prompt &amp;#34;你是男生吗y/n:&amp;#34; for sex display sfmt(&amp;#34;\n%1你好,你是否是男生(%2),你的生日是%3&amp;#34;,name,sex,birth using &amp;#34;yy/mm/dd&amp;#34;) 你会发现，prompt除了可以转换资料类型，还能够限制可以输入的字数。（一个中文汉字需要yi\一个varchar(3)）</description>
    </item>
    
    <item>
      <title>4.变量</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/4.variable/</link>
      <pubDate>Tue, 18 Jul 2023 09:23:44 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/4.variable/</guid>
      <description>变量#变量定义#变量定义，变量申明，都是同一个意思的两种翻译方法。
在定义变量的时候，需要给这个变量-一个名字。有了名字之后才能使用这个变量。回顾曾经编写的BDL语言代码，可以发现这些代码中，凡是用双引号括起来的部分，都是字符串。 那些没有用引号括起来的单词，一部分是C语言提供的关键字，比如integer，string等， 还有一部分是BDL语言提供的符号，如=、+、-、()、{}等，这些单词和符号就是BDL语言的核心部分，编译器生来就认识它们。 另外没有使用双引号括起来的单词，如define a integer,其中的integer是关键字，a就是非BDL语言的关键字，对于编译器来说，它是不认识的。 要让编译器知道这个单词是什么意思，所以有了定义(define)。
对于变量来说，变量的定义会使得编译器在变量符号表中新增一条记录。 这样编译器在后面如果读入了一个变量名，通过查询符号表，就知道是否声明过了。
 一行可以定义多个变量  define a,b,c integer  一样也可以拆成两行  define a,  b,  c integer  每行也可以只定义一个变量  define a integer define b integer define c integer  变量定义的顺序可以打乱  define b integer define a integer define c integer  不同类型可以定义在同一个define中，但必须指定每个不同类型变量的数据类型  define a,  b integer  c varchar(10) 定义变量的意义#BDL为什么要规定要先定义变量呢？ 为什么要指定变量的名字和对应的数据类型呢？</description>
    </item>
    
    <item>
      <title>4.函数调用</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/4.call-function/</link>
      <pubDate>Mon, 17 Jul 2023 15:30:22 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/4.call-function/</guid>
      <description>函数调用#看如下代码
 display sfmt(&amp;#34;\nhello world&amp;#34;) 这一行我们调用了，一个sfmt的函数，小括号中内的双引号括起来的文字是sfmt函数的参数。
该函数的功能就是把小括号的文字变为字符串，而display的功能就是将一个字符串功能打印出来。如果双引号内容改变，打印在控制台的内容也会改变。
说明
“\n”在这里有特殊的含义，读者可以发现“\n”并没有在屏幕中打印出来。
“\n”中的“\”是转义字符，表示其后面紧跟的字符有专门的意思。“\n” 表示将光标移到第二行第一格。也就是回车换行的意思。
请读者注意函数定义和函数调用有如下的不同之处。
 简单地说，所谓函数定义就是程序员编写程序代码，去实现函数的功能。  请读者注意，定义好的函数不-定会被调用。
比如BDL语言提供的大批库函数都已经实现，但是程序员编写程序并不会用到库函数中的每一个函数，只是从中挑选有用的库函数来使用。
函数调用就是调用已经编写好的函数，这些已经编写好的函数，可以是程序员自己编写的，叫做自定义函数；有的是BDL语言系统提供的函数，叫做库函数；有的是第三方提供的函数，叫做第三方库函数。BDL语言系统向程序员提供了非常丰富的库函数，以方便程序员使用。  本例中，sfmt函数被主函数main调用。sfmt函数的定义读者是看不见的，当然也看不见sfmt函数的代码，也就不清楚sfmt函数是如何实现的。</description>
    </item>
    
    <item>
      <title>4.调试排错</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/4.debug/</link>
      <pubDate>Mon, 17 Jul 2023 14:17:28 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/4.debug/</guid>
      <description>调试排错-查看代码如何一步步执行#程序员的主要工作之一是编写代码。 代码从无到有，需要逐个字符输入，工作量显然比较大。 但实际上，编码容易调试难。
代码编写完毕后，程序员将会花费大量时间进行错误或者问题的排查、修改。 在电脑系统程序中，将隐藏着的一些未发现的缺陷、问题或者错误，成为bug。
debug&amp;ndash;由来#马克2号（Harvard Mark II）编制程序的格蕾丝·霍珀（Grace Hopper）是一位美国海军准将及计算机科学家，同时也是世界最早的一批程序设计师之一。有一天，她在调试设备时出现故障，拆开继电器后，发现有只飞蛾被夹扁在触点中间，从而“卡”住了机器的运行。于是，霍珀诙谐地把程序故障统称为“臭虫（BUG）”，把排除程序故障叫DEBUG，而这奇怪的“称呼”，竟成为后来计算机领域的专业行话。
调试水平的高低，很大程度上显示出程序员能力的高低。 可以说，不会调试的程序员，是不会开发出好的软件的。
幸好，无论tiptop gp还是t100都集成了调试工具，运行r.d2+ czzi001(t100为r.dg czzi001)。
看，除了我们写的代码还多了一些代码，这些是tiptop gp自动加上的代码，是已经打包在编译连接中的代码，所以我们无法去除，这也是我们必须要写第一行database ds的原因，这些自动增加的代码中需要连接数据库。
设置断点#断点是为了方便程序员在调试过程中观察程序内容个状态而专门设置的一种调试手段。
也是在调试模式下运行程序的过程中，当程序语句运行到设置的断电时，暂停程序运行，但是程序当时的内容、寄存器、上下文环境等数据都被保存，并且代码中指示出当前停留在代码哪一行。然后程序可以不慌不忙地利用调试器查看程序内部状态。
如何设置断点#在调试器中设置断点，先用鼠标或者方向键，将活动行移动到你需要设置断点的代码行上，然后按下F9键、点击Toggle按钮或者双击当前行即可设置断点，重复操作即可取消断点。
调试运行#设置完断点之后，可以通过F5键(Run/Cont按钮)在调试器中启动程序。程序启动后，当运行到断点代码行后，程序暂停
 此时程序暂停于当前设置的断点代码行处，可以发现一个小箭头标识在终端行左侧。这表示当前运行的代码行。 此时这个程序已经运行起来，不过出于暂停状态，可以看到控制台没有“Hello World”输出，这表示当前代码行还未运行。 按F10键（Step Over按钮），可单步运行。每按一次F8键，就运行一行代码，直到程序运行结束。如果不想单步运行，可以直接F5键接着运行到下一个断点。如果后续没有断点，会直接运行到程序结束。 运行结束，程序提示正常退出   </description>
    </item>
    
    <item>
      <title>4.程序开发生命周期</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/4.program-life-cycle/</link>
      <pubDate>Mon, 17 Jul 2023 11:28:31 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/4.program-life-cycle/</guid>
      <description>程序开发生命周期#在windows 下，利用记事本这个软件，输入并编辑文件可以保存一个.txt后缀名的文件。类似的还有.xlsx。它们都可以通过记事本或者excle这类的软件打开，但本身是无法运行或者展现内容的。
那么你有没有想过如何产生一个.exe可执行文件呢。
聪明的你一定知道了。 是的，通过编写某种语言的源代码，编译成功通过后，在经过链接，成功后就可以产生一个可执行的文件。这就是所谓的程序。
编写BDL源代码#关于环境的说明
如果你是使用鼎捷系列软件，那么你需要新建一个程序代码，如何建立本书不会介绍。
如果你要学习，可以见TIPTOP相关书籍，本书只介绍代码部分。
由于t100与tiptop gp编译和链接代码也不同，所以本书以tiptop gp命令为主，如果你使用不同的系统，请自行替换为你系统的代码。
例如：tiptop gp 使用r.l2 连接，t100使用r.l 连接。
为什么不以底层fgllink写呢，因为license原因，有的环境可能不允许使用这类命令，所以不再赘述。
编辑BDL源代码#编辑BDL源代码就是做如下工作：
 逐个输入字符，如汉字、英文、标点符号或者其它可以用键盘输入的字符 通过插入、删除、移动、复制、粘贴等方法修改已经输入的字符 将输入修改完毕的所有字符保存到硬盘上  一篇由汉字、英文、标点符号或者其它可以用键盘输入的字符的内容被称作文本。 能够进行文字编辑的软件被称作编辑器。
通俗的将，源代码就是程序员输入编写的符和BDL语言语法规则的文本。 如下片段就是一段源代码:
main  display smft(&amp;#34;Hello World!&amp;#34;) end main 扩展名用.4gl标识其为一个BDL源代码文件。源代码文件简称源文件。
编辑器的功能很大程度上能够帮助程序员提高工作效率。只要能输入文字的文本编辑软件都可以作为源代码编辑器。 如记事本软件、字处理软件Word、vs code等。但是专业程序员一般采用专业源代码编辑器，如业界鼎鼎有名的编辑工具由VI/VIM、Emacs/XEmacs等。 一个好的源代码编辑器、要求具备关键字着色功能（可以使用不同颜色标识代码的不同部分）、优秀的代码跳转功能、代码自动补全功能等。
编译BDL源代码#编译时BDL源代码翻译成用二进制指令标识的目标文件。 这里的目标文件与机器语言还有一段距离，并不是真正的机器语言，所以不能被计算机直接运行。
编译过程由编译系统程序完成。编译程序简称为编译器。编译程序运行后，自动对源程序进行句法和语法检查，当发现错误是，就将错误的类型和所在位置显示出来，帮助修改程序中的错误。 用户可以继续利用编辑器对源程序进行修改。修改后，重新编译，直到编译通过为止。
连接目标文件#多个源代码文件经过编译后产生了多个目标文件，此时还没有将其组合装备为一个可以运行的整体，因此计算机还是不能执行。
连接过程是用连接程序将目标文件、第三方目标文件、BDL语言提供的运行时的一些函数装配为一个完成的可执行的目标程序。
编译连接过程示例#有时候为了叙述方便，将编译和连接两个步骤，统一用编译一个词语代替，读者应该清楚实际经历了两步。
  当源代码没有报错是，编译连接过程如下：   当编译时，不会产生目标文件，如下：    现在你可能还看不懂提示信息的含义，不用担心，后面章节会慢慢了解到。现在你只要关注如果源代码错误，会出现什么情况即可。</description>
    </item>
    
    <item>
      <title>5.预编译</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/5.preprocessor/</link>
      <pubDate>Mon, 28 Aug 2023 20:52:53 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/5.preprocessor/</guid>
      <description>预编译#预处理器指令通常用于简化源程序在不同的执行环境中的更改和编译。 源文件中的指令告知预处理器采取特定操作。 例如，预处理器可以替换文本中的标记，将其他文件的内容插入源文件，或通过移除几个部分的文本来取消一部分文件的编译。 在扩展宏之前，将识别并执行预处理器行。 因此，如果宏扩展到类似于预处理器命令的内容，该预处理器无法识别该内容。
预编译指令在编译之后就不影响程序了，所以不会影响程序运行效能。
预编译执行可以在程序任何位置写入。
&amp;amp;include 文件引入#在编写函数中，我们有些重复的逻辑，又无法封装为一个函数的场景。为了避免重复代码，我们可以使用&amp;amp;include。
&amp;amp;include并不是一个语法，而是一个预编译指令&amp;ndash;在编译时就生效。
&amp;amp;include用法是，后续跟需要导入的源代码文件，当编译时，编译到&amp;amp;include指令行数时，将后面文件原样导入到当前文件中。所以此指令不会影响到运行时效率。在编译后此指令依据不存在了。
当然这样也有缺点，我们在debug调试的时候，无法通过step in进入到&amp;amp;include中查看了，为排查错误带来了负向影响。
&amp;amp;define 宏定义#宏定义的时将任意一个东西替换为宏定义内容，宏定义并不是定义常量，而是将定义的内容原样替换。
&amp;amp;define MAX_TEST 12 &amp;amp;define HW &amp;#34;Hello world&amp;#34;  MAIN  DEFINE i INTEGER  FOR i=1 TO MAX_TEST  DISPLAY HW  END FOR END MAIN 你甚至可以定义&amp;amp;define mian main 这样你代码中所有的mian都会替换为main。而替换后的main可以正常使用。
&amp;amp;define mian main mian  display &amp;#34;123&amp;#34; end main 字符串替换符号##在宏定义中可以使用#，类似参数传递，会将内容转化为字符串
&amp;amp;define disp(x) DISPLAY #x disp(abcdef) 如以上代码将输出abcdef</description>
    </item>
    
    <item>
      <title>5.多笔查询</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/5.select-rows/</link>
      <pubDate>Thu, 24 Aug 2023 16:53:04 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/5.select-rows/</guid>
      <description>多笔查询#在上一节中我们学会了多种方式查询数据中数据，且即使多条结果，也能够灵活查询。
这节我们将重点介绍多笔查询的注意点，和进阶查询语法FOREACH。
FETCH&amp;ndash;进行多笔查询#在上一节中我们用FETCH可以查询一条数据，也可以查询多比数据。
现在我们假设有一个需求，查询数据中ima_file中字段ima01以E开头的所以资料。并将查询的结果保存到一个数组中。
让我们利用上一节的FETCH来完成上述需求。
define l_ima dynamic array of record like ima_file.* define l_cnt,l_i integer define l_sql string  -- 获取查询结果的资料总笔数 let l_sql = &amp;#34;select count(*) from ima_file where ima01 like ? &amp;#34; prepare ima_cnt from l_sql execute ima_cnt into l_cnt using &amp;#34;E%&amp;#34;  -- let l_sql = &amp;#34;select * from ima_file where ima01 like ? &amp;#34; declare ima_sel cursor from l_sql  open ima_sel using &amp;#34;E%&amp;#34; for l_i = 1 to l_cnt  fetch absolute l_i ima_sel into l_ima[l_i].</description>
    </item>
    
    <item>
      <title>5.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/5.practice/</link>
      <pubDate>Thu, 20 Jul 2023 17:49:58 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/11.array/5.practice/</guid>
      <description>练习#定义一个字符串数组，并输出每个字符串字符对应ASCII的值#字符串数组的值分别为&amp;quot;A&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;d&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;G&amp;quot;
写出下列代码输出结果# define i,j integer  define a array[4] of integer  let a[1]=1 let a[2]=2 let a[3]=3 let a[4] =4  for i = 1 to 4  for k = 1 to i  let a[i] = a[j] - a[i]  end for  end for  for i = 1 to 4  display sfmt(&amp;#34;%1&amp;#34;,a[i])  end for </description>
    </item>
    
    <item>
      <title>5.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/5.practice/</link>
      <pubDate>Thu, 20 Jul 2023 13:39:23 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/10.function/5.practice/</guid>
      <description>联系#自定义一个函数，计算你的存款利率。#例如输入10000块钱，定期存款3个月，那么3个月后你拥有多少钱？
 假设月利息3.1%
 </description>
    </item>
    
    <item>
      <title>5.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/5.practice/</link>
      <pubDate>Thu, 20 Jul 2023 09:59:33 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/9.over_and_over_again/5.practice/</guid>
      <description>练习#以下代码输出结果是什么# define i,j integer  let i = 1 let j = 3  while j&amp;lt;5 or i&amp;gt;3  let i = i + 1  let j = j + 1  display &amp;#34;*&amp;#34;  end while 根据以下代码，写出变量a和b的值# define a,b integer  while a &amp;gt; 0  let b = b + 1  let a = a - 2  end while  display sfmt(&amp;#34;\na=%1,b=%2&amp;#34;,a,b) 已以下这种格式控制台打印99乘法表#1*1=11*2=2 2*2=41*3=3 2*3=6 3*3 =9.</description>
    </item>
    
    <item>
      <title>5.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/5.practice/</link>
      <pubDate>Wed, 19 Jul 2023 19:58:40 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/8.condition/5.practice/</guid>
      <description>练习##</description>
    </item>
    
    <item>
      <title>5.类型转换</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/5.type-conversion/</link>
      <pubDate>Wed, 19 Jul 2023 16:14:00 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/5.type-conversion/</guid>
      <description>类型转换#前面章节中大家已经廖家，整数和浮点数在计算机中表示方法不同，占据的内存空间大小也有所不同。
如果某下时候，需要将一个integer类型数据存储到decimal类型变量中。此时就需要进行转换。这种不同类型的数据进行转换就称作类型转换。
自动转换#BDL中为了使编程简单，几乎所有数据类型都可以自动转换。 例如你可以写这种代码
 define a integer  let a = &amp;#34;12345.23&amp;#34; 字符串将自动转为整数12345，同样，整数也会自动转为字符串。
 不过要注意之前我们说using的时候，数值类型转字符串会自动补空格。
 但是如果我们要是一个无法理解的内容，会如何自动转换呢？
 define a integer  let a = &amp;#34;你好&amp;#34; 如果你在debug中查看会发现a的值会变为null，如果非法值转换，所有变量都会变为null，这将丢失之前变量的值!
哪些情况会自动转换呢# 赋值  无论是let还是returning都会自动转换为目的变量类型
传参  参数部分后续会详细讲，sfmt(&amp;quot;%1&amp;quot;,1)这个函数中&amp;quot;%1和1就叫做参数，1会自动转为字符串。
SQL语句  select ima01 from ima_file where ima01 = 2234 SQL语句后续会详细讲，这里先知道有印象就好
字符串拼接  字符串可以用两种方式凭借,和||，这两种方式都会自动转为字符串</description>
    </item>
    
    <item>
      <title>5.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/5.practice/</link>
      <pubDate>Tue, 18 Jul 2023 16:00:50 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/5.interaction_between_keybord_and_mouse/5.practice/</guid>
      <description>练习# 输出一下样式的数据   +------------------+-----+| 姓名| 年纪|+------------------+-----+| 小| 10|| 小蜜蜂| 9|| 小明| 8|| 小刚| 12|| 小红| 24|+------------------+-----+ 输入身份证号，输出身份证号的后4位。  </description>
    </item>
    
    <item>
      <title>5.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/5.practice/</link>
      <pubDate>Tue, 18 Jul 2023 10:22:43 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/4.how_save_and_get_data/5.practice/</guid>
      <description>练习-几个与变量相关的经典算法#几乎每一个程序 都必须使用到变量，因为程序就是处理数据的，而数据必须存储在变量中。 本节仅举几个简单的变量使用的例子。 这些例子都是一些经 典的做法，请读者深刻理解并记住。
累加和累乘#所谓累加，就是将一系列的数字分别相加，最后得到一个结果。 如计算1+2+3+4+5：
 define x integer  let x = x + 1  let x = x + 2  let x = x + 3  let x = x + 4  let x = x + 5  display sfmt(&amp;#34;\n1+2+3+4+5=%1&amp;#34;,x) 编译运行，结果为：
1+2+3+4+5=15 代码解析
不要认为这道算术题如此简单，让计算机来计算是大材小用。 读者要知道，通过一些简单的算术计算，可以理解编程中的一些基本技巧，为今后的真正开发软件打基础。
这些简单的数学题，是在锻炼读者的编程能力。
define x integer 定义了x为整型，整型的默认初始值为0。
重点来关注:
let x = x + 1 这行代码就使用到了一个非常经典的累加算法。 这行代码是一个赋值语句。就是将赋值号“=”右边计算后所得的值，赋给左边的变量。再重申一次，这里的等号“=”是BDL语言中的赋值号，不是数学里表示相等的等号。</description>
    </item>
    
    <item>
      <title>5.计算1&#43;1</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/5.count-1&#43;1/</link>
      <pubDate>Mon, 17 Jul 2023 15:49:10 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/5.count-1&#43;1/</guid>
      <description>计算1+1&amp;ndash;小有作为#以下代码实现了计算1+1的值。
databse ds main  define a,b integer --定义a,b 为整型  define y integer --定义y为整型   let a = 1 --将变量a赋值为1，此时a的值为1  let b = 1 --将变量b赋值为1，此时b的值为1  let y = a + b --将a，b的值分别取出来，计算结果后，赋值给变量y  display sfmt(&amp;#34;\na+b=%1&amp;#34;,y) --将y的值打印出来 end main 编译运行后，程序结果如下a+b=2
代码解析
 和之前代码一样，包含了database ds，同样也只有一个main函数。这是BDL语言规定，必须编写main函数。 define a,b integer定义a，b两个整形变量 define y integer定义y整形变量 空行用于分隔变量声明部分和接下来的函数实现部分。主要是逻辑分隔，利于程序员阅读代码，对编译器来说并无意义。 let a=1 给变量a赋值1，此时a的值为1,let是BDL的规定，赋值时必须使用。 let b=1 给变量b赋值1，此时b的值为1 let y = a + b 将a，b的值分别取出来，计算结果后，赋值给变量y display sfmt(&amp;quot;\na+b=%1&amp;quot;,y),将y的值打印出来。这个sfmt和以前代码中的用法不同，简单说明下，更详细的解释参见后续章节。 双引号中的“\n”，时回车换行。 “a+b=”原样输出。 “%1”中的%是格式化的起始字符，只在sfmt函数中这样用，意思是将y在这个位置显示出来。所以最后的输出是：  a+b=2 </description>
    </item>
    
    <item>
      <title>5.开始你的第一个程序</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/5.write-your-fisrt-program/</link>
      <pubDate>Mon, 17 Jul 2023 13:15:18 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/1.before_all/5.write-your-fisrt-program/</guid>
      <description>开始你的第一个程序# 使用你自己的编辑器，写一个输出&amp;quot;Hello World&amp;quot;的程序。  display &amp;#34;Hello World&amp;#34; 将你写的程序上传到服务器，并进行编译等一系列操作后，运行并测试是否能输出&amp;quot;Hello World&amp;quot;  </description>
    </item>
    
    <item>
      <title>6.DISPLAY</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/6.display/</link>
      <pubDate>Tue, 29 Aug 2023 15:45:32 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/6.display/</guid>
      <description>DISPLAY#在之前终端执行程序时，我们一直使用DISPLAY讲字符串显示到终端。 在程序升级到GUI版本后，我们不需要再回去看终端了，DISPLAY有了新的用法。
注意
因为BDL中，表格和非表格的控件方式有明显区别，所以讲非表格控件称为表单,表格称为表格。这并不是通用的定义，仅为了在本教程中方便区分两种。
 表格 表单  DISPLAY 表单#4fd文件
database ds main  define sr record  FFLabel1 varchar(40),  ComboBox1 varchar(40),  DateEdit1 date,  Edit1 varchar(40),  CheckBox1 varchar(40)  end record  open window act_w with form &amp;#34;czz/42f/czzi001&amp;#34;   menu &amp;#39;&amp;#39;  on action quit  exit menu  on action setvalue  let sr.FFLabel1 = &amp;#39;FFLabel1 &amp;#39;  let sr.</description>
    </item>
    
    <item>
      <title>6.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/6.practise/</link>
      <pubDate>Tue, 29 Aug 2023 08:13:19 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/16.module/6.practise/</guid>
      <description>练习#使用cl_null()、cl_replace_str()、cl_digcut()、cl_get_env()# p_findfunc作业可以查询tiptop gp中常用sub、lib函数 请注意以上函数需要的参数和返回值数量  新增一个lib函数cl_get_runtime_line()# 无参数 以下方式返回一个字符串，czz_czzi001.4gl为当前运行的文件名称，7为代码运行的当前行  file:czz_czzi001.4gl line:7 可以使用__FILE__ __LINE__ 两个宏定义标记  </description>
    </item>
    
    <item>
      <title>6.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/6.practise/</link>
      <pubDate>Sun, 27 Aug 2023 15:45:02 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/14.database/6.practise/</guid>
      <description>练习#创建学生资料表student#   字段 数据类型 字段说明     name varchar(20) 姓名   grade varchar(4) 年级   course varchar(40) 课程名称   score number(5) 得分    输入学生资料信息，插入到数据库# 如果相同已经有该姓名、年级、课程名称的资料那么更新已有成绩 如果得分小于0，或者大于100，报错，跳过这笔资料 当有20笔资料时，停止录入     姓名 年级 课程名称 得分    查询每门课的最高成绩，和平均成绩，并以以下格式显示#课程名称 平均分 最高分a 67 90b 87 99 查询按照课程名称和成绩倒序排列显示成绩单#姓名 年级 课程名称 成绩小米 4 数学 78小红 5 语文 98 </description>
    </item>
    
    <item>
      <title>6.运算符优先级</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/6.operation-priority/</link>
      <pubDate>Wed, 19 Jul 2023 16:34:55 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/6.operation-priority/</guid>
      <description>运算符优先级#BDL中运算符具有不同优先级和结合性。
在表达式中，各运算量参与运算的先后顺序不仅要遵守运算符优先级别的规定，还要受运算符集合的制约，以便确定自左向右进行运算还是自右向左预算。
优先级、结合性汇总#   优先级 运算符 结合性 说明 用法     13 units 左 间隔转换 (12) units day   12 ** 左 幂 x**5   12 mod 左 求余数 x mod 2   11 * 左 乘法 x*y   11 / 左 除法 x/y   10 + 左 加法 x+y   10 - 左 减法 x-y   9 || 左 连接符 &amp;ldquo;ab&amp;rdquo;   8 like 右 字符串比较 mystring like &amp;ldquo;A%&amp;rdquo;   8 matches 右 字符串比较 mystring matches &amp;ldquo;A*&amp;rdquo;   7 in() 左 清单比较 var IN(&amp;lsquo;CA&amp;rsquo;,&amp;lsquo;NY&amp;rsquo;)   6 &amp;lt; 左 小于 a&amp;lt;10   6 &amp;lt;= 左 小于等于 a&amp;lt;=10   6 &amp;gt; 左 大于 a&amp;gt;10   6 &amp;gt;= 左 大于等于 a&amp;gt;=10   6 == 左 等于 a==10   6 &amp;lt;&amp;gt; or !</description>
    </item>
    
    <item>
      <title>6.变量</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/6.variable/</link>
      <pubDate>Mon, 17 Jul 2023 15:59:44 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/6.variable/</guid>
      <description>变量&amp;ndash;数据从哪里来，又到那里去#在计算机程序设计中，经常要用到变量。比如在屏幕中移动光标，需要存储光标的x，y坐标，每次移动光标，就需要对坐标修改，也就是x、y的值要改变;为了得到当前光标的坐标，就需要从x、y中得到当前的值。在程序设计中这些值都是通过变量来完成的。
变量在内存中的表现形式#变量是指其值可以变化的量。在计算机中，指令代码、数据都存储于内存中。变量也需要存储在内存中。
类比人类的思维过程，也很容易明白为什么需要内存空间存储变量:假设现在有3个数据，分别是a=3,b=4,c=5，需要读者去计算“a+b+c&amp;quot;的值。 读者首先回忆a的值是3，b的值是4,c的值是5，然后分别用3、4、5作为计算的数得到“3+4+5=12”。
这是一个很简单的过程，思考过程几乎不花费时间。如果计算的变量超过100个，估计大部分读者都记不住这么多数据的值，需要把这些数据及其对应的数值记录在纸上或其他地方，当需要用到某个数据的时候，再去查看其对应的值。计算机中变量的作用与它类似。
在计算机中，每个变量都被分配了一块内存空间，在这些空间里存储的就是变量的值。 变量之所以可以变化，就是这个存储空间可以存储不同的数值。存储空间里的值变化，则变量对应的值也变化。 同一个时间，内存空间里只能保存一份值，新值冲掉了原来的旧值。 每个内存单元都有编号，这些是内存的地址。如图所示。
编译器使用变量符号表#在源代码中，每个变量都有变量名。 实际上，编译后的目标代码里并没有变量名字，而是记录着变量在内存空间中的地址。 在BDL语言中，通过变量名就可以访问到变量的值，对变量名的访问，就是对变量值的访问。
在编译的过程中，编译器会建立-张变量符号表，该表记录的数据是:变量类型、变量名、变量地址等信息。
变量及其使用#变量有不同的类型，如记录英文字母及标点符号，就需要字符类型(varchar)的变量； 记录整数需要整数类型integer的变量； 记录实数有decimal类型的变量。 这些变量都是数值类型，BDL语言还提供了其他类型的变量，详细讲解请参见后续章节的论述。
通过上述的简单叙述，读者可以对变量有了一个大概的感性认识。再回过头来看看源代码中每行的意思。
databse ds main  define a,b integer --定义a,b 为整型  define y integer --定义y为整型   let a = 1 --将变量a赋值为1，此时a的值为1  let b = 1 --将变量b赋值为1，此时b的值为1  let y = a + b --将a，b的值分别取出来，计算结果后，赋值给变量y  display sfmt(&amp;#34;\na+b=%1&amp;#34;,y) --将y的值打印出来 end main  define a,b integer  这是向编译器声明，以下程序将会用到两个整型变量，其名字为a和b。此时并不会进行真正的内存分配动作，也就是此时并没有内存地址与变量名关联。</description>
    </item>
    
    <item>
      <title>7.INPUT</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/7.input/</link>
      <pubDate>Tue, 29 Aug 2023 15:45:38 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/7.input/</guid>
      <description>INPUT#INPUT 和DISPLAY 一样可以将资料显示在已打开的画面上。
和DISPLAY不同的地方在于，DISPLAY中用户只能点击按钮操作，而INPUT中每个栏位(entry设置为&amp;rsquo;Y&amp;rsquo;)都变为可输入的状态，用户输入后将输入的内容赋值给INPUT中的变量。
和DISPLAY和语法一样，INPUT也有两种语法。
INPUT 表单#INPUT p_employee.no FROM no
INPUT BY NAME p_employee.no
以上两种语法和DISPLAY一致，INPUT BY NAME语法中，结构体的成员名称必须和画面中控件名称相同。
除了以上语法INPUT也支持块语法END INPUT。
INPUT variable-list FROM field-list  BEFORE INPUT   AFTER INPUT   BEFORE FIELD field-list   AFTER FIELD field-list   ON CHANGE field-list   ON ACTION action-name   ON IDLE idle-seconds  END INPUT 因为在表单录入时，我们需要校验字段值、或者指定字段输入顺序、带出默认值等限制性操作，所以在表单时就提供了块级别语法，在块语法中，我们可以加上我们想限制的语法。
注意
块语法中所有内容都是可选的，如果任何语句都没有，那么和不写END INPUT是一样的。
INPUT额外支持语法#DISPLAY 中所有语法INPUT都支持，除了之前讲过的语法，还支持以下语法：</description>
    </item>
    
    <item>
      <title>7.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/7.practice/</link>
      <pubDate>Wed, 19 Jul 2023 16:56:50 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/6.operators_and_expressions/7.practice/</guid>
      <description>练习#测试以下代码输出# define m,n integer  define x,y decimal(20,6)  let m = 1 let n = 2  let x=1.41 let t=2.5   display sfmt(&amp;#34;\nm&amp;lt;n and y-1&amp;gt;x=%1&amp;#34;,m&amp;lt;n and y-1&amp;gt;x)  display sfmt(&amp;#34;m&amp;lt;n or y-1&amp;gt;x=%1&amp;#34;,m&amp;lt;n or y-1&amp;gt;x)  display sfmt(&amp;#34;not (y-1&amp;gt;x)=%1&amp;#34;,not (y-1&amp;gt;x)) 用笔计算处以下代码运行结果，然后键入系统。# 看看笔算的结果和系统计算结果一样
  define a,b integer  let a=5 let b=4   display sfmt(&amp;#34;\n最后输出的结果是%1，但是a的值是%2&amp;#34;,a=2*8,a/4)  let a=2*8  let a=a/4  display sfmt(&amp;#34;a的值是%1&amp;#34;,a)  display sfmt(&amp;#34;a和b的比较结果是=%1&amp;#34;,a==b) </description>
    </item>
    
    <item>
      <title>7.设计一个BDL函数</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/7.create-a-function/</link>
      <pubDate>Mon, 17 Jul 2023 16:20:12 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/7.create-a-function/</guid>
      <description>设计一个BDL函数#用BDL语言库函数和第三方提供的函数组装程序是程序设计的&amp;ndash;条捷径和重要方法。但是，一个BDL程序不可能只由一个main函数组成，不能在main函数中实现所有的功能。编写程序，更多的时候需要程序员自己动手创建新的函数。
在main函数中计算3个整数的平均数#先看以下代码
databse ds main  define a,b,c,y integer --定义abc为整型  let a = 1 --赋值  let b = 2 --赋值  let c = 3 --赋值  let y = (a+b+c)/3 --进行数字计算  display sfmt(&amp;#34;\n the average is %1&amp;#34;,y) end main 编译后运行，程序输出为
the average is 2 代码解析
 main 不再赘述 define a,b,c,y integer 定义变量为整形， let ...= 1,2,3 变量赋初始值 let y = (a+b+c)/3  向编译器声明变量y为整型变量。计算a+b+c的值得到6，再整除3，得到2。 然后将2赋值给y。 “()&amp;ldquo;在这里同数学里的四则运算中的小括号“()”一样，表示需要优先运算。 “/”相当于四则运算中的除法运算。</description>
    </item>
    
    <item>
      <title>8.CONSTRUCT</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/8.construct/</link>
      <pubDate>Tue, 29 Aug 2023 15:45:47 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/8.construct/</guid>
      <description>CONSTRUCT#为了避免SQL注入安全问题，BDL提供了CONSTRUCT语法，用来输入SQL查询条件的场景。
CONSTRUCT运行时，会先清空输入字段的所有资料内容，然后根据录入的内容组成SQL查询条件。
CONSTRUCT并不区分表单还是表格，因为表格也只能录入第一行资料。
CONSTRUCT 有两种写法，两者只在开头处有区别，块语法中无区别，所以放在一起讲
 BY NAME ON  CONSTRUCT BY NAME variable ON column-list  [ ATTRIBUTES ( { display-attribute  | control-attribute }  [,...] ) ]  [ HELP help-number ] [ dialog-control-block  [...] END CONSTRUCT ]  ON FROM  CONSTRUCT variable ON column-list FROM field-list  [ ATTRIBUTES ( { display-attribute  | control-attribute  } [,...] ) ]  [ HELP help-number ] [ dialog-control-block  [.</description>
    </item>
    
    <item>
      <title>8.语句</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/8.statement/</link>
      <pubDate>Mon, 17 Jul 2023 16:49:56 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/8.statement/</guid>
      <description>语句构成程序#BDL语言有以下5中类型语句。
 表达式语句。 BDL语言中，操作者或动作可成为表达式。 例如以下示例都是表达式语句：  define a integerdisplay &amp;#34;hello world&amp;#34; BDL还有很多中流程控制语句。 如if-else，for循环语句，while循环语句，continue，结束本次循环语句，break跳出循环语句，switch多路分支语句，goto专项语句，return返回语句。 学习到画面规格后，还将设计到input输入语句，display显示语句（这里display与现在的display不同），dialog交互等画面控制语句。 函数调用构成的函数调用语句 符和语句，将以上语句写在同一行的语句  BDL语言中最小的程序单元是语句。 另外在源代码中有一些是指示编译器如何编译的预处理器指示命令，如&amp;amp;ifdef &amp;amp;endif &amp;amp;include等。 BDL语言源代码，就是由语句和这些指示命令构成的。</description>
    </item>
    
    <item>
      <title>9.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/9.practise/</link>
      <pubDate>Tue, 29 Aug 2023 15:46:01 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/17.interface/9.practise/</guid>
      <description>练习#学生成绩录入作业# 功能录入每个学生三门成绩，语文、数学、英语 每次录入完毕在后台显示改学生出成绩 成绩为0~100的整数 学生姓名不能重复录入  进阶#请将上述资料建立合适的表，并保存到数据库
利用表格显示学生成绩# 可修改成绩，但不能修改学生姓名 不可增加、删除 可以查询，学生栏位可以开窗选择  </description>
    </item>
    
    <item>
      <title>9.代码风格</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/9.code-style/</link>
      <pubDate>Mon, 17 Jul 2023 16:58:11 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/9.code-style/</guid>
      <description>代码风格&amp;ndash;向优秀程序员看齐#所谓代码风格，是编写代码时对代码的排版布局、如何命名代码中的变量名称、函数名称等。 一个优秀的程序员，除了代码质量高、错误少之外，另一个非常重要的标准就是代码风格。
在很多时候，代码风格比程序的效率更加重要，代码风格的好坏可以直接看出一个程序员编程 的素质。
优秀的代码风格如同一身得体的打扮，能够给人以良好的印象。
初学程序设计，首先必须建立良好的编程习惯，这其中就包括代码风格。
代码风格是很个性化的，每个程序员都会有自己的喜好和见解。
在本书后续章节的相关内容中，将介绍一些编程中需要注意到的一些代码风格。 一些通用的风格，如每行尽量不超过80个字符，这个标准是有历史原因的，以前的编辑器一行只能显示80个字符，所以超过80字符，就得滚动才能看全。 现在的编辑器已没有这个限制，但是一行中有太长的代码依旧不利于程序员阅读;
使用有描述意义的变量名函数名，尽量不要使用简写。</description>
    </item>
    
    <item>
      <title>10.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/10.practice/</link>
      <pubDate>Mon, 17 Jul 2023 17:01:03 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/3.composition_of_bdl/10.practice/</guid>
      <description>练习#自定义一个函数，实现两个整数求和#找出以下代码的错误#database ds  main()  define a,b integer  define y integer  let a = 10 let b= 20  let y = add(a,b)  display sfmt(&amp;#34;\n the average is %1&amp;#34;,y) end main  function add(a,b)  define a,b integer  a+b end function </description>
    </item>
    
    <item>
      <title>5.practice</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/5.practice/</link>
      <pubDate>Thu, 20 Jul 2023 19:27:34 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/2.medium/13.struct/5.practice/</guid>
      <description></description>
    </item>
    
    <item>
      <title>5.练习</title>
      <link>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/5.practice/</link>
      <pubDate>Mon, 17 Jul 2023 14:48:01 +0800</pubDate>
      
      <guid>https://bdl.darcyjoven.com/docs/BDL/1.basic/2.first_code/5.practice/</guid>
      <description>练习#编程输出中文“你好，世界！”#输出5个空行，不显示任何字符或字#输出数字1、2、3、4、5，但是每行显示一个数字#</description>
    </item>
    
  </channel>
</rss>
